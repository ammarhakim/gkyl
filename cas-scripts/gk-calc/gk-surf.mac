load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("positivity-calc/fhatAL-calc")$
load("scifac")$
fpprec : 24$

wc : [wx, wy, wz, wv, wm]$
wc2 : [wx2, wy2, wz2, wv2, wm2]$
derivfac : [dfac_x, dfac_y, dfac_z, dfac_v, dfac_m]$
derivfac2 : [dfac_x2, dfac_y2, dfac_z2, dfac_v2, dfac_m2]$
gkvsub:[vx=vpar,vy=mu]$
gkvsubInv:[vpar=vx,mu=vy]$

let (wv^2, wv2)$
let (dfac_v^2, dfac_v2)$

cvars : [X, Y, Z]$
vvars : [Vpar, Mu]$

doMakeExprLst(vals, S) := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* set up some vector calculus functions */
load("vect")$
fgrad(f):= ev(express(grad(f)),diff)*derivfacsC$

gkPB(f,g):=1/m_*Bstar_by_Bmag_expd.(fgrad(f)*dfac_v*diff(g,vpar)-fgrad(g)*dfac_v*diff(f,vpar))-1/q_*BmagInv_expd*dfac_x*dfac_y*(diff(f,x)*diff(g,y)-diff(f,y)*diff(g,x))$

calcUpdateInDir(surfDir, fh, funcNm, cdim, vdim, basisFun, i,emflag, bvarslist, pureUpwind) := block([],
kill(varsC, varsP, basisC, basisP),
if vdim > 0 then modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")
else modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
load(modNm),
  if cdim = 1 then (
    label:["x", "v", "m"]
  ),
  if cdim = 2 then (
    label:["x", "y", "v", "m"]
  ),
  if cdim = 3 then (
    label:["x", "y", "z", "v", "m"]
  ),
  bC : basisC[i],
  if vdim=0 then bP : bC
  else bP : subst(gkvsub, basisP[i]),
  if vdim=0 then varsP : varsC
  else varsP : subst(gkvsub, varsP),
  numC : length(bC),
  volfac : 1,
  /* get surface variable */
  surfVar : varsP[surfDir],
  /* remove surface variable from integrand of surface integrals */
  surfIntVars : delete(surfVar,varsP),
  if surfDir <= cdim then dirlabel : cvars[surfDir]
  else dirlabel : vvars[surfDir-cdim],
  cellCenter : makelist(varsP[d]=0, d, 1, length(varsP)),
  /* set up ignorable variables for Bmag */
  Bignorevars: flatten(makelist([varsC[d]^2=var2,var2=1/3,varsC[d]=0], d, 1, length(varsC))),
  if bvarslist # [0] then (
    for i : 1 thru length(bvarslist) do (
      Bignorevars : delete( varsC[bvarslist[i]]=0, Bignorevars ),
      Bignorevars : delete( varsC[bvarslist[i]]^2=var2, Bignorevars )
  )),
  /* for grad and curl expressions */
  scalefactors(varsC),
  derivfacsC : makelist(derivfac[d], d, 1, length(varsC)),
  derivfacsV : makelist(derivfac[d], d, 4, 5),
  wC : makelist(wc[d], d, 1, length(varsC)),
  wV : makelist(wc[d], d, 4, 5),
  surfLabel : label[surfDir],
  if surfDir <= cdim then (dfacSurf : derivfacsC[surfDir], wSurf : wC[surfDir])
  else (dfacSurf : derivfacsV[surfDir-cdim], wSurf : wV[surfDir-cdim]),

  /* remove volume contribution from surface variable, which is not integrated */
  surfac : fullratsimp(volfac*dfacSurf),

  if emflag then printf(fh, "double ~a_~a_P~a_Bvars_~a(const double q_, const double m_, const double cfl, const double *w, const double *dxv, const double amax_in, const double *Bmag, const double *BmagInv, const double *Gradpar, const double *BdriftX, const double *BdriftY, const double *Phi, const double *Apar, const double *dApardt, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, dirlabel, i, simplode(bvarslist,"_"))
  else printf(fh, "double ~a_~a_P~a_Bvars_~a(const double q_, const double m_, const double cfl, const double *w, const double *dxv, const double amax_in, const double *Bmag, const double *BmagInv, const double *Gradpar, const double *BdriftX, const double *BdriftY, const double *Phi, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, dirlabel, i, simplode(bvarslist,"_")),
  printf(fh, "// w[NDIM]: Cell-center coordinates. dxv[NDIM]: Cell spacing. H/f: Input Hamiltonian/distribution function. out: Incremented output ~%"),

  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double dfac_~a = 2.0/dxv[~a]; ~%", label[dir], dir-1)
  ),

  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double w~a = w[~a]; ~%", label[dir], dir-1)
  ),
  if vdim>0 then (
    printf(fh, "  double wv2 = wv*wv; ~%"),
    printf(fh, "  double dfac_v2 = dfac_v*dfac_v; ~%")
  ),
  printf(fh, "  double q2 = q_*q_; ~%"),
  printf(fh, "  double incr[~a]; ~%", length(bP)),

  /* expand background magnetic field Bmag, assuming it only varies in x */
  Bmag_expd:subst(Bignorevars,doExpand1(Bmag,bC)),
  BmagInv_expd:subst(Bignorevars,doExpand1(BmagInv,bC)),
  /* expand Phi */
  Phi_expd:doExpand1(Phi,bC),

  if emflag then (
    /* expand Apar */
    Apar_expd:doExpand1(Apar,bC),
    /* expand dApar/dt */
    dAdt_expd:doExpand1(dApardt,bC)
    /* NOTE: even though Apar and dApar/dt are allowed
       to be discontinuous in the parallel (z) direction,
       the surface term in the z direction does not involve
       Apar. since Apar is continuous in the other directions,
       it does not matter if we use the right or left value */
  )
  else (
    Apar_expd : 0,
    dAdt_expd : 0
  ),

  /* calculate full expansion expression for Hamiltonian */
  H_full: q_*Phi_expd,
  if vdim > 0 then H_full : H_full + 1/2*m_*(wv + vpar/dfac_v)^2,
  if vdim > 1 then H_full : H_full + (wm+mu/dfac_m)*Bmag_expd,
  
  /* project Hamiltonian onto basis functions */
  H_k:fullratsimp(innerProd(varsP, 1, bP, H_full)),
  /* expand projected Hamiltonian on basis */
  H_expd:H_k.bP,

  /* expand distribution function on basis */
  fL_expd:doExpand1(fl,bP),
  fR_expd:doExpand1(fr,bP),

  /* expand BstarZ/Bmag = bhat.grad(z) = Gradpar on basis */
  BstarZ_by_Bmag_expd : subst(Bignorevars, doExpand1(Gradpar, bC)),

  /* expand BdriftX = 1/B*curl(bhat)*grad(x) on basis */
  BdriftX_expd : subst(Bignorevars, doExpand1(BdriftX, bC)),
  /* expand BdriftY = 1/B*curl(bhat)*grad(y) on basis */
  BdriftY_expd : subst(Bignorevars, doExpand1(BdriftY, bC)),
  /* expand BstarX/Bmag = ( m/q vpar + Apar ) BdriftX = (m/q vpar + Apar)/B*curl(bhat)*grad(x) on basis */
  BstarX_by_Bmag_expd : (m_/q_*(wv+vpar/dfac_v) + Apar_expd)*BdriftX_expd,
  /* expand BstarY/Bmag = ( m/q vpar + Apar ) BdriftY = (m/q vpar + Apar)/B*curl(bhat)*grad(y) on basis */
  BstarY_by_Bmag_expd : (m_/q_*(wv+vpar/dfac_v) + Apar_expd)*BdriftY_expd,
  /* make vApar = -bhatXgrad(Apar) vector */
  if cdim = 1 then vApar_expd : [0], 
  if cdim = 2 then vApar_expd : [diff(Apar_expd, y)*dfac_y, -diff(Apar_expd,x)*dfac_x],
  if cdim = 3 then vApar_expd : [diff(Apar_expd, y)*dfac_y, -diff(Apar_expd,x)*dfac_x, 0], 

  /* make Bstar/Bmag vector */
  if cdim = 1 then Bstar_by_Bmag_expd : [1],
  if cdim = 2 then Bstar_by_Bmag_expd : [BstarX_by_Bmag_expd, BstarY_by_Bmag_expd] + vApar_expd,
  if cdim = 3 then Bstar_by_Bmag_expd : [BstarX_by_Bmag_expd, BstarY_by_Bmag_expd, 1] + vApar_expd,

  /* calculate phase space velocity alpha in direction of surfVar */
  /* we assume alpha.n is continuous across boundary, although H may not be */
  alpha_expd : gkPB(wSurf + surfVar/dfacSurf, H_expd),
  if surfVar = vpar then alpha_expd : alpha_expd - q_/m_*dAdt_expd,
  /* calculate expression for surface-averaged alpha, and print to c variable alpha0 */
  alpha0expr : gcfac(fullratsimp(innerProd(surfIntVars, 1, subst(surfVar=-1,alpha_expd), subst(surfVar=-1, bP[1]))*bP[1])),
  printf(fh, "  // surface-averaged phase velocity in this direction ~%"),
  printf(fh, "  double alpha0 = ~a; ~%~%", float(subst([wv^2=wv2,q_^2=q2,dfac_v^2=dfac_v2], alpha0expr))),

  /* project full alpha expression onto full basis and print to c variable alpha */
  printf(fh, "  double alpha[~a]; ~%", length(bP)),
  alpha_k : fullratsimp(innerProd(varsP, 1, bP, alpha_expd)),
  writeCExprs1(alpha, gcfac(fullratsimp(subst([wv^2=wv2,dfac_v^2=dfac_v2, m_^2=m2, q_^2=q2], expand(facsum(alpha_k,derivfac)))))),
  alphaNoZero_k : doMakeExprLst(alpha_k, alpha),
  alpha_expd : doExpandLst(alphaNoZero_k, bP),

  /* note: always use pureUpwind for p=1 */
  if pureUpwind or i=1 then (
    /* evaluate alpha_expd at interior surface */
    alpha_expd : subst(surfVar=-1, alpha_expd),

    printf(fh, "  if (alpha0>0) { ~%"),
    if positivity then fhat : subst(gkvsub, fhatAL(fl, subst(gkvsubInv,surfVar), 1, cfl, cdim, vdim, i))
    else fhat : subst(surfVar=1, fL_expd),
    t : surfac*calcInnerProdList(surfIntVars, alpha_expd, subst(surfVar=-1, bP), fhat),
    incr_r : facsum(fullratsimp(t),dxv),
    writeCExprsNoExpand1(incr, subst([wv^2=wv2,q_^2=q2], incr_r)),
    printf(fh, "~%"),
    incr_s : makelist(incr[i-1], i, 1, length(bP)),
    writeCIncrExprsNoExpand1(outr, incr_s),  
    printf(fh, "~%"),
    t : surfac*calcInnerProdList(surfIntVars, alpha_expd, subst(surfVar=1, bP), fhat),
    incr_l : -t,
    signs : fullratsimp(incr_l/incr_r),
    incr_s : makelist(signs[i]*incr[i-1], i, 1, length(bP)),
    writeCIncrExprsNoExpand1(outl, incr_s),
    
    printf(fh, "  } else { ~%"),
    if positivity then fhat : subst(gkvsub, fhatAL(fr, subst(gkvsubInv,surfVar), -1, cfl, cdim, vdim, i))
    else fhat : subst(surfVar=-1, fR_expd),
    t : surfac*calcInnerProdList(surfIntVars, alpha_expd, subst(surfVar=-1, bP), fhat),
    incr_r : facsum(fullratsimp(t),dxv),
    writeCExprsNoExpand1(incr, subst([wv^2=wv2,q_^2=q2], incr_r)),
    printf(fh, "~%"),
    incr_s : makelist(incr[i-1], i, 1, length(bP)),
    writeCIncrExprsNoExpand1(outr, incr_s),  
    printf(fh, "~%"),
    t : surfac*calcInnerProdList(surfIntVars, alpha_expd, subst(surfVar=1, bP), fhat),
    incr_l : -t,
    signs : fullratsimp(incr_l/incr_r),
    incr_s : makelist(signs[i]*incr[i-1], i, 1, length(bP)),
    writeCIncrExprsNoExpand1(outl, incr_s),
    printf(fh, "  } ~%"),
    printf(fh, "  return std::abs(alpha0); ~%"),
    printf(fh, "} ~%"),
    flush_output(fh)
  ) else (
    /* determine whether to use local or global value for penalty amax */
    printf(fh, "  double amax = 0.0; ~%"),
    printf(fh, "  bool upwind = false; ~%"), 
    printf(fh, "  if(upwind) ~%"),
    printf(fh, "    amax = std::abs(alpha0); ~%"),
    printf(fh, "  else ~%"),
    printf(fh, "    amax = amax_in; ~%~%"),
    printf(fh, "  double Ghat[~a]; ~%", length(bP)),

    /* get signs = bP(-sv)/bP(sv) */
    basisFlip : subst(surfVar=-surfVar, bP),
    signs : float(fullratsimp(basisFlip/bP)),

    /* print C exprs for favg = fr(sv=-1) + fl(sv=1) */
    printf(fh, "  double favg[~a]; ~%~%", length(bP)),
    for c : 1 thru length(bP) do (
      printf(fh, "  favg[~a] = ~a*fr[~a]+fl[~a]; ~%", c-1, signs[c], c-1, c-1)
    ),
    flush_output(fh),

    /* print C exprs for fjump = fr(sv=-1) - fl(sv=1) */
    printf(fh, "  double fjump[~a]; ~%~%", length(bP)),
    for c : 1 thru length(bP) do (
      printf(fh, "  fjump[~a] = amax*(~a*fr[~a]-fl[~a]); ~%", c-1, signs[c], c-1, c-1)
    ),
    flush_output(fh),

    favg_expd : doExpand1(favg, bP),
    fjump_expd : doExpand1(fjump, bP),

    /* evaluate alpha_expd, favg_expd, and fjump_expd at surface */
    alpha_expd : subst(surfVar=-1, alpha_expd),
    fhat_average : subst(surfVar=1, favg_expd),
    fhat_jump : subst(surfVar=1, fjump_expd),

    Ghat_k : gcfac(fullratsimp(subst([wv^2=wv2,dfac_v^2=dfac_v2,q_^2=q2],innerProd(varsP, 1/2, bP, alpha_expd*fhat_average-fhat_jump)))),
    clst : makelist(alpha[i-1], i, 1, length(bP)),
    writeCExprsCollect1(Ghat, Ghat_k, clst),
    printf(fh, "~%"),
    flush_output(fh),
    /* these functions drop components of Ghat that are zero from list Ghatl */
    GhatNoZero_k : doMakeExprLst(Ghat_k, Ghat),
    Ghat_k : doExpandLst(GhatNoZero_k, bP),

/*
    /* calculate lax penalty flux expression */
    /* we evaluate at the boundary by evaluating the f_L (left) value at surfVar=1 and the f_R (right) value at surfVar=-1 */
    alpha_expd : subst(surfVar=-1, alpha_expd),
    Ghat_expd : fullratsimp(alpha_expd/2*(subst(surfVar=1, fL_expd)+subst(surfVar=-1, fR_expd))-amax/2*(subst(surfVar=-1, fR_expd)-subst(surfVar=1, fL_expd))),
    /* project flux expression onto basis functions */
    Ghat_k : gcfac(fullratsimp(subst([wv^2=wv2,dfac_v^2=dfac_v2,q_^2=q2],calcInnerProdList(varsP, 1, bP, Ghat_expd)))),
    /* print fluxl list to c array Ghat */
    writeCExprsNoExpand1(Ghat, Ghat_k),
    printf(fh, "~%"),
    flush_output(fh),
    /* these functions drop components of Ghat that are zero from list Ghatl */
    GhatNoZero_k : doMakeExprLst(Ghat_k, Ghat),
    Ghat_k : doExpandLst(GhatNoZero_k, bP),
*/

    /* evaluate contribution to right boundary (surfVar=-1) */
    incr_r : gcfac(fullratsimp(surfac*innerProd(surfIntVars, 1, subst(surfVar=-1, bP), subst(surfVar=-1,Ghat_k)))),
    writeCExprsNoExpand1(incr, incr_r),
    printf(fh, "~%"),
    incr_s : makelist(incr[i-1], i, 1, length(bP)),
    writeCIncrExprsNoExpand1(outr, incr_s),  
    printf(fh, "~%"),
    flush_output(fh),
    /* contribution to left boundary (surfVar=1) is same except for signs */
    incr_l : surfac*innerProd(surfIntVars, -1, subst(surfVar=1, bP), subst(surfVar=1, Ghat_k)),
    signs : fullratsimp(incr_l/incr_r),
    incr_s : makelist(signs[i]*incr[i-1], i, 1, length(bP)),
    writeCIncrExprsNoExpand1(outl, incr_s),
    /* return alpha0 so that we can find global value */
    printf(fh, "return std::abs(alpha0); ~%"),
    
    printf(fh, "} ~%"),
    flush_output(fh)
  )
)$

calcGKSurfUpdater(fh, funcNm, cdim, vdim, basisFun,p,emflag, bvarslist) := block([],
  if vdim = 0 then vd : 0
  else vd : 1,
  for dir : 1 thru cdim+vd do (
    /* always pure upwind in z direction */
    if (dir=cdim and cdim#2) then (
      pureUpwind : false
    ) else (
      pureUpwind : false
    ),
    calcUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun,p,emflag, bvarslist, pureUpwind) 
  )
)$

em:false$
for pos: 0 thru 1 do (
if pos=0 then positivity:false
else positivity:true,
if positivity then posString : "Positivity"
else posString : "",
for c : 1 thru 2 do (
for v: 1 thru 2 do (
if c=1 or (c>1 and v=2) then (
pmax:2,
if c=1 then (pmax:2),
if positivity then pmax:1,
for p:1 thru pmax do (
/* separate file for positivity implementation */
if em then fname : sconcat("~/max-out/EmGyrokineticSurf", posString, "Ser", c, "x", v, "vP", p, ".cpp")
else fname : sconcat("~/max-out/GyrokineticSurf", posString, "Ser", c, "x", v, "vP", p, ".cpp"),
fh : openw(fname),
printf(fh, "#include <GyrokineticModDecl.h> ~%"),
/* possible combinations of variable dependence of background magnetic field,
   with 0 = const, 1 = x, 2 = y, 3 = z.
   note that we assume axisymmetry, which means B cannot depend on y */
if c=1 then bvarslist : [[0], [1]],
if c=2 then bvarslist : [[0], [1]],
if c=3 then bvarslist : [[0], [1], [3], [1,3]],
for b : 1 thru length(bvarslist) do (
if em then (
funcName : sconcat("EmGyrokineticSurf", posString, c, "x", v, "v", "Ser"),
calcGKSurfUpdater(fh, funcName, c, v, "Ser", p, true, bvarslist[b])
) else (
funcName : sconcat("GyrokineticSurf", posString, c, "x", v, "v", "Ser"),
calcGKSurfUpdater(fh, funcName, c, v, "Ser", p, false, bvarslist[b])
)),
close(fh)
)))),
c:2,
v:0,
pmax:2,
if positivity then pmax:1,
for p:1 thru pmax do (
fname : sconcat("~/max-out/GyrokineticSurf", posString, "Ser", c, "x", v, "vP", p, ".cpp"),
fh : openw(fname),
printf(fh, "#include <GyrokineticModDecl.h> ~%"),
bvarslist : [[0]],
funcName : sconcat("GyrokineticSurf", posString, c, "x", v, "v", "Ser"),
calcGKSurfUpdater(fh, funcName, c, v, "Ser", p, false, [0]),
close(fh)
))$
