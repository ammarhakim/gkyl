load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

gkvsub:[vx=vpar,vy=mu];

wc : [wx, wy, wz, wv, wm];
wc2 : [wx2, wy2, wz2, wv2, wm2];
derivfac : [dfac_x, dfac_y, dfac_z, dfac_v, dfac_m];
derivfac2 : [dfac_x2, dfac_y2, dfac_z2, dfac_v2, dfac_m2];
gkvsub:[vx=vpar,vy=mu];

cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* set up some vector calculus functions */
load("vect");
fgrad(f):= ev(express(grad(f)),diff)*derivfacsC;
fcurl(f):= ev(express(curl(f)),diff);

gkPB(f,g):=Bstar_expd.fgrad(f)*derivfac[4]*diff(g,vpar)-Bstar_expd.fgrad(g)*derivfac[4]*diff(f,vpar)-mcByq*derivfac[1]*derivfac[2]*(diff(f,x)*diff(g,y)-diff(f,y)*diff(g,x));

calcGKVolUpdater(fh, funcNm, cdim, vdim, basisFun, pmax) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
load(modNm),
printf(fh, "#include <GyrokineticModDecl.h> ~%"),
for i : 1 thru pmax do (
  if cdim = 2 then (
    label:["x", "y", "v", "m"],
    derivfacList:[dfac_x, dfac_y, dfac_v, dfac_m]
  ),
  if cdim = 3 then (
    label:["x", "y", "z", "v", "m"],
    derivfacList:derivfac
  ),
  bP : subst(gkvsub, basisP[i]),
  bC : basisC[i],
  varsP : subst(gkvsub, varsP),
  numC : length(bC),
  printf(fh, "double ~aP~a(const double mcByq, const double *w, const double *dxv, const double *Bmag, const double *BcurvY, const double *Phi, const double *f, double *out) ~%{ ~%", funcNm, i),
  printf(fh, "// w[NDIM]: Cell-center coordinates. dxv[NDIM]: Cell spacing. H/f: Input Hamiltonian/distribution function. out: Incremented output ~%"),
  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  volfac : 1,
  cellCenter : makelist(varsP[d]=0, d, 1, length(varsP)),
  Bvars:[y=0,z=0], /* this makes it so that Bmag is assumed to only vary in x */
  /* for grad and curl expressions */
  scalefactors(varsC),
  derivfacsC : makelist(derivfac[d], d, 1, length(varsC)),

  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double d~aInv = 1.0/dxv[~a]; ~%", label[dir], dir-1)
  ),
  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double dfac_~a = 2.0*d~aInv; ~%", label[dir], label[dir])
  ),

  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double w~a = w[~a]; ~%", label[dir], dir-1)
  ),
  printf(fh, "  double wv2 = wv*wv; ~%"),
  printf(fh, "  double dfac_v2 = 4.0*dvInv*dvInv; ~%"),

  /* expand background magnetic field Bmag, assuming it only varies in x */
  Bmag_expd:subst(Bvars,doExpand1(Bmag,bC)),
  /* expand Phi */
  Phi_expd:doExpand1(Phi,bC),

  /* calculate full expansion expression for Hamiltonian */
  H_full:vpar^2/(2*derivfac2[4])+(wc[4]*vpar)/derivfac[4]+wc2[4]/2 + (wc[5]+mu/derivfac[5])*Bmag_expd + Phi_expd,
  /* project Hamiltonian onto basis functions */
  H_k:fullratsimp(innerProd(varsP, 1, bP, H_full)),
  /* expand projected Hamiltonian on basis */
  H_expd:H_k.bP,

  /* expand distribution function on basis */
  f_expd:doExpand1(f,bP),

  /* expand BcurvY = curl(bhat) on basis, assuming it only varies in x */
  BcurvY_expd : subst(Bvars, doExpand1(BcurvY, bC)),
  /* expand BstarY = mc/q vpar BcurvY on basis */
  BstarY_expd : mcByq*(wc[4]+vpar/derivfac[4])*BcurvY_expd,
  /* make Bstar vector */
  if cdim = 2 then Bstar_expd : [0, BstarY_expd],
  if cdim = 3 then Bstar_expd : [0, BstarY_expd, Bmag_expd],

  /* calculate GK poisson bracket of basis functions and Hamiltonian */
  gkPB_basis : fullratsimp(gkPB(bP, H_expd)),

  /* calculate volume term, which is inner product < f {basisFunction, H} > */
  gkVolTerm_k : fullratsimp(innerProd(varsP, 1, f_expd, gkPB_basis)),

  /* write C increment expressions for volume term */
  writeCIncrExprsNoExpand(float(subst([wv^2=wv2, dfac_v^2=dfac_v2], facsum(gkVolTerm_k,[derivfac,wc])))),

  /* calculate cflFeq = sum_d alpha_d / dxv[d] */
  printf(fh, "  double cflFreq = 0.0; ~%"), 
  /* note: no contribution from mu */
  for d : 1 thru cdim+1 do (
    /* calculate phase space velocity alpha_d = {z[d], H} = dz[d]/dt*/
    alpha_expd : gkPB(wc[d] + varsP[d]/derivfacList[d], H_expd),
    /* take cell center value */
    alpha0 : subst(cellCenter, alpha_expd),
    /* write to increment cflFreq */
    printf(fh, "  cflFreq += fabs(~a)*d~aInv; ~%", float(subst(wv^2=wv2, alpha0)), label[d])
  ),

  printf(fh, "  return cflFreq; ~%"),
  printf(fh, "} ~%")
));

pmax:1;
for c : 2 thru 3 do (
v:2,
fname : sconcat("~/max-out/GyrokineticSer", c, "x", v, "v", ".cpp"),
fh : openw(fname),
funcName : sconcat("GyrokineticVol", c, "x", v, "v", "Ser"),
calcGKVolUpdater(fh, funcName, c, v, "Ser", pmax),
close(fh)
);
