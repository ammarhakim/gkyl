load("modal-basis")$
load("out-scripts")$
load(stringproc)$
fpprec : 24$

wc : [wx, wy, wz, wv, wm]$
wc2 : [wx2, wy2, wz2, wv2, wm2]$
derivfac : [dfac_x, dfac_y, dfac_z, dfac_v, dfac_m]$
derivfac2 : [dfac_x2, dfac_y2, dfac_z2, dfac_v2, dfac_m2]$
gkvsub:[vx=vpar,vy=mu]$

let (wv^2, wv2)$
let (dfac_v^2, dfac_v2)$

cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* set up some vector calculus functions */
load("vect")$
fgrad(f):= ev(express(grad(f)),diff)*derivfacsC$

gkPB(f,g):=1/m_*(Bstar_by_Bmag_expd.fgrad(f)*dfac_v*diff(g,vpar)-Bstar_by_Bmag_expd.fgrad(g)*dfac_v*diff(f,vpar))-1/q_*BmagInv_expd*dfac_x*dfac_y*(diff(f,x)*diff(g,y)-diff(f,y)*diff(g,x))$

calcGKVolUpdater(fh, funcNm, cdim, vdim, basisFun, pmax, emflag) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
load(modNm),
for i : 1 thru pmax do (
  if cdim = 1 then (
    label:["x", "v", "m"]
  ),
  if cdim = 2 then (
    label:["x", "y", "v", "m"]
  ),
  if cdim = 3 then (
    label:["x", "y", "z", "v", "m"]
  ),
  bP : subst(gkvsub, basisP[i]),
  bC : basisC[i],
  varsP : subst(gkvsub, varsP),
  numC : length(bC),

  if emflag then printf(fh, "double ~aP~a(const double q_, const double m_, const double *w, const double *dxv, const double *Bmag, const double *BmagInv, const double *BcurvY, const double *Phi, const double *Apar, const double *f, double *out) ~%{ ~%", funcNm, i)
  else printf(fh, "double ~aP~a(const double q_, const double m_, const double *w, const double *dxv, const double *Bmag, const double *BmagInv, const double *BcurvY, const double *Phi, const double *f, double *out) ~%{ ~%", funcNm, i),

  printf(fh, "// w[NDIM]: Cell-center coordinates. dxv[NDIM]: Cell spacing. H/f: Input Hamiltonian/distribution function. out: Incremented output ~%"),
  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  volfac : 1,
  cellCenter : makelist(varsP[d]=0, d, 1, length(varsP)),
  Bvars:[y=0,z=0], /* this makes it so that Bmag is assumed to only vary in x */
  /* for grad and curl expressions */
  scalefactors(varsC),
  derivfacsC : makelist(derivfac[d], d, 1, length(varsC)),
  derivfacsV : makelist(derivfac[d], d, 4, 5),
  wC : makelist(wc[d], d, 1, length(varsC)),
  wV : makelist(wc[d], d, 4, 5),

  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double d~aInv = 1.0/dxv[~a]; ~%", label[dir], dir-1)
  ),
  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double dfac_~a = 2.0/dxv[~a]; ~%", label[dir], dir-1)
  ),

  for dir : 1 thru cdim+vdim do (
    printf(fh, "  double w~a = w[~a]; ~%", label[dir], dir-1)
  ),
  printf(fh, "  double wv2 = wv*wv; ~%"),
  printf(fh, "  double dfac_v2 = dfac_v*dfac_v; ~%"),
  printf(fh, "  double q2 = q_*q_; ~%"),
  printf(fh, "  double m2 = m_*m_; ~%"),

  /* expand background magnetic field Bmag, assuming it only varies in x */
  Bmag_expd:subst(Bvars,doExpand1(Bmag,bC)),
  BmagInv_expd:subst(Bvars,doExpand1(BmagInv,bC)),
  /* expand Phi */
  Phi_expd:doExpand1(Phi,bC),
  if emflag then (
    /* expand Apar */
    Apar_expd:doExpand1(Apar,bC)
  )
  else (
    Apar_expd : 0
  ),

  /* calculate full expansion expression for Hamiltonian. */
  H_full:1/2*m_*(wv + vpar/dfac_v)^2 + q_*Phi_expd,
  if vdim > 1 then H_full : H_full + (wm+mu/dfac_m)*Bmag_expd,

  /* project Hamiltonian onto basis functions */
  H_k:fullratsimp(innerProd(varsP, 1, bP, H_full)),
  /* expand projected Hamiltonian on basis */
  H_expd:H_k.bP,

  /* expand distribution function on basis */
  f_expd:doExpand1(f,bP),

  /* expand BcurvY = 1/B*curl(bhat)*grad(y) on basis, assuming it only varies in x */
  BcurvY_expd : subst(Bvars, doExpand1(BcurvY, bC)),
  /* expand BstarY/Bmag = ( m/q vpar + Apar ) BcurvY = (m/q vpar + Apar)/B*curl(bhat)*grad(y) on basis */
  BstarY_by_Bmag_expd : (m_/q_*(wv+vpar/dfac_v) + Apar_expd)*BcurvY_expd,
  /* make vApar = -bhatXgrad(Apar) vector */
  if cdim = 1 then vApar_expd : [0], 
  if cdim = 2 then vApar_expd : [diff(Apar_expd, y)*dfac_y, -diff(Apar_expd,x)*dfac_x],
  if cdim = 3 then vApar_expd : [diff(Apar_expd, y)*dfac_y, -diff(Apar_expd,x)*dfac_x, 0], 

  /* make Bstar/Bmag vector */
  if cdim = 1 then Bstar_by_Bmag_expd : [1],
  if cdim = 2 then Bstar_by_Bmag_expd : [0, BstarY_by_Bmag_expd] + vApar_expd,
  if cdim = 3 then Bstar_by_Bmag_expd : [0, BstarY_by_Bmag_expd, 1] + vApar_expd,

  /* calculate alpha.grad(bP) = {bP, H} = GK poisson bracket of basis functions and Hamiltonian */
  gkPB_basis : fullratsimp(gkPB(bP, H_expd)),

  /* calculate volume term, which is inner product
     < f alpha.grad(bP) > = < f {bP, H} > */
  gkVolTerm_k : fullratsimp(innerProd(varsP, 1, f_expd, gkPB_basis)),

  /* write C increment expressions for volume term */
  writeCIncrExprsNoExpand(float(subst([wv^2=wv2,dfac_v^2=dfac_v2, m_^2=m2, q_^2=q2], facsum(gkVolTerm_k,derivfac)))),

  /* calculate cflFeq = sum_d alpha_d / dxv[d] */
  printf(fh, "  double cflFreq = 0.0; ~%"), 
  for d : 1 thru cdim do (
    /* calculate phase space velocity alpha_d = {z[d], H} = dz[d]/dt*/
    /* also include factor of jacobian = Bmag */
    alpha_expd : Bmag_expd*gkPB(wC[d] + varsP[d]/derivfacsC[d], H_expd),
    /* take cell center value */
    alpha0 : subst(cellCenter, alpha_expd),
    /* write to increment cflFreq */
    printf(fh, "  cflFreq += fabs(~a)*d~aInv; ~%", float(letsimp(alpha0)), label[d])
  ),
  /* note: no contribution from mu */
  for d : cdim+1 thru cdim+1 do (
    /* calculate phase space velocity alpha_d = {vpar, H} = dvpar/dt */
    /* also include factor of jacobian = Bmag */
    alpha_expd : Bmag_expd*gkPB(wV[d-cdim] + varsP[d]/derivfacsV[d-cdim], H_expd),
    /* take cell center value */
    alpha0 : subst(cellCenter, alpha_expd),
    /* write to increment cflFreq */
    printf(fh, "  cflFreq += fabs(~a)*d~aInv; ~%", float(letsimp(alpha0)), label[d])
  ),

  printf(fh, "  return cflFreq; ~%"),
  printf(fh, "} ~%")
))$

calcdAdtVolUpdater(fh, funcNm, cdim, vdim, basisFun, pmax) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
load(modNm),
for i : 1 thru pmax do (
  if cdim = 1 then (
    label:["x", "v", "m"]
  ),
  if cdim = 2 then (
    label:["x", "y", "v", "m"]
  ),
  if cdim = 3 then (
    label:["x", "y", "z", "v", "m"]
  ),
  bP : subst(gkvsub, basisP[i]),
  bC : basisC[i],
  varsP : subst(gkvsub, varsP),
  numC : length(bC),

  printf(fh, "double ~aP~a(const double q_, const double m_, const double *w, const double *dxv, const double *Bmag, const double *dApardt, const double *f, double *out) ~%{ ~%", funcNm, i),

  printf(fh, "  double dvInv = 1.0/dxv[~a]; ~%", cdim),
  printf(fh, "  double dfac_v = 2.0/dxv[~a]; ~%", cdim),

  /* expand background magnetic field Bmag, assuming it only varies in x */
  Bmag_expd:subst(Bvars,doExpand1(Bmag,bC)),
  /* expand dApar/dt */
  dAdt_expd:doExpand1(dApardt,bC),

  /* calculate volume term, which is inner product
     < - f q/m dApar/dt d/dvpar(bP) > */
  gkVolTerm_k : fullratsimp(innerProd(varsP, 1, f_expd, -q_/m_*dAdt_expd*diff(bP,vpar)*dfac_v)),

  /* write C increment expressions for volume term */
  writeCIncrExprsNoExpand(float(subst([wv^2=wv2,dfac_v^2=dfac_v2, m_^2=m2, q_^2=q2], facsum(gkVolTerm_k,derivfac)))),

  /* calculate phase space velocity (only in vpar direction for this term) alpha_v = - q/m dApar/dt */
  /* also include factor of jacobian = Bmag */
  alpha_expd : -q_/m_*Bmag_expd*dAdt_expd,
  /* take cell center value */
  alpha0 : subst(cellCenter, alpha_expd),
  /* return cflFreq = alpha/dv */
  printf(fh, "  return fabs(~a)*dvInv; ~%", float(letsimp(alpha0))),
  printf(fh, "} ~%")
))$

pmax:1$
for c : 1 thru 3 do (
v:2,
if c=1 then v:1,
fname : sconcat("~/max-out/GyrokineticSer", c, "x", v, "v", ".cpp"),
fh : openw(fname),
printf(fh, "#include <GyrokineticModDecl.h> ~%"),
funcName : sconcat("GyrokineticVol", c, "x", v, "v", "Ser"),
calcGKVolUpdater(fh, funcName, c, v, "Ser", pmax, false),
funcName : sconcat("EmGyrokineticVol", c, "x", v, "v", "Ser"),
calcGKVolUpdater(fh, funcName, c, v, "Ser", pmax, true),
funcName : sconcat("dAdtVol", c, "x", v, "v", "Ser"),
calcdAdtVolUpdater(fh, funcName, c, v, "Ser", pmax),
close(fh)
)$
