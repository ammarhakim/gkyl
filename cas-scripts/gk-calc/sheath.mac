load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

gkvsub:[vx=vpar,vy=mu];

calcGkSheathFuncs(fh, cdim, vdim, basisFun, pmax) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
load(modNm),
for p : 1 thru pmax do (
  bP : subst(gkvsub, basisP[p]),
  bC : basisC[p],

/* function to compute surface-average deltaPhi */
  funcNm : sconcat("calcSheathDeltaPhi", cdim, "x", basisFun),

  /* get name of last config space dimension, which is assumed to be z */
  zVar : varsC[cdim],

  phiSheath_expd : subst(zVar=zVal,doExpand1(phi, bC)),
  /* assume wall potential specified without z dependence */
  phiWall_expd : subst(zVar=0,doExpand1(phiWall, bC)),

  deltaPhi_expd : phiSheath_expd - phiWall_expd,
  /* we will use surface-center value. we already got rid of zVar, but we need to set other config coords to 0 */
  deltaPhi0 : subst([x=0,y=0,z=0], deltaPhi_expd),
  /* only print for vdim==2 so that don't duplicate */
  if vdim=2 then (
  printf(fh, "double ~a_P~a(const double *phi, const double *phiWall, const double zVal) ~%{ ~%", funcNm, p),
  if p=2 then printf(fh, "  double zVal2 = zVal*zVal; ~%"),
  printf(fh, "  return ~a; ~%", subst(zVal^2=zVal2, float(deltaPhi0))),
  printf(fh, "}~%~%")
  ),

/* function to compute scaled partially-reflected distribution fhat */

  funcNm : sconcat("calcSheathPartialReflectionScaled", cdim, "x", vdim, "v", basisFun),
  printf(fh, "void ~a_P~a(const double wv, const double dv, const double zVal, const double vcut, const double *f, double *fhat) ~%{ ~%", funcNm, p),

  varsP : subst(gkvsub, varsP),
  if vdim=1 then varsV:[vpar] else varsV:[vpar,mu],

  edgesub : [zVar=zVal],

  printf(fh, "  double u[~a]; ~%", length(bC)),
  printf(fh, "  double uhat[~a]; ~%", length(bC)),
  printf(fh, "  double c[~a]; ~%", length(bC)),

  powersimp:[zVal^2=zVal2, wv^2=wv2, wv^3=wv3, wv^4=wv4, wv^5=wv5, vcut^2=vcut2, vcut^3=vcut3, vcut^4=vcut4, vcut^5=vcut5, dv^2=dv2, dv^3=dv3, dv^4=dv4, dv^5=dv5],
  printf(fh, "  double zVal2 = zVal*zVal; ~%"),
  printf(fh, "  double wv2 = wv*wv; ~%"),
  printf(fh, "  double wv3 = wv2*wv; ~%"),
  printf(fh, "  double wv4 = wv3*wv; ~%"),
  printf(fh, "  double wv5 = wv4*wv; ~%"),
  printf(fh, "  double dv2 = dv*dv; ~%"),
  printf(fh, "  double dv3 = dv2*dv; ~%"),
  printf(fh, "  double dv4 = dv3*dv; ~%"),
  printf(fh, "  double dv5 = dv4*dv; ~%"),
  printf(fh, "  double vcut2 = vcut*vcut; ~%"),
  printf(fh, "  double vcut3 = vcut2*vcut; ~%"),
  printf(fh, "  double vcut4 = vcut3*vcut; ~%"),
  printf(fh, "  double vcut5 = vcut4*vcut; ~%"),

  /* expand f and fhat */
  f_expd : doExpand1(f, bP),

  /* make sure velocity integration vars are first, and remove z from integral */
  /* we do this in case vcut depends on x and y at some point */
  intVars : flatten([varsV,varsC]),
  lims : makelist([-1,1],i,1,length(varsP)),
  cutlims : makelist([-1,1],i,1,length(varsP)),
  
  /* flux projected onto conf basis evaluated at z surface */
  u_k:fullratsimp(innerProdGen(intVars,lims,bC, wv + dv/2*vpar, subst(edgesub,f_expd))),
  writeCExprsWithZerosNoExpand1(u, fullratsimp(subst(powersimp, u_k))),

  printf(fh, "  if(wv > 0) {~%"),
  /* first velocity dim is always vpar, and we need to modify the upper integration limit */
  cutlims[1] : [-1,2*(vcut-wv)/dv],
  /* flux projected onto conf basis, but with modified upper vpar limit, evaluated at z surface */
  uhat_k:fullratsimp(innerProdGen(intVars,cutlims,bC, wv + dv/2*vpar, subst(edgesub,f_expd))),
  writeCExprsWithZerosNoExpand1(uhat, fullratsimp(subst(powersimp, uhat_k))),
  printf(fh, "  } else {~%"),
  /* first velocity dim is always vpar, and we need to modify the upper integration limit */
  cutlims[1] : [2*(-vcut-wv)/dv,1],
  /* flux projected onto conf basis, but with modified upper vpar limit, evaluated at z surface */
  uhat_k:fullratsimp(innerProdGen(intVars,cutlims,bC, wv + dv/2*vpar, subst(edgesub,f_expd))),
  writeCExprsWithZerosNoExpand1(uhat, fullratsimp(subst(powersimp, uhat_k))),
  printf(fh, "  }~%~%"),
  printf(fh, "  // account for rare positivity issues ~%"),
  printf(fh, "  if (u[0]*uhat[0]<0) {~%"),
  printf(fh, "  if(wv > 0) {~%"),
  /* first velocity dim is always vpar, and we need to modify the upper integration limit */
  cutlims[1] : [-1,2*(vcut-wv)/dv],
  /* flux projected onto conf basis, but with modified upper vpar limit, evaluated at z surface */
  uhat_k:fullratsimp(innerProdGen(intVars,cutlims,bC, wv + dv/2*vpar, subst(vpar=wv,subst(edgesub,f_expd)))),
  writeCExprsWithZerosNoExpand1(uhat, fullratsimp(subst(powersimp, uhat_k))),
  printf(fh, "  } else {~%"),
  /* first velocity dim is always vpar, and we need to modify the upper integration limit */
  cutlims[1] : [2*(-vcut-wv)/dv,1],
  /* flux projected onto conf basis, but with modified upper vpar limit, evaluated at z surface */
  uhat_k:fullratsimp(innerProdGen(intVars,cutlims,bC, wv + dv/2*vpar, subst(vpar=wv,subst(edgesub,f_expd)))),
  writeCExprsWithZerosNoExpand1(uhat, fullratsimp(subst(powersimp, uhat_k))),
  printf(fh, "  }~%"),
  printf(fh, "  } ~%~%"),

  printf(fh, "  // calculate c = uhat/u ~%"),
  printf(fh, "  CartFieldBinOpDivide~ax~a_P~a(u, uhat, 1, 1, c); ~%", cdim, basisFun, p),

  printf(fh, "  // calculate fhat = c*f ~%"),
  printf(fh, "  CartFieldBinOpMultiply~ax~av~a_P~a(c, f, 1, 1, fhat); ~%", cdim, vdim, basisFun, p),

  printf(fh, "} ~%~%"),

/* function to compute weak-equivalent partially-reflected distribution fhat */

writeWeakEquiv:false,

if writeWeakEquiv then (
  funcNm : sconcat("calcSheathPartialReflectionWeakEquiv", cdim, "x", vdim, "v", basisFun),
  printf(fh, "void ~a_P~a(const double wv, const double dv, const double zVal, const double vcut, const double *f, double *fhat) ~%{ ~%", funcNm, p),

  varsP : subst(gkvsub, varsP),
  if vdim=1 then varsV:[vpar] else varsV:[vpar,mu],

  edgesub : [zVar=zVal],

  /* expand f at upper z edge */
  f_expd : subst(edgesub, doExpand1(f, bP)),
  /* we also expand fhat at the upper z edge, but we don't care about
     z dependence of fhat, so we just take z=0 in the expansion */
  fhat_expd : subst(zVar=0, doExpand1(fhat, bP)),

  /* make sure velocity integration vars are first, and remove z from integral */
  /* we do this in case vcut depends on x and y at some point */
  intVars : flatten([varsV,delete(zVar,varsC)]),
  lims : makelist([-1,1],i,1,length(varsP)-1),
  cutlims : makelist([-1,1],i,1,length(varsP)-1),
  /* first velocity dim is always vpar, and we need to modify the upper integration limit */
  cutlims[1] : [-1,2*(vcut-wv)/dv],

  bPz : subst(edgesub,bP),
  
  /* project f onto basis at z surface */
  f_k:fullratsimp(innerProdGen(intVars,lims,1,bPz,f_expd)),

  /* project fhat onto basis at z surface, but with modified upper vpar limit */
  fhat_k:fullratsimp(innerProdGen(intVars,cutlims,1,bPz,fhat_expd)),

  /* set up system to solve weak-equivalence */
  eqns : makelist(f_k[i]=fhat_k[i],i,1,length(fhat_k)),
  sol : fullratsimp(linsolve(eqns,makelist(fhat[i],i,0,length(fhat_k)-1))),

  /* substitute fhat solution into fhat expansion, and then 
     project onto entire basis (instead of just basis at surface)
     this gets rid of any redundancy in solution */
  sol_k : fullratsimp(innerProd(varsP, 1, bP, subst(sol, fhat_expd))),
  /* get common denominator */
  denomExpr : denom(fullratsimp(subst(sol,fhat_expd))),

  powersimp:[zVal^2=zVal2, wv^2=wv2, wv^3=wv3, wv^4=wv4, wv^5=wv5, wv^6=wv6, wv^7=wv7, wv^8=wv8, wv^9=wv9, vcut^2=vcut2, vcut^3=vcut3, vcut^4=vcut4, vcut^5=vcut5, vcut^6=vcut6, vcut^7=vcut7, vcut^8=vcut8, vcut^9=vcut9, dv^2=dv2, dv^3=dv3, dv^4=dv4, dv^5=dv5, dv^6=dv6, dv^7=dv7, dv^8=dv8, dv^9=dv9, dv^10=dv10],
  printf(fh, "  double zVal2 = zVal*zVal; ~%"),
  printf(fh, "  double wv2 = wv*wv; ~%"),
  printf(fh, "  double wv3 = wv2*wv; ~%"),
  printf(fh, "  double wv4 = wv3*wv; ~%"),
  printf(fh, "  double wv5 = wv4*wv; ~%"),
  printf(fh, "  double wv6 = wv5*wv; ~%"),
  printf(fh, "  double wv7 = wv6*wv; ~%"),
  printf(fh, "  double wv8 = wv7*wv; ~%"),
  printf(fh, "  double wv9 = wv8*wv; ~%"),
  printf(fh, "  double dv2 = dv*dv; ~%"),
  printf(fh, "  double dv3 = dv2*dv; ~%"),
  printf(fh, "  double dv4 = dv3*dv; ~%"),
  printf(fh, "  double dv5 = dv4*dv; ~%"),
  printf(fh, "  double dv6 = dv5*dv; ~%"),
  printf(fh, "  double dv7 = dv6*dv; ~%"),
  printf(fh, "  double dv8 = dv7*dv; ~%"),
  printf(fh, "  double dv9 = dv8*dv; ~%"),
  printf(fh, "  double dv10 = dv9*dv; ~%"),
  printf(fh, "  double vcut2 = vcut*vcut; ~%"),
  printf(fh, "  double vcut3 = vcut2*vcut; ~%"),
  printf(fh, "  double vcut4 = vcut3*vcut; ~%"),
  printf(fh, "  double vcut5 = vcut4*vcut; ~%"),
  printf(fh, "  double vcut6 = vcut5*vcut; ~%"),
  printf(fh, "  double vcut7 = vcut6*vcut; ~%"),
  printf(fh, "  double vcut8 = vcut7*vcut; ~%"),
  printf(fh, "  double vcut9 = vcut8*vcut; ~%"),

  printf(fh, "  double denom = ~a; ~%", subst(powersimp, denomExpr)),
  writeCExprsWithZerosNoExpand1(fhat, fullratsimp(subst(powersimp, expand(sol_k*denomExpr/denom)))),

  printf(fh, "} ~%~%")
)
))$

fname : "~/max-out/GkSheathFuncsSer.cpp";
fh : openw(fname);
printf(fh, "#include <GyrokineticModDecl.h> ~%");
printf(fh, "#include <CartFieldBinOpModDecl.h> ~%");
for c : 1 thru 3 do (
for v: 1 thru 2 do (
if c=1 or (c>1 and v=2) then (
pmax:2,
if c=1 and v=1 then (pmax:2),
calcGkSheathFuncs(fh, c, v, "Ser", pmax)
)));
close(fh);
