load("modal-basis");
load("out-scripts");
load(stringproc)$
load("fem-calc/femMatrices")$
fpprec : 24$

gkvsub:[vx=vpar,vy=mu];


calcGkSheathFuncs(fh, cdim, vdim, basisFun, pmax) := block([],
kill(varsC, varsP, basisC, basisP),
load("basis-precalc/basisSer1x"),
basisVp : subst([x=vx],basisC),
basisMu : subst([x=vy],basisC),
load("basis-precalc/basisSer2x"),
basisXY : basisC,
basisVpMu : subst([x=vx,y=vy],basisC),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
load(modNm),
for p : 1 thru pmax do (
  bP : basisP[p],
  bC : basisC[p],
  bXY : basisXY[p],
  bVp : basisVp[p],
  bMu : basisMu[p],
  bVpMu : basisVpMu[p],

  /* get name of last config space dimension, which is assumed to be z */
  zVar : varsC[cdim],
  surfVars : delete(zVar, varsP),
  surfVarsC : delete(zVar, varsC),
  surfVarsP : delete(vx, surfVars),

  funcNm : sconcat("calcSheathReflection", cdim, "x", vdim, "v", basisFun),
  printf(fh, "void ~a_P~a(const double wv, const double dv, const double vlowerSq, const double vupperSq, const double zVal, const double q_, const double m_, const double *phi, const double *phiWall, const double *f, double *fRefl) ~%{ ~%", funcNm, p),

  /* calculate expansion for deltaPhi */
  phiSheath_expd : subst(zVar=zVal,doExpand1(phi, bC)),
  phiWall_expd : subst(zVar=zVal,doExpand1(phiWall, bC)),

  deltaPhi_expd : phiSheath_expd - phiWall_expd,

  /* set up quadrature nodes */
  if p=1 then quad:1/sqrt(3),
  if p=2 then quad:sqrt(3/5),
  nodesXY : eval_string(sconcat("nodes2xp", p))*quad,
  nodesXYsub(f) := makelist(subst(makelist(surfVarsC[j]=nodesXY[i][j],j,1,length(surfVarsC)),f),i,1,length(nodesXY)),
  nodesMu : eval_string(sconcat("nodes1xp", p))*quad,
  nodesMusub(f) := makelist(subst(makelist(vy=nodesMu[i][j],j,1,1),f),i,1,length(nodesMu)),

  /* evaluate deltaPhi at x,y quadrature nodes */
  deltaPhiQ : nodesXYsub(deltaPhi_expd),

  /* evaluate f at z surface, and x,y quadrature nodes */
  fSurf_expd : subst(zVar=zVal, doExpand1(f, bP)),
  fXYQ_expd : nodesXYsub(fSurf_expd),
  
  kill(fReflXYQ_expd),
  kill(fReflXYMuQ_expd),
  fReflXYQ_expd : makelist(0, i,1,length(bVpMu)),
  fReflXYMuQ_expd : makelist(0, i,1,length(bMu)),
  /* evaluate and write vcut^2 at x,y quadrature nodes */
  vcutSqQ:gcfac(float(fullratsimp(-2*q_/m_*deltaPhiQ))),
  /* for each x,y quadrature node, determine and write coefficients for vpar,mu modal basis (bVpMu) */
  printf(fh, "  double vcutSq_i, xc, xcSq, b; ~%"),
  printf(fh, "  double wvSq = wv*wv; ~%"),
  printf(fh, "  double dvSq = dv*dv; ~%"),
  printf(fh, "  double fReflXYQuad[~a][~a]; ~%", length(nodesXY), length(bVpMu)),
  printf(fh, "  double fReflXYMuQuad[~a][~a]; ~%", length(nodesMu), length(bVp)),
  printf(fh, "  ~%~%"),
  for i:1 thru length(nodesXY) do (
    printf(fh, "// quadrature node (x,y)_i=~a ~%", i),
    printf(fh, "  vcutSq_i = ~a; ~%", vcutSqQ[i]),
    printf(fh, "  if(vcutSq_i <= vlowerSq) { // absorb (no reflection) ~%"),
    writeCExprsWithZerosNoExpand1(fReflXYQuad[i-1], makelist(0.,j,1,length(bVpMu))),
    printf(fh, "  } else if(vcutSq_i > vupperSq) { // full reflection ~%"),
    /* project f at this (x,y)_i quad node onto vpar,mu basis (bVpMu) */
    fXYQ_VpMu_c : gcfac(fullratsimp(innerProd([vx,vy], 1, bVpMu, fXYQ_expd[i]))),
    writeCExprsNoExpand1(fReflXYQuad[i-1], fXYQ_VpMu_c),
    printf(fh, "  } else { // partial reflection ~%"),
      /* also evaluate at mu quad nodes */
      fXYMuQ_expd : nodesMusub(fXYQ_expd[i]),
      for j:1 thru length(nodesMu) do (
        /* project f at this (x,y)_i,mu_j quad node onto vpar basis (bVp) */
        fXYMuQ_Vp_c : gcfac(fullratsimp(innerProd([vx], 1, bVp, fXYMuQ_expd[j]))),
        /*beta:invL(gcfac(float(fXYMuQ_Vp_c[2]/sqrt(3)/fXYMuQ_Vp_c[1]))),
        printf(fh, "  b = ~a; ~%", beta),*/
        printf(fh, "  if(wv > 0) {~%"),
        printf(fh, "  xc = ~a; ~%", 2*(sqrt(vcutSq_i)-wv)/dv),
        printf(fh, "  xcSq = ~a; ~%", subst([wv^2=wvSq,dv^2=dvSq],expand((2*(sqrt(vcutSq_i)-wv)/dv)^2))),
        /*fReflfacs : [ "(exp(b*xc)-exp(-b))/2/sinh(b)", 
            "((b*xc-1)*exp(b*xc)+(b+1)*exp(-b))/2/(b*cosh(b)-sinh(b))",
            "(((b*(3*b*xc*xc-(6*xc+b))+6)*exp(b*xc))/3-(2*(b*b+3*(b+1))*exp(-b))/3)/(-4*b*cosh(b) + 4/3*(3 + b*b)*sinh(b))"],*/
        cutlims : [-1,xc],
        uhat : fullratsimp(innerProdGen([vx], [cutlims], 1, wv+dv/2*vx, fXYMuQ_expd[j])),
        u : fullratsimp(innerProd([vx], 1, wv+dv/2*vx, fXYMuQ_expd[j])),
        fReflfacs : subst([xc^2=xcSq,wv^2=wvSq,dv^2=dvSq],gcfac(float(fullratsimp(uhat/u)))),
        for k:1 thru length(bVp) do (
          printf(fh, "  fReflXYMuQuad[~a][~a] = ~a*~a; ~%", j-1, k-1, gcfac(float(fXYMuQ_Vp_c[k])), fReflfacs)
        ),
        printf(fh, "  } else { ~%"),
        printf(fh, "  xc = ~a; ~%", 2*(-sqrt(vcutSq_i)-wv)/dv),
        printf(fh, "  xcSq = ~a; ~%", subst([wv^2=wvSq,dv^2=dvSq],expand((2*(-sqrt(vcutSq_i)-wv)/dv)^2))),
        /*fReflfacs : [ "(exp(b)-exp(b*xc))/2/sinh(b)", 
            "((b-1)*exp(b)-(b*xc-1)*exp(b*xc))/2/(b*cosh(b)-sinh(b))", 
            "((2*(b*b+3*(1-b))*exp(b))/3-((b*(3*b*xc*xc-(6*xc+b))+6)*exp(b*xc))/3)/(-4*b*cosh(b) + 4/3*(3 + b*b)*sinh(b))"],*/
        cutlims : [xc,1],
        uhat : fullratsimp(innerProdGen([vx], [cutlims], 1, wv+dv/2*vx, fXYMuQ_expd[j])),
        u : fullratsimp(innerProd([vx], 1, wv+dv/2*vx, fXYMuQ_expd[j])),
        fReflfacs : subst([xc^2=xcSq,wv^2=wvSq,dv^2=dvSq],gcfac(float(fullratsimp(uhat/u)))),
        for k:1 thru length(bVp) do (
          printf(fh, "  fReflXYMuQuad[~a][~a] = ~a*~a; ~%", j-1, k-1, gcfac(float(fXYMuQ_Vp_c[k])), fReflfacs)
        ),
        printf(fh, "  } ~%"),
        fReflXYMuQ_expd[j] : makelist(fReflXYMuQuad[j-1][k-1],k,1,length(bVp)).bVp
      ),
      modToNodMu:fullratsimp(calcModToNodPhaseWithNodesAndBasis(nodesMu, bMu, [vy])),
      fReflXYQ_VpMu_expd : fullratsimp(bMu.fullratsimp(invert(transpose(float(modToNodMu))).fReflXYMuQ_expd)),
      /* project fRefl at this (x,y)_i quad node onto vpar,mu basis (bVpMu) */
      fReflXYQ_VpMu_c : gcfac(fullratsimp(innerProd([vx,vy], 1, bVpMu, fReflXYQ_VpMu_expd))),
      writeCExprsNoExpand1(fReflXYQuad[i-1], fReflXYQ_VpMu_c),
    printf(fh, "  } ~%~%"),
    /* expansion of fRefl at each x,y quad node */
    fReflXYQ_expd[i] : makelist(fReflXYQuad[i-1][j-1],j,1,length(bVpMu)).bVpMu,
    printf(fh, " ~%")
  ),

  modToNodXY:fullratsimp(calcModToNodPhaseWithNodesAndBasis(nodesXY,bXY,[x,y])),
  fRefl_expd : fullratsimp(bXY . fullratsimp(invert(transpose(float(modToNodXY))).fReflXYQ_expd)),
  fRefl_c : fullratsimp(innerProd(varsP, 1, bP, fRefl_expd)),
  writeCExprsWithZerosNoExpand1(fRefl, fRefl_c),
  printf(fh, "}~%")
)
)$

fname : "~/max-out/GkSheathFuncsSer.cpp";
fh : openw(fname);
printf(fh, "#include <cmath> ~%");
printf(fh, "#include <GyrokineticModDecl.h> ~%");
printf(fh, "// approximation for inverse Langevin function ~%");
printf(fh, "double invL(double x) { ~%");
printf(fh, "  // from Kroger ~%");
printf(fh, "  return (3.*x-x*x*x*(6. + x*x - 2.*x*x*x*x)/5.)/(1.-x*x); ~%");
printf(fh, "}~%~%");
calcGkSheathFuncs(fh, 3, 2, "Ser", 1);
close(fh);

