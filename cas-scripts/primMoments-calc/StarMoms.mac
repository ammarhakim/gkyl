/* Compute the star moments (M_0^\star, M_1^\star, M_2^\star)
   needed by SelfPrimMoments to compute the flow velocity and
   thermal speed squared in the piece-wise linear (p=1) case
   while preserving momentum and energy density. */
/* IMPORTANT: code below assumes vMin is negative and vMax positive.
   It also assumes uniform grid (dxvl = dxvr). */

load("modal-basis");
load("out-scripts");
fpprec : 24$

polyOrder : 1$ /* This is only for piecewise linear. */

varsV : [vx, vy, vz]$
vvars : [VX, VY, VZ]$

vidx(cdim,vdim)     := makelist(i,i,cdim+1,cdim+vdim)$
vidx1(cdim,vdim)    := makelist(i,i,cdim,cdim+vdim-1)$
volExpr(cdim, vdim) := prod(dxv[cdim+i-1], i, 1, vdim)$

vTrans  : [vx*dv1/2+wx1, vy*dv2/2+wx2, vz*dv3/2+wx3]$
wTrans  : [wx1, wx2, wx3]$
dvTrans : [vx*dv1/2, vy*dv2/2, vz*dv3/2]$

let(wx1^2, wx1_sq)$
let(wx2^2, wx2_sq)$
let(wx3^2, wx3_sq)$
let(dv1^2, dv1_sq)$
let(dv2^2, dv2_sq)$
let(dv3^2, dv3_sq)$

let(wx1^3, wx1_cu)$
let(wx2^3, wx2_cu)$
let(wx3^3, wx3_cu)$
let(dv1^3, dv1_cu)$
let(dv2^3, dv2_cu)$
let(dv3^3, dv3_cu)$

writeCIncrExprsCollect1r(lhs, rhs, clst, cdim, vdim) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      param : cons(expr[i], clst),
      e : apply(collectterms, param),
      /* Replace exponentials. */
      ep : string(e),
      for vd : 1 thru vdim do (
        ep : ssubst(sconcat("wvSq[",vd-1,"]"),sconcat("w[",cdim+vd-1,"]^2"),ep)
      ),
      printf(fh, "  ~a += ~a; ~%", lhs[i-1], ep)
    )
  )
)$

writeCIncrExprsNoExpand1r(lhs, rhs, cdim, vdim) := block([expr],
  expr : float(rhs),
  for i : 1 thru length(expr) do (
    if (expr[i] # 0.0) then (
      /* Replace exponentials. */
      ep : string(expr[i]),
      for vd : 1 thru vdim do (
        ep : ssubst(sconcat("wvSq[",vd-1,"]"),sconcat("w[",cdim+vd-1,"]^2"),ep)
      ),
      printf(fh, "  ~a += ~a; ~%", lhs[i-1], ep)
    )
  )
)$

calcStarM0Dir(dir, fh, funcNm, cdim, vdim, basisFun) := block([],

  kill(varsC, varsP, basisC, basisP),

  /*... Compute  1D recovery polynomial coefficients into hsol ...*/
  /* Load 1D basis. */
  load(sconcat("basis-precalc/basis", basisFun, 1, "x")),
  bC1 : basisC[polyOrder],
  N1  : length(bC1),

  eta(xc,dx,b) := subst(x=(w-xc)/(dx/2), b),

  /* Construct the 1D recovery polynomial */
  hOrder : 2*polyOrder+1,
  /* Left and right (of the boundary) basis sets */
  pL : eta(-1/2,1,bC1),
  pR : eta(1/2,1,bC1),
  /* Recovery polynomial expanded in z */
  h1 : doExpand1(hn,makelist(w^i,i,0,hOrder)),

  /* LHS of system of equations arising from weak equivalence relations */
  eqL : makelist(integrate(h1*pL[i],w,-1,0), i,1,polyOrder+1),
  eqR : makelist(integrate(h1*pR[i],w,0,1), i,1,polyOrder+1),
  LHS : append(eqL,eqR),
  A   : coefmatrix(LHS, makelist(hn[i],i,0,hOrder)),

  /* RHS is similar to the mass matrix */
  RHS : transpose(append(makelist(fl[i]/2,i,1,N1), makelist(fr[i]/2,i,1,N1))),

  /* solve system of equations for coefficients of h */
  S     : fullratsimp(invert(A) . RHS),
  hsol1 : makelist(S[i][1],i,1,hOrder+1),

  /*... Recovery polynomial coefficients of requested dimensionality ...*/
  kill(varsC, basisC),
  /* Load basis of dimensionality requested. */
  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),

  /* Variables. */
  vid      : vidx(cdim,vdim),
  vid1     : vidx1(cdim,vdim),
  vv       : varsV[dir],
  surfVars : delete(vv,varsP),
  dv       : makelist(dxvl[cdim+i], i, 0, vdim-1),

  /* Polynomial basis and its derivatives. */
  bP  : basisP[polyOrder],
  bC  : basisC[polyOrder],
  NP  : length(bP),
  NC  : length(bC),
  bPp : diff(bP,vv),

  fg : doExpand(f, bP),       /* Function expanded in basis. */

  /* Obtain the left and right function coefficients
     by projecting the function onto the direction of interest. */
  hcoeff : calcInnerProdList([vv], 1, subst(x=vv,bC1), fg),
  fls : subst(makelist(f[i]=fl[i],i,NP), hcoeff),
  frs : subst(makelist(f[i]=fr[i],i,NP), hcoeff),

  /* Substitute these "left" and "right" function coefficients,
     which contain variation along other dimensions, into the
     1D recovery polynomial coefficients computed above. */
  hsol : psubst(append(makelist(fl[i]=fls[i], i, 1, N1), makelist(fr[i]=frs[i], i, 1, N1)), hsol1),

  /* Write out the full recovery polynomial and its derivative. */
  h : sum(hsol[i]*vv^(i-1), i, 1, 2*N1),
  /* Evaluate the recovery polynomial at the discontinuity. */
  hsol0 : subst(vv=0,h),

  /* Because f's in hsol are index-1, we need to switch to
     0-indexed for C++. */
  subList : append(makelist(fr[i]=fr[i-1],i,1,NP),makelist(fl[i]=fl[i-1],i,1,NP)),
  hsol0   : psubst(subList,hsol0),

  /*............. RECOVERY DONE ..............................*/

  if (sequal(substring(funcNm,1,3),"Vm")) then (
    printf(fh, "void ~a_~a(const double *wl, const double *wr, const double *dxvl, const double *dxvr, const double *fl, const double *fr, double *out) ~%{ ~%", funcNm, vvars[dir])
  ) else (
    printf(fh, "void ~a_~a(const double intFac, const double *wl, const double *wr, const double *dxvl, const double *dxvr, const double *fl, const double *fr, double *out) ~%{ ~%", funcNm, vvars[dir])
  ),
  printf(fh, "  // intFac:  =2pi/m for gyrokinetics (not used in Vlasov). ~%"),
  printf(fh, "  // w[NDIM]: Cell-center coordinates. ~%"),
  printf(fh, "  // dxv[~a]:  cell length in each direciton. ~%", cdim+vdim),
  printf(fh, "  // fl/fr:   Distribution function in left/right cells ~%"),
  printf(fh, "  // out:     Increment to M_0^\star from this cell surface. ~%"),
  printf(fh, " ~%"),

  dvSurf   : delete(dxvl[cdim+dir-1],dv),
  surfExpr : float(prod(dvSurf[i],i,1,vdim-1)),

  /* Surface integral above was done in [-1,1] computational space. Surface
     factor needs to be multiplied to obtain result from physical grid. */
  if (sequal(substring(funcNm,1,3),"Vm")) then (
    printf(fh, "  const double dS = ~a*(wr[~a]-wl[~a]); ~%", float(1/(2^(vdim-1)))*surfExpr, vid1[dir], vid1[dir])
  ) else (
    printf(fh, "  const double dS = ~a*intFac*(wr[~a]-wl[~a]); ~%", float(1/(2^(vdim-1)))*surfExpr, vid1[dir], vid1[dir])
  ),
  printf(fh, " ~%"),

  iM0star : calcInnerProdList(surfVars, 1, bC, hsol0),
  writeCIncrExprsCollect1(out, dS*iM0star,[dS]),
  
  printf(fh, " ~%"),
  printf(fh, "} ~%"),

  printf(fh, " ~%")
)$

/* Calculate Vlasov M1i* and M2*. */
calcVmStarM1iM2(fh, funcNm, cdim, vdim, basisFun) := block([],

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),

  bP : basisP[polyOrder],
  bC : basisC[polyOrder],
  NC : length(bC),

  printf(fh, "void ~a(const double *w, const double *dxv, const double *f, double *outM1i, double *outM2) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:    Cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:  Cell length in each direciton. ~%", cdim+vdim),
  printf(fh, "  // intFac:  for gyrokinetics (not used in Vm). ~%"),
  printf(fh, "  // m_:      mass (not used in Vm). ~%"),
  printf(fh, "  // Bmag[~a]: Magnetic field magnitude (not used in Vm). ~%", NC),
  printf(fh, "  // f:       Distribution function. ~%"),
  printf(fh, "  // outM1i:  Contribution to M_1^\star from this cell. ~%"),
  printf(fh, "  // outM2:   Contribution to M_2^\star from this cell. ~%"),
  printf(fh, " ~%"),

  printf(fh, "  const double volFact = ~a; ~%", float(volExpr(cdim, vdim)/(2^vdim))),
  printf(fh, "  double wvSq[~a]; ~%", vdim),
  for i : 1 thru vdim do (
    printf(fh, "  wvSq[~a]  = w[~a]*w[~a]; ~%", i-1, cdim+i-1, cdim+i-1)
  ),
  printf(fh, "  double dvSq[~a]; ~%", vdim),
  for i : 1 thru vdim do (
    printf(fh, "  dvSq[~a] = dxv[~a]*dxv[~a]; ~%", i-1, cdim+i-1, cdim+i-1)
  ),
  printf(fh, "  double tempM0[~a]; ~%", NC),
  printf(fh, "~%"),

  f_e : doExpand1(f, bP),

  /* Place integral of f over velocity space in a temporary array. */
  M0 : calcInnerProdList(varsP, 1, bC, f_e),
  writeCExprs1(tempM0, volFact*M0),
  printf(fh, "~%"),

  M0M1i : (M0M1i : [],
       for dir : 1 thru vdim do (
         M0M1i : append(M0M1i, makelist(tempM0[i-1]*w[cdim+dir-1], i, 1, NC))
       ),
  M0M1i),
  writeCIncrExprs1(outM1i, M0M1i),
  printf(fh, "~%"),

  /* Velocity space integral (projected on conf space) of vx*(dv/2)*f. */
  M1i : (M1i : [],
       for dir : 1 thru vdim do (
         M1i : append(M1i, calcInnerProdList(varsP, varsV[dir]*dxv[cdim+dir-1]/2, bC, f_e))
       ),
  M1i),
  /* Add to the integral of f. */
  tempM1i : M0M1i+volFact*M1i,

  /* Multiply (vector) components by corresponding w and add them. */
  M0M2 : makelist(0,i,1,NC),
  for vd : 1 thru vdim do (
     M0M2 : M0M2+makelist(tempM1i[(vd-1)*NC+i],i,1,NC)*w[cdim+vd-1]
  ),
  clst : append([volFact], makelist(tempM0[i-1], i, 1, NC)),
  writeCIncrExprsCollect1r(outM2, M0M2, clst, cdim, vdim),

  printf(fh, " ~%"),
  printf(fh, "} ~%")
)$

/* Calculate gyrokinetic M1i* and M2*. */
calcGkStarM1iM2(fh, funcNm, cdim, vdim, basisFun) := block([],

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),

  bP : basisP[polyOrder],
  bC : basisC[polyOrder],

  printf(fh, "void ~a(const double *w, const double *dxv, const double intFac, const double m_, const double *Bmag, const double *f, double *outM1i, double *outM2) ~%{ ~%", funcNm),
  printf(fh, "  // w[~a]:    Cell-center coordinates. ~%", cdim+vdim),
  printf(fh, "  // dxv[~a]:  Cell length in each direciton. ~%", cdim+vdim),
  printf(fh, "  // intFac:  =2pi/m for gyrokinetics. ~%"),
  printf(fh, "  // m_:      mass. ~%"),
  printf(fh, "  // Bmag[~a]: Magnetic field magnitude. ~%", NC),
  printf(fh, "  // f:       Distribution function. ~%"),
  printf(fh, "  // outM1i:  Contribution to M_1^\star from this cell. ~%"),
  printf(fh, "  // outM2:   Contribution to M_2^\star from this cell. ~%"),
  printf(fh, " ~%"),

  if (vdim = 1) then (
    printf(fh, "  const double volFact = ~a; ~%", float((1/(2^vdim))*volExpr(cdim, vdim)))
  ) else (
    printf(fh, "  const double volFact = intFac*~a; ~%", float((1/(2^vdim))*volExpr(cdim, vdim)))
  ),
  printf(fh, "  double wvSq[~a]; ~%", vdim),
  for i : 1 thru vdim do (
    printf(fh, "  wvSq[~a]  = w[~a]*w[~a]; ~%", i-1, cdim+i-1, cdim+i-1)
  ),
  printf(fh, "  double dvSq[~a]; ~%", vdim),
  for i : 1 thru vdim do (
    printf(fh, "  dvSq[~a] = dxv[~a]*dxv[~a]; ~%", i-1, cdim+i-1, cdim+i-1)
  ),
  printf(fh, " ~%"),

  f_e    : doExpand1(f, bP),
  bmag_e : doExpand1(Bmag, bC),

  M1 : calcInnerProdList(varsP, w[cdim], bC, f_e),
  M1 : map(letsimp, M1),

  writeCIncrExprsNoExpand1(outM1i, volFact*M1),
  printf(fh, " ~%"),

  M2par : calcInnerProdList(varsP, w[cdim]*(vx*dxv[cdim]/2+w[cdim]), bC, f_e),
  M2par : map(letsimp, M2par),

  if (vdim=1) then (

    writeCIncrExprsNoExpand1r(outM2, volFact*expand(M2par), cdim, vdim),
    printf(fh, " ~%")

  ) else (

    Mtemp : calcInnerProdList(varsP, vy*dxv[cdim+1]/2+w[cdim+1], bC, f_e),
    Mtemp : map(letsimp, Mtemp),

    printf(fh, "  double tmp[~a]; ~%", length(bC)),
    writeCExprs1(tmp, Mtemp),
    printf(fh, " ~%"),

    tmp_e : doExpand1(tmp, bC),
    M2perp : fullratsimp(innerProd(varsC, bC, bmag_e, tmp_e)),

    writeCIncrExprsNoExpand1r(outM2, volFact*(expand(M2par)+expand(2.0*M2perp)/m_), cdim, vdim),
    printf(fh, " ~%")

  ),

  printf(fh, "} ~%")
)$

calcStarMomContributions(fh, funcNmRoot, cdim, vdim, basisFun) := block([],

  funcNm : sconcat(funcNmRoot,"M0Star", c, "x", v, "v", basisFun),
  if (sequal(funcNmRoot,"Vm")) then (

    for dir : 1 thru vdim do (
      calcStarM0Dir(dir, fh, funcNm, cdim, vdim, basisFun)
    ),

    funcNm : sconcat(funcNmRoot,"M1iM2Star", c, "x", v, "v", basisFun),
    calcVmStarM1iM2(fh, funcNm, cdim, vdim, basisFun)

  ) else (

    calcStarM0Dir(1, fh, funcNm, cdim, vdim, basisFun),

    funcNm : sconcat(funcNmRoot,"M1iM2Star", c, "x", v, "v", basisFun),
    calcGkStarM1iM2(fh, funcNm, cdim, vdim, basisFun)

  )

)$
