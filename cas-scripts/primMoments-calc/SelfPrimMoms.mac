/* Generate kernels for the updater that computes the primitive
   moments u and vt^2 given the moments and the distribution function.
   Weak division, multiplication and dot products are employed. */

/* At the moment we obtain u through weak division of m1 by m0. This
   does not conserve momentum in a finite velocity grid. We include
   the contribution coming from the finite velocity grid in the
   calculation of vtSq. */

/* To avoid the expensive symbolic matrix inversion in
   Maxima we use Eigen to solve the system. */

/* In the comments we refer to the rank 3 tensor E_M. This is
   E_{M,i,j,k} = InnerProd(varsC,bC[i],bC[j],bC[k]). */

load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

VarsC : [X, Y, Z]$
varsV : [vx, vy, vz]$

writeCExprsB(lhs, rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then printf(fh, "  ~a = ~a; ~%", ssubst(")","]",ssubst("(","[",string(lhs[i]))), expr[i])
  )
)$

writeEVExprs(lhs, rhs, vd, nc) := block([expr],
  len   : length(rhs),
  start : len*2+(len-1)+2*len+1,
  for k : 1 thru vd*nc do (
    start : start+slength(string(k-1))
  ),
  for k : 1 thru nc do (
    start : start+slength(string(k-1))
  ),
  printf(fh, "  ~a << ~a; ~%", lhs, sremove("]",sremovefirst("[",string(rhs)),sequal,start))
)$

calcSelfPrimMoms(fh, funcNm, cdim, vdim, basisFun, pMax) := block([],
  kill(varsC, varsP, basisC, basisP),
  if (cdim > vdim) then (
    basisVdim : vdim+1
  ) else (
    basisVdim : vdim
  ),
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", basisVdim, "v"),
  load(modNm),
  for polyOrder : 1 thru pMax do (
    bC : basisC[polyOrder],
    bP : basisP[polyOrder],
    NP  : length(bP),
    NC  : length(bC),
  
    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const int pVdim, const double *m0, const double *m1, const double *m2, const double *cM, const double *cE, double *u, double *vtSq) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // m0,m1,m2: moments of the distribution function. ~%"),
    printf(fh, "  // cM, cE: vtSq*cM and vtSq*cE are corrections to u and vtSq, respectively. ~%"),
    printf(fh, "  // u:        velocity. ~%"),
    printf(fh, "  // vtSq:     squared thermal speed, sqrt(T/m). ~%"),
    printf(fh, " ~%"),

    /* Expand moments in configuration space basis. */
    m0_e : doExpand1(m0, bC),
    m2_e : doExpand1(m2, bC),
    /* Array of expansion coefficients. */
    m0_c : makelist(m0[i],i,0,NC-1),
    m2_c : makelist(m2[i],i,0,NC-1),
    /* Equivalently for  vtSq .*/
    vtSq_e : doExpand1(vtSq,bC),
    vtSq_c : makelist(vtSq[i],i,0,NC-1),
    /* cM and cE are the corrections to u and vtSq
       needed to preserve momentum and energy conservation. */
    cE_e : doExpand1(cE, bC),
    cE_c : makelist(cE[i],i,0,NC-1),

    /* N is the size of the linear problem. LHS Eigen matrix is NxN. */
    N : NC*(vdim+1),

    printf(fh, "  // Declare Eigen matrix and vectors for weak division. ~%"),
    printf(fh, "  Eigen::MatrixXd BigAEM = Eigen::MatrixXd::Zero(~a,~a); ~%", N, N), 
    printf(fh, "  Eigen::VectorXd bEV = Eigen::VectorXd::Zero(~a);  ~%", N),
    printf(fh, "  Eigen::VectorXd xEV = Eigen::VectorXd::Zero(~a);  ~%", N),
    printf(fh, " ~%"),

    /* Make a list of the LHS matrix assignments. */
    /* Note: Eigen defaults to Column-major order. */
    Ef [i,j] := BigAEM[i,j],

    m1RHS_c : [],
    for vd : 1 thru vdim do (
      /* Expand u function and create a list of expansion coefficients. */
      m1_e : doExpand1(m1, bC),
      m1_c : makelist(m1[i],i,0,NC-1),
      u_e  : doExpand1(u,bC),
      u_c  : makelist(u[i],i,0,NC-1),
      cM_e : doExpand1(cM, bC),
      cM_c : makelist(cM[i],i,0,NC-1),
      /* Use the vd component of u, m1 and cM. */
      u_e : subst(makelist(u[i]=u[(vd-1)*NC+i],i,0,NC-1),u_e),
      u_c : subst(makelist(u[i]=u[(vd-1)*NC+i],i,0,NC-1),u_c),
      m1_e : subst(makelist(m1[i]=m1[(vd-1)*NC+i],i,0,NC-1),m1_e),
      m1_c : subst(makelist(m1[i]=m1[(vd-1)*NC+i],i,0,NC-1),m1_c),
      cM_e : subst(makelist(cM[i]=cM[(vd-1)*NC+i],i,0,NC-1),cM_e),
      cM_c : subst(makelist(cM[i]=cM[(vd-1)*NC+i],i,0,NC-1),cM_c),

      /*........... Matrix block from weak multiply of u and M_0 .............*/
      eq : calcInnerProdList(varsC,u_e,bC,m0_e),
      E  : fullratsimp(coefmatrix(eq,u_c)),
      /* Flatten E for WriteCExprsB. */
      Eflat : list_matrix_entries(E),
  
      /* Elhs     : list_matrix_entries(genmatrix(Ef,NC-1,NC-1,0,0)), */
      Elhs     : list_matrix_entries(genmatrix(Ef,vd*NC-1,vd*NC-1,(vd-1)*NC,(vd-1)*NC)),
  
      printf(fh, "  // ....... Block from weak multiply of u~a and m0  .......... // ~%", VarsC[vd]),
      writeCExprsB(Elhs,Eflat),
      printf(fh, " ~%"),
  
      /*........... Matrix block from correction to u .............*/
      eq : -calcInnerProdList(varsC,vtSq_e,bC,cM_e),
      E  : fullratsimp(coefmatrix(eq,vtSq_c)),
      /* Flatten E for WriteCExprsB. */
      Eflat : list_matrix_entries(E),
  
      Elhs     : list_matrix_entries(genmatrix(Ef,vd*NC-1,N-1,(vd-1)*NC,(vdim-1)*NC+NC)),
  
      printf(fh, "  // ....... Block from correction to u~a .......... // ~%", VarsC[vd]),
      writeCExprsB(Elhs,Eflat),
      printf(fh, " ~%"),
  
      /*........... Matrix block from weak multiply of u and m1 .............*/
      eq : calcInnerProdList(varsC,u_e,bC,m1_e),
      E  : fullratsimp(coefmatrix(eq,u_c)),
      /* Flatten E for WriteCExprsB. */
      Eflat : list_matrix_entries(E),
  
      Elhs     : list_matrix_entries(genmatrix(Ef,N-1,vd*NC-1,vdim*NC,(vd-1)*NC)),
  
      printf(fh, "  // ....... Block from weak multiply of u~a and m1~a  .......... // ~%", VarsC[vd], VarsC[vd]),
      writeCExprsB(Elhs,Eflat),
      printf(fh, " ~%"),

      /* Vector of all m1 coefficients. */
      m1RHS_c : append(m1RHS_c,m1_c)
    ),
  
    /*........... Matrix block from correction to vtSq .............*/
    eq : calcInnerProdList(varsC,vtSq_e,bC,pVdim*m0_e-cE_e),
    E  : fullratsimp(coefmatrix(eq,vtSq_c)),
    /* Flatten E for WriteCExprsB. */
    Eflat : list_matrix_entries(E),
  
    Elhs     : list_matrix_entries(genmatrix(Ef,N-1,N-1,vdim*NC,vdim*NC)),
  
    printf(fh, "  // ....... Block from correction to vtSq .......... // ~%"),
    writeCExprsB(Elhs,Eflat),
    printf(fh, " ~%"),

    if vdim=2 then (
      printf(fh, "  // Set other entries to 0. // ~%"),
      printf(fh, "  BigAEM.block<~a,~a>(~a,~a).setZero(); ~%",NC,NC,0,NC),
      printf(fh, "  BigAEM.block<~a,~a>(~a,~a).setZero(); ~%",NC,NC,NC,0),
      printf(fh, " ~%")
    ) elseif vdim=3 then (
      printf(fh, "  // Set other entries to 0. // ~%"),
      printf(fh, "  BigAEM.block<~a,~a>(~a,~a).setZero(); ~%",NC,2*NC,0,NC),
      printf(fh, "  BigAEM.block<~a,~a>(~a,~a).setZero(); ~%",2*NC,NC,NC,0),
      printf(fh, "  BigAEM.block<~a,~a>(~a,~a).setZero(); ~%",NC,NC,NC,2*NC),
      printf(fh, "  BigAEM.block<~a,~a>(~a,~a).setZero(); ~%",NC,NC,2*NC,NC),
      printf(fh, " ~%")
    ),

    printf(fh, "  // ....... RHS vector is composed of m1 and m2 .......... // ~%"),
    writeEVExprs(bEV,append(m1RHS_c,m2_c), vdim, NC),
    printf(fh, " ~%"),

    printf(fh, "  xEV = BigAEM.colPivHouseholderQr().solve(bEV); ~%"),
    printf(fh, " ~%"),

    printf(fh, "  Eigen::Map<VectorXd>(u,~a,1) = xEV.segment<~a>(0); ~%", NC*vdim,NC*vdim),
    printf(fh, " ~%"),

    printf(fh, "  Eigen::Map<VectorXd>(vtSq,~a,1) = xEV.segment<~a>(~a); ~%", NC, NC, NC*vdim),
    printf(fh, " ~%"),


    printf(fh, "} ~%"),
    printf(fh, " ~%")
  )
)$

