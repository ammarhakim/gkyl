load("modal-basis")$
load("fem-calc/femMatrices")$
load("scifac")$

/* returns anti-limited expansion of f evaluated at surfVar=surfVal */
fhatAL(f,surfVar,surfVal,cfl,cdim,vdim,p):=block([limTheta,modNm,basis,vars,varsP,nodes,modToNod,avgAndSlope,nodesub,r,fq,fhatAL_k,fhatAL_expd, surfIntVars],
  if vdim=0 then modNm : sconcat("basis-precalc/basisSer", cdim, "x")
  else modNm : sconcat("basis-precalc/basisSer", cdim, "x", vdim, "v"),
  load(modNm),
  if vdim=0 then basis : basisC[p]
  else basis : basisP[p],
  if vdim=0 then vars : varsC else vars : varsP,
  surfIntVars : delete(surfVar, vars),
  nodes : eval_string(sconcat("nodes", cdim+vdim-1, "xp", p))/3,
  avgAndSlope:fullratsimp(innerProd([surfVar],1,[1/2,3/2*surfVar],doExpand1(f,basis))),
  /* function to evaluate f at control nodes in all dimensions other than surfVar */
  nodesub(f):=makelist(subst(makelist(surfIntVars[j]=nodes[i][j],j,1,length(surfIntVars)),f),i,1,length(nodes)),
  /* evaluate r=f1/f0 at control nodes */
  r:fullratsimp(nodesub(fullratsimp(avgAndSlope[2]/(EPSILON + avgAndSlope[1])))),
  /* print r */
  printf(fh,"  double rVal[~a];  // rVal=f1/f0 at each control node in dimensions other than ~a ~%",length(r),surfVar),
  writeCExprsNoExpand1(rVal,gcfac(r)),
  flush_output(fh),
  fq:fullratsimp(nodesub(avgAndSlope[1])*makelist(limTheta(rVal[i-1],surfVal,cfl),i,1,length(r))),
  /* print fq */
  printf(fh,"  double fqVal[~a];  // fqVal = anti-limited f evaluated at each control node on ~a surface ~%",length(fq),surfVar),
  writeCExprsNoExpand1(fqVal,gcfac(fq)),
  flush_output(fh),
  if cdim+vdim-1<=3 then modToNod:calcModToNodPhase(cdim+vdim-1,0,p)
  else modToNod:calcModToNodPhase(cdim-1,vdim,p),
  fhatAL_k:fullratsimp(invert(transpose(modToNod)).makelist(fqVal[i-1],i,1,length(fq))),
  fhatAL_k:gcfac(makelist(fhatAL_k[i][1],i,1,length(fhatAL_k))),
  printf(fh,"  double fhatALVal[~a];  // fhatALVal = mode coefficients of anti-limited f ~%",length(fq)),
  writeCExprsNoExpand1(fhatALVal, fhatAL_k),
  flush_output(fh),
  surfBasis:sqrt(2)*delete(0,fullratsimp(innerProd(vars,1,basis,subst(surfVar=0,basis)))*basis),
  fhatAL_expd:subst(surfVar=surfVal,fullratsimp(surfBasis.makelist(fhatALVal[i-1],i,1,length(fhatAL_k)))),
  flush_output(fh),
  return(fhatAL_expd)
)$

fhatALgenUpwind(fL_expd, fR_expd, alphaSurf_expd,surfVar,cflL,cflR,cdim,vdim,p):=block([limTheta,modNm,basis,vars,varsP,nodes,modToNod,avgAndSlope,nodesub,r,fq,fhatAL_k,fhatAL_expd, surfIntVars],
  if vdim=0 then modNm : sconcat("basis-precalc/basisSer", cdim, "x")
  else modNm : sconcat("basis-precalc/basisSer", cdim, "x", vdim, "v"),
  load(modNm),
  if vdim=0 then basis : basisC[p]
  else basis : basisP[p],
  if vdim=0 then vars : varsC else vars : varsP,
  surfIntVars : delete(surfVar, vars),
  /* surface control nodes */
  nodes : eval_string(sconcat("nodes", cdim+vdim-1, "xp", p))/3,
  nodesub(f):=makelist(subst(makelist(surfIntVars[j]=nodes[i][j],j,1,length(surfIntVars)),f),i,1,length(nodes)),
  /* evaluate fl, fr, and alpha at surface control nodes */
  /* note flQ and frQ will still have surfVar dependence, so that we can evaluate integrals in that direction below */
  alphaq:nodesub(alphaSurf_expd),
  frQ:nodesub(fR_expd),
  flQ:nodesub(fL_expd), 
  
  printf(fh, "  double rVal;  // rVal=f1/f0 at each control node in dimensions other than ~a ~%",surfVar),
  printf(fh, "  double fqVal[~a];  // fqVal = anti-limited f evaluated at each control node on ~a surface ~%",length(nodes),surfVar),

  printf(fh, "  // determine upwinding at each surface control node ~%"),
  for i:1 thru length(alphaq) do (
  printf(fh, "  if(~a > 0) {~%", gcfac(float(alphaq[i]))),
  /* integrate in surfVar to find avg and slope */
  avgAndSlope:fullratsimp(innerProd([surfVar],1,[1/2,3/2*surfVar],flQ[i])),
  r:fullratsimp(avgAndSlope[2]/(EPSILON + avgAndSlope[1])),
  printf(fh, "  rVal = ~a; ~%", gcfac(float(r))),
  fq:fullratsimp(avgAndSlope[1]*limTheta(rVal,1,cflL)),
  printf(fh, "  fqVal[~a] = ~a; ~%", i-1, gcfac(float(fq))),
  printf(fh, "  } else {~%"),
  /* integrate in surfVar to find avg and slope */
  avgAndSlope:fullratsimp(innerProd([surfVar],1,[1/2,3/2*surfVar],frQ[i])),
  r:fullratsimp(avgAndSlope[2]/(EPSILON + avgAndSlope[1])),
  printf(fh, "  rVal = ~a; ~%", gcfac(float(r))),
  fq:fullratsimp(avgAndSlope[1]*limTheta(rVal,-1,cflR)),
  printf(fh, "  fqVal[~a] = ~a; ~%", i-1, gcfac(float(fq))),
  printf(fh, "  }~%")
  ),
  if cdim+vdim-1<=3 then modToNod:calcModToNodPhaseWithNodes(cdim+vdim-1,0,p,nodes)
  else modToNod:calcModToNodPhaseWithNodes(cdim-1,vdim,p,nodes),
  fhatAL_k:fullratsimp(invert(transpose(modToNod)).makelist(fqVal[i-1],i,1,length(nodes))),
  fhatAL_k:gcfac(makelist(fhatAL_k[i][1],i,1,length(fhatAL_k))),
  printf(fh,"  double fhatALVal[~a];  // fhatALVal = mode coefficients of anti-limited f ~%",length(nodes)),
  writeCExprsNoExpand1(fhatALVal, fhatAL_k),
  flush_output(fh),
  surfBasis:sqrt(2)*delete(0,fullratsimp(innerProd(vars,1,basis,subst(surfVar=0,basis)))*basis),
  fhatAL_expd:subst(surfVar=surfVal,fullratsimp(surfBasis.makelist(fhatALVal[i-1],i,1,length(fhatAL_k)))),
  flush_output(fh),
  return(fhatAL_expd)
)$
