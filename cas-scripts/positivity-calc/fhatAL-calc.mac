load("modal-basis")$
load("fem-calc/femMatrices")$

/* returns anti-limited expansion of f evaluated at surfVar=surfVal */
fhatAL(f,surfVar,surfVal,cdim,vdim,p):=block([limTheta,modNm,basis,vars,nodes,modToNod,avgAndSlope,nodesub,r,fq,fhatAL_k,fhatAL_expd],
  if vdim=0 then modNm : sconcat("basis-precalc/basisSer", cdim, "x")
  else modNm : sconcat("basis-precalc/basisSer", cdim, "x", vdim, "v"),
  load(modNm),
  if vdim=0 then basis : basisC[p]
  else basis : basisP[p],
  if vdim=0 then vars : varsC else vars : varsP,
  nodes : eval_string(sconcat("nodes", cdim+vdim, "xp", p)),
  avgAndSlope:fullratsimp(innerProd([surfVar],1,[1/2,3/2*surfVar],doExpand1(f,basis))),
  nodesub(f):=makelist(subst(makelist(vars[j]=nodes[i][j]/3,j,1,length(vars)),f),i,1,length(nodes)),
  r:fullratsimp(nodesub(fullratsimp(avgAndSlope[2]/avgAndSlope[1]))),
  /* print r */
  printf(fh,"  double rVal[~a]; ~%",length(r)),
  writeCExprsNoExpand1(rVal,r),
  fq:fullratsimp(nodesub(avgAndSlope[1])*makelist(limTheta(rVal[i-1],surfVal,cfl),i,1,length(r))),
  /* print fq */
  printf(fh,"  double fqVal[~a]; ~%",length(fq)),
  writeCExprsNoExpand1(fqVal,fq),
  modToNod:calcModToNodPhase(cdim,vdim,p),
  fhatAL_k:fullratsimp(modToNod.makelist(fqVal[i-1],i,1,length(fq))),
  fhatAL_expd:fullratsimp(basis.fhatAL_k),
  return(fhatAL_expd)
)$
