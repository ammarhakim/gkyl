/* Generate kernels that perform weak division of two
   fields, say if Au .= B, (where .= means weak equality)
   then this kernel computes u .= A\B. */

/* To avoid the expensive algebraic matrix inversion in
   Maxima we use Eigen to solve the system. */

load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

writeCExprsB(lhs, rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then printf(fh, "  ~a = ~a; ~%", ssubst(")","]",ssubst("(","[",string(lhs[i]))), expr[i])
  )
)$

writeEVExprs(lhs, rhs) := block([expr],
  len   : length(rhs),
  digs  : slength(string(len)),
/*  start : len+(len-1)+5+len*digs+6*(len-1)+digs*(len-1)+1, */
  start : len+(len-1)+4+5*(len-1)+1,
  for k : 1 thru (len-1) do (
    start : start+slength(string(k))
  ),
  printf(fh, "    ~a << ~a; ~%", lhs, sremove("]",sremovefirst("[",string(rhs)),sequal,start))
)$

writeEVExprsS(lhs, rhs) := block([expr],
  len   : length(rhs),
  digs  : slength(string(len)),
/*  start : len+(len-1)+5+len*digs+6*(len-1)+digs*(len-1)+1, */
  start : len+(len-1)+2*len+1,
  for k : 1 thru len do (
    start : start+slength(string(k-1))
  ),
  printf(fh, "  ~a << ~a; ~%", lhs, sremove("]",sremovefirst("[",string(rhs)),sequal,start))
)$

writeCExprs1s(lhs, rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
    printf(fh, "    ~a = ~a; ~%", lhs[i-1], expr[i])
  )
)$

calcBinOpDivideS(fh, funcNm, cdim, basisFun, pMax) := block([],
  kill(varsC, varsP, basisC, basisP),
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
  load(modNm),
  for polyOrder : 1 thru pMax do (
    bC : basisC[polyOrder],
    N  : length(bC),
  
    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const double *A, const double *B, const short int Ncomp, const short int eqNcomp, double *out) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // A:       denominator field (must be a scalar field). ~%"),
    printf(fh, "  // B:       numerator field (can be scalar or vector). ~%"),
    printf(fh, "  // Ncomp:   number of components of B (could be 1D, 2D, 3D, vector). ~%"),
    printf(fh, "  // eqNcomp: =1 if A:numComponents=B:numComponents, =0 else. ~%"),
    printf(fh, "  // out:     output field (same number of components as B). ~%"),
    printf(fh, " ~%"),

    /* In order to avoid dividing by very small, negative or zero numbers
       use the cell average of A when A<0 at one of the corners. */
    printf(fh, "  // If a corner value is below zero, use cell average A.~%"),
    printf(fh, "  bool avgA = false;~%"),
    for v1 : -1 step 2 thru 1 do (
      cornerA : subst(varsC[1]=v1,doExpand1(A,bC)),
      if cdim > 1 then (
        for v2 : -1 step 2 thru 1 do (
          cornerA : subst(varsC[2]=v2,cornerA),
          if cdim > 2 then (
            for v3 : -1 step 2 thru 1 do (
              cornerA : subst(varsC[3]=v3,cornerA),
              printf(fh, "  if (~a < 0) { ~%",float(expand(cornerA))),
              printf(fh, "    avgA = true;~%"),
              printf(fh, "  }~%")
            )
          ) else (
            printf(fh, "  if (~a < 0) { ~%",float(expand(cornerA))),
            printf(fh, "    avgA = true;~%"),
            printf(fh, "  }~%")
          )
        )
      ) else (
        printf(fh, "  if (~a < 0) { ~%",float(expand(cornerA))),
        printf(fh, "    avgA = true;~%"),
        printf(fh, "  }~%")
      )
    ),
    printf(fh, " ~%"),

    printf(fh, "  double As[~a]; ~%", N),
    printf(fh, "  if (avgA) { ~%"),
    writeCExprs1s(As,append([A[0]],makelist(0.0,i,1,N-1))),
    printf(fh, "  } else { ~%"),
    writeCExprs1s(As,makelist(A[i],i,0,N-1)),
    printf(fh, "  } ~%"),
    printf(fh, " ~%"),

    /* Expand fields A and B in configuration space basis. */
    Ae : doExpand1(As, bC),
    Be : doExpand1(B, bC),
    /* Expand u function and create a list of expansion coefficients. */ 
    ue : doExpand1(u,bC),
    un : makelist(u[i],i,0,N-1),

    eq : calcInnerProdList(varsC,ue,bC,Ae),
  
    E : fullratsimp(coefmatrix(eq,un)),
    /* Flatten E for WriteCExprsB. */
    Eflat : list_matrix_entries(E),

    /* Make a list of the LHS matrix assignments. */
    /* Note: Eigen defaults to Column-major order. */
    Ef [i,j] := AEM[i,j],
    Elhs : list_matrix_entries(genmatrix(Ef,N-1,N-1,0,0)),

    printf(fh, "  // Declare Eigen Matrix with triple basis tensor dotted with B vector. ~%"),
    printf(fh, "  Eigen::MatrixXd AEM = Eigen::MatrixXd::Zero(~a,~a); ~%", N, N),
    printf(fh, "  // Declare Eigen Vector with coefficients of B. ~%"),
    printf(fh, "  Eigen::VectorXd BEV = Eigen::VectorXd::Zero(~a);  ~%", N),
    printf(fh, "  // Declare vector with solution to system of equations. ~%"),
    printf(fh, "  Eigen::VectorXd u = Eigen::VectorXd::Zero(~a);  ~%", N),
    printf(fh, " ~%"),

    printf(fh, "  // Fill AEM matrix. ~%"),
    writeCExprsB(Elhs,Eflat),
    printf(fh, " ~%"),

    printf(fh, "  for(unsigned short int vd=0; vd<Ncomp; vd++) ~%"),
    printf(fh, "  { ~%"),

    printf(fh, "    unsigned short int b0 = ~a*vd; ~%", N),
    printf(fh, "    // Fill BEV. ~%"),
/*    printf(fh, "    Eigen::Map<const VectorXd> BEV(B+0,~a); ~%", N), */
/*  Something like this is only needed if the BEV vector is pre-initialized during init. */
/*    printf(fh, "    ::new (&BEV) Eigen::Map<const VectorXd>(B,~a); ~%", N), */
    writeEVExprs(BEV,makelist(B[i],i,b0+0,b0+N-1)),
    printf(fh, " ~%"),

    printf(fh, "    // Solve the system of equations. ~%"),
    printf(fh, "    u = AEM.colPivHouseholderQr().solve(BEV); ~%"),
    printf(fh, " ~%"),

    printf(fh, "    // Copy data from Eigen vector. ~%"),
    printf(fh, "    Eigen::Map<VectorXd>(out+vd*~a,~a,1) = u; ~%", N, N),
    printf(fh, "  } ~%"),
    printf(fh, "} ~%"),
    printf(fh, " ~%")
  )
)$

calcBinOpDivideD(fh, funcNm, cdim, vdim, basisFun, pMax) := block([],
  kill(varsC, varsP, basisC, basisP),
  modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
  load(modNm),
  for polyOrder : 1 thru pMax do (
    bC : basisC[polyOrder],
    bP : basisP[polyOrder],
    NC : length(bC),
    NP : length(bP),
  
    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const double *A, const double *B, const short int Ncomp, const short int eqNcomp, double *out) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // A:       configuration space denominator field (must be a scalar field). ~%"),
    printf(fh, "  // B:       phase space numerator field (must be a scalar field). ~%"),
    printf(fh, "  // Ncomp:   number of components of B (=1 here). ~%"),
    printf(fh, "  // eqNcomp: =1 if A:numComponents=B:numComponents, =0 else (=1 here). ~%"),
    printf(fh, "  // out:     output field (same number of components as B). ~%"),
    printf(fh, " ~%"),

    /* In order to avoid dividing by very small, negative or zero numbers
       use the cell average of A when A<0 at one of the corners. */
    printf(fh, "  // If a corner value is below zero, use cell average A.~%"),
    printf(fh, "  bool avgA = false;~%"),
    for v1 : -1 step 2 thru 1 do (
      cornerA : subst(varsC[1]=v1,doExpand1(A,bC)),
      if cdim > 1 then (
        for v2 : -1 step 2 thru 1 do (
          cornerA : subst(varsC[2]=v2,cornerA),
          if cdim > 2 then (
            for v3 : -1 step 2 thru 1 do (
              cornerA : subst(varsC[3]=v3,cornerA),
              printf(fh, "  if (~a < 0) { ~%",float(expand(cornerA))),
              printf(fh, "    avgA = true;~%"),
              printf(fh, "  }~%")
            )
          ) else (
            printf(fh, "  if (~a < 0) { ~%",float(expand(cornerA))),
            printf(fh, "    avgA = true;~%"),
            printf(fh, "  }~%")
          )
        )
      ) else (
        printf(fh, "  if (~a < 0) { ~%",float(expand(cornerA))),
        printf(fh, "    avgA = true;~%"),
        printf(fh, "  }~%")
      )
    ),
    printf(fh, " ~%"),

    printf(fh, "  double As[~a]; ~%", NC),
    printf(fh, "  if (avgA) { ~%"),
    writeCExprs1s(As,append([A[0]],makelist(0.0,i,1,NC-1))),
    printf(fh, "  } else { ~%"),
    writeCExprs1s(As,makelist(A[i],i,0,NC-1)),
    printf(fh, "  } ~%"),
    printf(fh, " ~%"),

    /* Expand fields A and B in configuration space basis. */
    Ae : doExpand1(As, bC),
    Be : doExpand1(B, bP),
    /* Expand u function and create a list of expansion coefficients. */ 
    ue : doExpand1(u,bP),
    un : makelist(u[i],i,0,NC-1),

    eq : calcInnerProdList(varsP,ue,bP,Ae),
  
    E : fullratsimp(coefmatrix(eq,un)),
    /* Flatten E for WriteCExprsB. */
    Eflat : list_matrix_entries(E),

    /* Make a list of the LHS matrix assignments. */
    /* Note: Eigen defaults to Column-major order. */
    Ef [i,j] := AEM[i,j],
    Elhs : list_matrix_entries(genmatrix(Ef,NP-1,NP-1,0,0)),

    printf(fh, "  // Declare Eigen Matrix with triple basis tensor dotted with B vector. ~%"),
    printf(fh, "  Eigen::MatrixXd AEM = Eigen::MatrixXd::Zero(~a,~a); ~%", NP, NP),
    printf(fh, "  // Declare Eigen Vector with coefficients of B. ~%"),
    printf(fh, "  Eigen::VectorXd BEV = Eigen::VectorXd::Zero(~a);  ~%", NP),
    printf(fh, "  // Declare vector with solution to system of equations. ~%"),
    printf(fh, "  Eigen::VectorXd u = Eigen::VectorXd::Zero(~a);  ~%", NP),
    printf(fh, " ~%"),

    printf(fh, "  // Fill AEM matrix. ~%"),
    writeCExprsB(Elhs,Eflat),
    printf(fh, " ~%"),

    printf(fh, "  // Fill BEV. ~%"),
/*    printf(fh, "  Eigen::Map<const VectorXd> BEV(B+0,~a); ~%", NP), */
/*  Something like this is only needed if the BEV vector is pre-initialized during init. */
/*    printf(fh, "  ::new (&BEV) Eigen::Map<const VectorXd>(B,~a); ~%", NP), */
    writeEVExprsS(BEV,makelist(B[i],i,0,NP-1)),
    printf(fh, " ~%"),

    printf(fh, "  // Solve the system of equations. ~%"),
    printf(fh, "  u = AEM.colPivHouseholderQr().solve(BEV); ~%"),
    printf(fh, " ~%"),

    printf(fh, "  // Copy data from Eigen vector. ~%"),
    printf(fh, "  Eigen::Map<VectorXd>(out,~a,1) = u; ~%", NP),
    printf(fh, " ~%"),
    printf(fh, "} ~%"),
    printf(fh, " ~%")
  )
)$

