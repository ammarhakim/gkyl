load("modal-basis")$
load("out-scripts");
load(stringproc)$
fpprec : 24$

/* This script generates the kernels needed for adding the
   contributions from second order diffusion in all directions
   using two integrations by parts. */

cvars : [X, Y, Z]$

cidx(cdim) := makelist(i,i,0,cdim-1)$

calcUpdateInDir(dir, fh, funcNm, cdim, basisFun, pMax) := block([],
  for polyOrder : 1 thru pMax do (

    kill(varsC, varsP, basisC, basisP),

    /*... Compute  1D recovery polynomial coefficients into hsol ...*/
    /* Load 1D basis. */
    load(sconcat("basis-precalc/basis", basisFun, 1, "x")),
    bC1 : basisC[polyOrder],
    N1 : length(bC1),

    eta(xc,dx,b) := subst(x=(w-xc)/(dx/2), b),

    /* Construct the 1D recovery polynomial */
    hOrder : 2*polyOrder+1,
    /* Left and right (of the boundary) basis sets */ 
    pL : eta(-1/2,1,bC1),
    pR : eta(1/2,1,bC1),
    /* Recovery polynomial expanded in z */
    h1 : doExpand1(hn,makelist(w^i,i,0,hOrder)),
    
    /* LHS of system of equations arising from weak equivalence relations */
    eqL : makelist(integrate(h1*pL[i],w,-1,0), i,1,polyOrder+1),
    eqR : makelist(integrate(h1*pR[i],w,0,1), i,1,polyOrder+1),
    LHS : append(eqL,eqR),
    A : coefmatrix(LHS, makelist(hn[i],i,0,hOrder)),
    
    /* RHS is similar to the mass matrix */
    RHS : transpose(append(makelist(fl[i]/2,i,1,N1), makelist(fr[i]/2,i,1,N1))),
    
    /* solve system of equations for coefficients of h */
    S : fullratsimp(invert(A) . RHS),
    hsol1 : makelist(S[i][1],i,1,hOrder+1),

    /*... Recovery polynomial coefficients of requested dimensionality ...*/
    kill(varsC, basisC),
    /* Load basis of dimensionality requested. */
    modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
    load(modNm),

    /* Variables. */
    cv : varsC[dir],
    surfVars : delete(cv,varsC),

    /* Polynomial basis and its derivatives. */
    bC : basisC[polyOrder],
    N : length(bC),
    bCp : diff(bC,cv),

    fg : doExpand(f, bC),	/* Function expanded in basis. */

    /* Obtain the left and right function coefficients
       by projecting the function onto the direction of interest. */
    hcoeff : calcInnerProdList([cv], 1, subst(x=cv,bC1), fg),
    fls : subst(makelist(f[i]=fl[i],i,N), hcoeff),
    frs : subst(makelist(f[i]=fr[i],i,N), hcoeff),

    /* Substitute these "left" and "right" function coefficients,
       which contain variation along other dimensions, into the
       1D recovery polynomial coefficients computed above. */
    hsol : psubst(append(makelist(fl[i]=fls[i], i, 1, N1), makelist(fr[i]=frs[i], i, 1, N1)), hsol1),
    
    /* Write out the full recovery polynomial. */
    h : sum(hsol[i]*cv^(i-1), i, 1, 2*N1),
    /* Evaluate the recovery polynomial at the discontinuity. */
    hsolp0 : subst(cv=0,diff(h,cv)),

    /*............. RECOVERY DONE ..............................*/

    printf(fh,"void ~a_~a_P~a(const double *wl, const double *wr, const double *dxvl, const double *dxvr, const double *nu, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, cvars[dir], polyOrder),
    printf(fh,"// w[NDIM]: Cell-center coordinates. dxv[NDIM]: Cell spacing. nu[NDIM]: diffusion coefficient (collisionality). fl/fr: Distribution function in left/right cells ~%"),
    printf(fh,"// outl/outr: Incremented distribution function in left/right cells ~%"),
    cid : cidx(cdim),
    printf(fh,"  double rdxSq2nul = 2.0*nu[~a]/(dxvl[~a]*dxvl[~a]); ~%", cid[dir], cid[dir], cid[dir]),
    printf(fh,"  double rdxSq2nur = 2.0*nu[~a]/(dxvr[~a]*dxvr[~a]); ~%", cid[dir], cid[dir], cid[dir]),
    printf(fh,"~%"),
  
    /* Contribution to vector to the left and right of the boundary. */
    /* incr_r2 has 3 minus signs. One comes from the second integration
    ** by parts, another from evaluating at upper surface Minus lower
    ** surface, and the last one from evaluating at cv=-1. */
    incr_l1 : calcInnerProdList(surfVars,1,subst(cv=1,bC),hsol[2]),
    incr_l2 : calcInnerProdList(surfVars,-2,subst(cv=1,bCp),hsol[1]),

    incr_r1 : -calcInnerProdList(surfVars,1,subst(cv=-1,bC),hsol[2]),
    incr_r2 : -calcInnerProdList(surfVars,-2,subst(cv=-1,bCp),hsol[1]),
    /* Make these two zero indexed for C++ */
    incr_l1 : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_l1),
    incr_l2 : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_l2),
    incr_r1 : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_r1),
    incr_r2 : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_r2),
    
    /* If value of recovery polynomial at the interface is below zero,
       use its exponential representation. */
    hsol0 : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),hsol),
    printf(fh,"  double incr1[~a]; ~%", length(bC)),
    printf(fh,"  double incr2[~a]; ~%", length(bC)),
    printf(fh,"  if (~a >= 0.0) {~%", float(expand(hsol0[1]))),

    clst : [wxr, dvxr],
    writeCExprsCollect1(incr1, incr_r1, clst),
    printf(fh,"~%"),

    writeCExprsCollect1(incr2, incr_r2, clst),
    printf(fh,"~%"),

    printf(fh,"  } else {~%"),
    printf(fh,"  double xBar = ~a;~%",float((expand(hsol0[2]+3*hsol0[4]/5)/(3*hsol0[1]+hsol0[3])))),
    printf(fh,"  double xBarSq = xBar*xBar;~%"),
    printf(fh,"  double g1 = ~a;~%",float(expand(xBar*(3-xBarSq)/(1-xBarSq)))),
    printf(fh,"  if (std::abs(g1) > 1.0e-15) {~%"),
    hsol[1] : g1*(hsol[1]+hsol[3]/3)/sinh(g1),
    hsol[2] : g1*hsol[1],
    incr_l1E : calcInnerProdList(surfVars,1,subst(cv=1,bC),hsol[2]),
    incr_l2E : calcInnerProdList(surfVars,-2,subst(cv=1,bCp),hsol[1]),
    incr_r1E : -calcInnerProdList(surfVars,1,subst(cv=-1,bC),hsol[2]),
    incr_r2E : -calcInnerProdList(surfVars,-2,subst(cv=-1,bCp),hsol[1]),
    incr_l1E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_l1E),
    incr_l2E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_l2E),
    incr_r1E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_r1E),
    incr_r2E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_r2E),

    clst : [wxr, dvxr],
    writeCExprsCollect1(incr1, incr_r1E, clst),
    printf(fh,"~%"),
    writeCExprsCollect1(incr2, incr_r2E, clst),
    printf(fh,"~%"),
    printf(fh,"  } else {~%"),
    hsol[1] : hsol[1]+hsol[3]/3,
    hsol[2] : 0,
    incr_l1E : calcInnerProdList(surfVars,1,subst(cv=1,bC),hsol[2]),
    incr_l2E : calcInnerProdList(surfVars,-2,subst(cv=1,bCp),hsol[1]),
    incr_r1E : -calcInnerProdList(surfVars,1,subst(cv=-1,bC),hsol[2]),
    incr_r2E : -calcInnerProdList(surfVars,-2,subst(cv=-1,bCp),hsol[1]),
    incr_l1E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_l1E),
    incr_l2E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_l2E),
    incr_r1E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_r1E),
    incr_r2E : psubst(append(makelist(fr[i]=fr[i-1],i,1,N),makelist(fl[i]=fl[i-1],i,1,N)),incr_r2E),

    clst : [wxr, dvxr],
    writeCExprsCollect1(incr1, incr_r1E, clst),
    printf(fh,"~%"),
    writeCExprsCollect1(incr2, incr_r2E, clst),
    printf(fh,"~%"),
    printf(fh,"  };~%"),
    printf(fh, "~%"),
    printf(fh,"  };~%"),
    printf(fh, "~%"),
  
    incr_s1 : makelist(incr1[i-1], i, 1, N),
    incr_s2 : makelist(incr2[i-1], i, 1, N),
    /* Don't do coefficients where the increment is zero */
    for i : 1 thru N do (
      if (incr_r1[i] = 0) then
        incr_s1[i] : 0,
      if (incr_r2[i] = 0) then
        incr_s2[i] : 0
    ), 
    writeCIncrExprs1(outr, rdxSq2nur*(incr_s1+incr_s2)),
    printf(fh, "~%"),
  
/*    signs : fullratsimp(incr_l/incr_r), */
    signs1 : makelist(1,i,1,N),
    signs2 : makelist(1,i,1,N),
    for i : 1 thru N do (
        if (incr_r1[i] = 0) then
          false
        else
          signs1[i] : fullratsimp(incr_l1[i]/incr_r1[i]),
        if (incr_r2[i] = 0) then
          false
        else
          signs2[i] : fullratsimp(incr_l2[i]/incr_r2[i])
    ),
    incr_s1 : makelist(signs1[i]*incr1[i-1], i, 1, N),
    incr_s2 : makelist(signs2[i]*incr2[i-1], i, 1, N),
    /* Don't do coefficients where the increment is zero */
    for i : 1 thru N do (
      if (incr_r1[i] = 0) then
        incr_s1[i] : 0
    ), 
    for i : 1 thru N do (
      if (incr_r2[i] = 0) then
        incr_s2[i] : 0
    ), 
    writeCIncrExprs1(outl, rdxSq2nul*(incr_s1+incr_s2)),
    printf(fh, "~%"),
  
    printf(fh, "} ~%")
));

calcConstDiffusionSurfUpdater(fh, funcNm, cdim, basisFun, polyOrderMax) := block([],
  printf(fh, "#include <ConstDiffusionModDecl.h> ~%"),
  for dir : 1 thru cdim do ( calcUpdateInDir(dir, fh, funcNm, cdim, basisFun, polyOrderMax) )
)$

