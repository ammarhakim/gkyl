/* Kernels for the diffusion term
         L(phi) = nabla^2(phi) = del^2(phi)
   where L=Laplacian, using an FEM method. */

load("modal-basis");
load("out-scripts");
load("nodalOperations/nodalFunctions");
load("mgPoisson-calc/MGpoissonUtil");
load("mgPoisson-calc/FEMnodalFuncs");
fpprec : 24$


calcFEMdiffOp(fh, funcNm, dim, basisFun, polyOrder) := block([],
  /* Compute nabla^2(phi) using FEM. */

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  /* Associative list between stencil location (-1,0,1) and variable
     strings used in kernel names. */
  coordVarS : getCoordVarS(varsC),

  /* List of stencil locations. Each entry is a dim-dimensional list
     with -1 meaning it is at a lower boundary, 1 upper boundary, or
     0 away from boundaries in that direction. */
  stencilLoc : getStencilCoords(dim),

  /* Types of boundary conditions for which to generate kernels.
       =0 periodic
       =1 Dirichlet
       =2 Neumann
       =3 Robin
     For periodic we'll assume ghost cells are filled accordingly
     and use an interior stencil. */
  bcTypes  : [0, 1, 2, 3],
  bcStrs   : ["", "Dirichlet", "Neumann", "Robin"],
  bcKey    : makelist([bcTypes[i],bcStrs[i]],i,1,length(bcTypes)),

  for sI : 1 thru length(stencilLoc) do (

    /* Obtain the different BC combinations for this stencil.
       Will generate a separate kernel for each. */
    bcCombos : getBCcombos(stencilLoc[sI],bcTypes),

    /* Loop over BC combinations. Will create a separate kernel for each. */
    for bcI : 1 thru length(bcCombos) do (

      currBC : copylist(bcCombos[bcI]),

      /* String used in kernel name, identifying stencil location and BC. */
      stencilStr : getStencilStr(stencilLoc[sI],coordVarS,currBC,bcKey),

      /* Each cell only stores the lower left nodes. */
      numStoredNodes : length(getStoredNodes(args(getNodes(basisFun, dim, polyOrder)),stencilLoc[sI])),

      /* Obtain the weak Poisson equation for the stored nodes. */
      weqPoissonLst : weakPoissonStored(basisFun,varsC,polyOrder,stencilLoc[sI],currBC),
      poissonLHS    : weqPoissonLst[1],
      sourceRHS     : weqPoissonLst[2],

      /* Solve for the coefficients of this cell to get the stencil. */
      diffStencil : fullratsimp(makelist(-poissonLHS[i],i,1,numStoredNodes)),

      printf(fh, "void ~a_~aP~a(double **dx, const double *bcVals, double **phi, double *diffOut) ~%{ ~%", funcNm, stencilStr, polyOrder),
      printf(fh, "  // dx:      cell lengths of cells pointed to by the stencil.~%"),
      printf(fh, "  // bcVals:  values to impose as BCs.~%"),
      printf(fh, "  // phi:     iterate cells pointed to by the stencil.~%"),
      printf(fh, "  // diffOut: diffusion term.~%"),
      printf(fh, "~%"),

      /* Pointers to the cell lengths in cells pointed to by the stencil. */
      printf(fh, "  double *dxC  = dx[0]; ~%"),
      printf(fh, "~%"),

      /* This volume factors appears in front of the right-side source term. */
      volumeFac : (1/2)^dim,
      for dir : 1 thru dim do (
        volumeFac : volumeFac*dxC[dir-1]
      ),
      printf(fh, "  double volFac = ~a; ~%", float(volumeFac)),
      printf(fh, "~%"),

      /* Some factors based on cell lengths. */
      printf(fh, "  double rdx2SqVol[~a]; ~%", dim),

      for dir : 1 thru dim do (
        printf(fh, "  rdx2SqVol[~a] = volFac*4.0/(dxC[~a]*dxC[~a]); ~%", dir-1, dir-1, dir-1)
      ),
      printf(fh, "~%"),

      /* Pointers to the data in cells pointed to by the stencil. */
      printf(fh, "  double *phiC = phi[0]; ~%"),
      i : 1,
      varStrs : [""],
      for d : 1 thru dim do (
        for sI : 1 thru 3^(d-1) do (
          for pm : -1 thru 1 step 2 do (
            i : i + 1,
            varStrs : append(varStrs, [sconcat(varStrs[sI],assoc(pm,locStrKey),string(varsC[d]))]),
            printf(fh, "  double *phi~a = phi[~a]; ~%", varStrs[i], i-1)
          )
        )
      ),
      printf(fh, "~%"),

      /* Write the relaxation stencil. */
      writeCExprs1noPowers(diffOut,diffStencil,[rdx2SqVol,bcVals,dxC],18),
      printf(fh, "~%"),

      printf(fh, "}~%"),
      printf(fh, "~%")

    )
  )
)$
