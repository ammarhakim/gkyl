load("modal-basis")$
load("out-scripts");
load(stringproc)$
fpprec : 24$

/* This script generates the kernels for the volume term
   contribution from Lenard Bernstein operator to the
   Vlasov equation using two integrations by parts for
   the diffusive term. */

cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

varsV : [vx, vy, vz]$

doMakeExprLst(vals, S) := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

calcVmLBOconstNuVolUpdater(fh, funcNm, cdim, vdim, basisFun, pMax) := block([],
  printf(fh, "#include <VmLBOModDecl.h> ~%"),
  for polyOrder : 1 thru pMax do (

    kill(varsC, varsP, basisC, basisP),
    /* Load basis of dimensionality requested. */
    modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
    load(modNm),
    vid : vidx(cdim,vdim),

    /* Polynomial basis and its derivatives. */
    bP : basisP[polyOrder],
    bC : basisC[polyOrder],
    NP : length(bP),
    NC : length(bC),

    /* Expand distribution function f in phase basis. */
    f_e    : doExpand1(f, bP),
    /* Expand flow speed u and thermal speed squared in configuration basis. */
    u_e    : doExpand1(u, bC),
    vtSq_e : doExpand1(vtSq, bC),

    /* To allow for multiple components change the cofficient indices in Ae and Be. */
    u_e : psubst(makelist(u[i]=u[a0+i],i,0,NC-1),u_e),

    /* w-u part of the drag term. */
    drBar_e : doExpand1(drBar,bC),
    drBar_e : psubst(makelist(drBar[i]=drBar[a0+i],i,0,NC-1),drBar_e),
    
    /* Volume increment. */
    incr : (
      incr : 0,
      for dir : 1 thru vdim do (
        cv : varsV[dir],
        incr : incr+(-nu*calcInnerProdList(varsP,cv,diff(bP,cv),f_e)
	       +rdv2[dir-1]*subst(a0=NC*(dir-1),calcInnerProdList(varsP,drBar_e,diff(bP,cv),f_e)))
               +rdvSq4[dir-1]*nu*calcInnerProdList(varsP,vtSq_e,diff(bP,cv,2),f_e)
      ),
      incr
    ),

    printf(fh, "double ~aP~a(const double *w, const double *dxv, const double nu, const double *u, const double *vtSq, const double *f, double *out) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // w[~a]:   Cell-center coordinates. ~%", cdim+vdim),
    printf(fh, "  // dxv[~a]: Cell spacing. ~%", cdim+vdim),
    printf(fh, "  // nu:     diffusion coefficient (collisionality). ~%"),
    printf(fh, "  // u:      bulk velocity. ~%"),
    printf(fh, "  // vtSq:   thermal speed squared. ~%"),
    printf(fh, "  // f:      Input distribution function. out: Incremented output ~%"),
    printf(fh, "  // out:    Incremented output ~%"),
    cid : cidx(cdim),
    printf(fh, "  double rdv2[~a]; ~%", vdim),
    printf(fh, "  double rdvSq4[~a]; ~%", vdim),
    for dir : 1 thru vdim do (
      printf(fh, "  rdv2[~a] = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
      printf(fh, "  rdvSq4[~a] = 4.0/(dxv[~a]*dxv[~a]); ~%", dir-1, vid[dir], vid[dir])
    ),
    printf(fh, "~%"),

    /* Compute the nu*(wxl-u) drift part separately. */
    printf(fh, "  double drBar[~a]; ~%", NC*vdim),
    /* -nu*(w-u) part of the drag term. */
    for dir : 1 thru vdim do (
       drBar_c : subst(a0=NC*(dir-1),calcInnerProdList(varsC,1,bC,-nu*(w[vid[dir]]-u_e))),
       for i : 1 thru NC do (
          printf(fh, "  ~a = ~a; ~%", drBar[NC*(dir-1)+i-1], float(expand(drBar_c[i])))
       )
    ),
    printf(fh, "~%"),
  
    clst : append(makelist(rdv2[i],i,0,vdim-1),makelist(rdvSq4[i],i,0,vdim-1)),
    writeCIncrExprsCollect1(out, incr, clst),
    printf(fh, "~%"),

    /* Calculate nu*vtSq at cell center for CFL condition */
    nuVtSqP_c : nu*calcInnerProdList(varsP,1,bP,vtSq_e),
    nvlst : doMakeExprLst(nuVtSqP_c, nuVtSqP),
    nuVtSqP_e : doExpandLst(nvlst, bP),

    printf(fh, "  double nuVtSqP[~a]; ~%", 0, length(bP)),
    writeCExprsCollect1(nuVtSqP, nuVtSqP_c, []),

    zr : makelist(varsP[d]=0, d, 1, length(varsP)),
    nuVtSqMid : float(expand(fullratsimp(subst(zr,nuVtSqP_e)))),
    printf(fh, "  const double nuVtSqMid = ~a; ~%", nuVtSqMid),
    
    if vdim = 1 then (
      printf(fh, "return nuVtSqMid*rdvSq4[0]; ~%")
    ),
    if vdim = 2 then (
      printf(fh, "return nuVtSqMid*(rdvSq4[0]+rdvSq4[1]); ~%")
    ),
    if vdim = 3 then (
      printf(fh, "return nuVtSqMid*(rdvSq4[0]+rdvSq4[1]+rdvSq4[2]); ~%")
    ),
    printf(fh, "~%"),
  
    printf(fh, "} ~%")
));

