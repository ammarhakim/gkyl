load("modal-basis")$
load("out-scripts");
load(stringproc)$
fpprec : 24$

/* This script generates the kernels for the volume term
   contribution from Lenard Bernstein operator to the
   gyrokinetic equation using two integrations by parts for
   the diffusive term. */

cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

varsV : [vpar, mu]$
gkvsub: [vx=vpar,vy=mu]$

doMakeExprLst(vals, S) := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

load ("scifac")$
writeCExprsCollect1c(rhs) := block([expr],
  expr : float(expand(rhs)),
  for i : 1 thru length(expr) do (
     if expr[i] # 0.0 then printf(fh, "  ~a += ~a; ~%", out[i-1], gcfac(expr[i]))
  )
)$

calcGkLBOconstNuVolUpdater(fh, funcNm, cdim, vdim, basisFun, pMax) := block([],
  printf(fh, "#include <GkLBOModDecl.h> ~%"),
  for polyOrder : 1 thru pMax do (

    kill(varsC, varsP, basisC, basisP),
    /* Load basis of dimensionality requested. */
    modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
    load(modNm),
    vid : vidx(cdim,vdim),
    /* Rename independent variables in bases. */
    varsP : subst(gkvsub, varsP),

    /* Polynomial basis and its derivatives. */
    bP : subst(gkvsub, basisP[polyOrder]),
    bC : basisC[polyOrder],
    NP : length(bP),
    NC : length(bC),

    /* Expand distribution function f in phase basis. */
    f_e  : doExpand1(f, bP),
    /* Expand flow speed u and thermal speed squared in configuration basis. */
    u_e    : doExpand1(u, bC),
    vtSq_e : doExpand1(vtSq, bC),    
    
    /* Volume increment. */
    /* vpar contribution */
    cv   : varsV[1],
    bPp  : diff(bP,cv),
    bPpp : diff(bP,cv,2),
    alpha0_c : calcInnerProdList(varsP,1,bP,-nu*cv + rdv2nu[0]*(-w[vid[1]] + u_e)),
    alst0 : doMakeExprLst(alpha0_c, alpha0),
    alpha0_e : doExpandLst(alst0, bP),

    alpha1_c : calcInnerProdList(varsP,rdvSq4nu[0],bP,vtSq_e),
    alst1 : doMakeExprLst(alpha1_c, alpha1),
    alpha1_e : doExpandLst(alst1, bP),

    incr : fullratsimp(calcInnerProdList(varsP,alpha0_e,bPp,f_e)
           +calcInnerProdList(varsP,alpha1_e,bPpp,f_e)),
    
    /* mu contribution. Last 3 terms from 2nd int by parts */
    if vdim = 2 then (
	cv   : varsV[2],
	bPp  : diff(bP,cv),
    	bPpp : diff(bP,cv,2),
	BmagInv_e : doExpand1(BmagInv,bC),

	mufac0_c : calcInnerProdList(varsP,1,bP,-2*(nu*cv + rdv2nu[1]*(w[vid[2]] - m_*BmagInv_e*vtSq_e))),
	mlst0 :  doMakeExprLst(mufac0_c, mufac0),
    	mufac0_e : doExpandLst(mlst0, bP),

	mufac1_c : calcInnerProdList(varsP,1,bP,2*m_*BmagInv_e*vtSq_e*(rdv2nu[1]*cv + rdvSq4nu[1]*w[vid[2]])),
	mlst1 :  doMakeExprLst(mufac1_c, mufac1),
    	mufac1_e : doExpandLst(mlst1, bP),
	
	incr : fullratsimp(incr
              +calcInnerProdList(varsP,mufac0_e,bPp,f_e)
              +calcInnerProdList(varsP,mufac1_e,bPpp,f_e))
    ),
    
    printf(fh, "double ~aP~a(const double m_, const double *w, const double *dxv, const double *BmagInv, const double nu, const double *u, const double *vtSq, const double *f, double *out) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // w[~a]:    Cell-center coordinates. ~%", cdim+vdim),
    printf(fh, "  // dxv[~a]:  Cell spacing. ~%", cdim+vdim),
    printf(fh, "  // nu:      diffusion coefficient (collisionality). ~%"),
    printf(fh, "  // u[~a]:    bulk velocity. ~%", NC),
    printf(fh, "  // vtSq[~a]: thermal speed squared. ~%", NC),
    printf(fh, "  // f[~a]:    Input distribution function. ~%", NP),
    printf(fh, "  // out[~a]:  Incremented output ~%", NP),
    cid : cidx(cdim),
    printf(fh, "  double rdv2nu[~a]; ~%", vdim),
    printf(fh, "  double rdvSq4nu[~a]; ~%", vdim),
    for dir : 1 thru vdim do (
      printf(fh, "  rdv2nu[~a] = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
      printf(fh, "  rdvSq4nu[~a] = nu*rdv2nu[~a]*rdv2nu[~a]; ~%", dir-1, dir-1, dir-1),
      printf(fh, "  rdv2nu[~a] = nu*rdv2nu[~a]; ~%", dir-1, dir-1)
    ),
    printf(fh, "~%"),

    /* Print all alphas */
    printf(fh, "  double alpha~a[~a]; ~%", 0, length(bP)),
    clst : [rdv2nu[0]],
    writeCExprsCollect1(alpha0, alpha0_c, clst),
    printf(fh, "~%"),
    printf(fh, "  double alpha~a[~a]; ~%", 1, length(bP)),
    clst : [rdvSq4nu[0]],
    writeCExprsCollect1(alpha1, alpha1_c, clst),
    printf(fh, "~%"),

    if vdim = 2 then (
        /* Print all mufacs */
    	printf(fh, "  double mufac~a[~a]; ~%", 0, length(bP)),
   	writeCExprsCollect1(mufac0, mufac0_c, []),
	printf(fh, "~%"),
        printf(fh, "  double mufac~a[~a]; ~%", 1, length(bP)),
    	writeCExprsCollect1(mufac1, mufac1_c, []),
	printf(fh, "~%")    
    ),

    clst : makelist(f[i],i,0,NC-1),
    writeCExprsCollect1c(radcan(incr)),
    printf(fh, "~%"),

    /* Return coefficients for CFL condition */
    zr : makelist(varsP[d]=0, d, 1, length(varsP)),
    alpha0Mid : float(expand(fullratsimp(subst(zr,alpha0_e)))),
    printf(fh, "  const double alpha0Mid = ~a; ~%", alpha0Mid),
    alpha1Mid : float(expand(fullratsimp(subst(zr,alpha1_e)))),
    printf(fh, "  const double alpha1Mid = ~a; ~%", (polyOrder+1)*(polyOrder+1)*alpha1Mid/(2*polyOrder+1)), 
    if vdim = 1 then (
       printf(fh, "  return std::abs(alpha0Mid) + alpha1Mid; ~%")
    ),
    if vdim = 2 then (
       	mufacD_c : calcInnerProdList(varsP,1,bP,-2*(nu*cv + rdv2nu[1]*w[vid[2]])),
	mlst :  doMakeExprLst(mufacD_c, mufacD),
    	mufacD_e : doExpandLst(mlst, bP),
	printf(fh, "  double mufacD[~a]; ~%", length(bP)),
   	writeCExprsCollect1(mufacD, mufacD_c, []),
	printf(fh, "~%"),

        mufacDMid : float(expand(fullratsimp(subst(zr,mufacD_e)))),
    	printf(fh, "  const double mufacDMid = ~a; ~%", mufacDMid),
       	mufac1Mid : float(expand(fullratsimp(subst(zr,mufac1_e)))),
       	printf(fh, "  const double mufac1Mid = ~a; ~%", (polyOrder+1)*(polyOrder+1)*mufac1Mid/(2*polyOrder+1)),
       	printf(fh, "  return std::abs(alpha0Mid) + alpha1Mid + std::abs(mufacDMid) + mufac1Mid; ~%")
    ),
    printf(fh, "~%"),
  
    printf(fh, "} ~%")
));

