load("modal-basis")$
load("out-scripts");
load(stringproc)$
fpprec : 24$

/* This script generates the kernels for the volume term
   contribution from Lenard Bernstein operator to the
   gyrokinetic equation using two integrations by parts for
   the diffusive term. */

cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

varsV : [vpar, mu]$
gkvsub: [vx=vpar,vy=mu]$

calcGkLBOconstNuVolUpdater(fh, funcNm, cdim, vdim, basisFun, pMax) := block([],
  printf(fh, "#include <GkLBOModDecl.h> ~%"),
  for polyOrder : 1 thru pMax do (

    kill(varsC, varsP, basisC, basisP),
    /* Load basis of dimensionality requested. */
    modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
    load(modNm),
    vid : vidx(cdim,vdim),
    /* Rename independent variables in bases. */
    varsP : subst(gkvsub, varsP),

    /* Polynomial basis and its derivatives. */
    bP : subst(gkvsub, basisP[polyOrder]),
    bC : basisC[polyOrder],
    NP : length(bP),
    NC : length(bC),

    /* Expand distribution function f in phase basis. */
    f_e    : doExpand1(f, bP),
    /* Expand flow speed u and thermal speed squared in configuration basis. */
    nuU_e    : doExpand1(nuU, bC),
    nuVtSq_e : doExpand1(nuVtSq, bC),

    /* -nu*w+u part of the vpar drag term. */
    drBar_e : doExpand1(drBar,bC),
    
    /* Volume increment. */
    /* vpar contribution */
    cv   : varsV[1],
    bPp  : diff(bP,cv),
    incr : (-nu*calcInnerProdList(varsP,cv,bPp,f_e)
           +rdv2[0]*calcInnerProdList(varsP,drBar_e,bPp,f_e))
           +rdvSq4[0]*calcInnerProdList(varsP,nuVtSq_e,diff(bP,cv,2),f_e),
    
    /* mu contribution. Last 3 terms from 2nd int by parts */
    if vdim = 2 then (
	cv   : varsV[2],
        bPp  : diff(bP,cv),
        bPpp : diff(bP,cv,2),
        w_e  : doExpand(calcInnerProdList(varsC,1,bC,w[vid[2]]),bC),
        incr : incr + 2*(-nu*(calcInnerProdList(varsP,cv,bPp,f_e)
              +rdv2[1]*calcInnerProdList(varsP,w_e,bPp,f_e))
              +m_*(rdv2[1]*(calcInnerProdList(varsP,nuVtSq_e*cv,bPpp,f_e)
	      +calcInnerProdList(varsP,nuVtSq_e,bPp,f_e))
	      +rdvSq4[1]*calcInnerProdList(varsP,nuVtSq_e*w_e,bPpp,f_e)))
    ),
    
    printf(fh, "double ~aP~a(const double m_, const double *w, const double *dxv, const double nu, const double *nuU, const double *nuVtSq, const double *f, double *out) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // w[NDIM]: Cell-center coordinates. dxv[NDIM]: Cell spacing. nu: diffusion coefficient (collisionality). nuU: bulk velocity times nu. nuVtSq: thermal speed squared times nu. f: Input distribution function. out: Incremented output ~%"),
    cid : cidx(cdim),
    printf(fh, "  double rdv2[~a]; ~%", vdim),
    printf(fh, "  double rdvSq4[~a]; ~%", vdim),
    for dir : 1 thru vdim do (
      printf(fh, "  rdv2[~a] = 2.0/dxv[~a]; ~%", dir-1, vid[dir]),
      printf(fh, "  rdvSq4[~a] = rdv2[~a]*rdv2[~a]; ~%", dir-1, dir-1, dir-1)
    ),
    printf(fh, "~%"),

    /* Compute the nu*wx-nuU drift part separately. */
    printf(fh, "  double drBar[~a]; ~%", NC),
    /* -nu*(w-u) part of the drag term. */
    drBar_c : calcInnerProdList(varsC,1,bC,-nu*w[vid[1]]+nuU_e),
    for i : 1 thru NC do (
       printf(fh, "  ~a = ~a; ~%", drBar[i-1], float(expand(drBar_c[i])))
    ),
    printf(fh, "~%"),
  
    clst : append(makelist(rdv2[i],i,0,vdim-1),makelist(rdvSq4[i],i,0,vdim-1),[m_,nu]),
    writeCIncrExprsCollect1(out, incr, clst),
    printf(fh, "~%"),

    if vdim = 1 then (
      printf(fh, "return nu*rdvSq4[0]*0.5; ~%")
    ),
    if vdim = 2 then (
      printf(fh, "return nu*(rdvSq4[0]+rdvSq4[1])*0.5; ~%")
    ),
    printf(fh, "~%"),
  
    printf(fh, "} ~%")
));

