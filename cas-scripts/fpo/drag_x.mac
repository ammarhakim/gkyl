kill(all) $
load("modal-basis") $
assume(dx>0, dy>0) $

polyOrder : 1 $
N : polyOrder + 1 $
load("basis-precalc/basisSer1x") $
basis1D : basisC[polyOrder] $
load("basis-precalc/basisSer2x") $
basis2D : basisC[polyOrder] $

eta(xc, yc, dx, dy, basis) := subst([wx=x, wy=y], subst([x=(wx-xc)/(dx/2), y=(wy-yc)/(dy/2)] , basis)) $
/* dx : 2 $ */
/* dy : 2 $ */
baC : eta(0, 0, dx, dy, basis2D) $
baL : eta(-dx/2, 0, dx, dy, basis1D) $
baR : eta(dx/2, 0, dx, dy, basis1D) $

rExp : doExpand(r, makelist(x^i, i, 0, 2*N-1)) $
recEqList : append(
  calcInnerProdListGen([x], [[-dx,0]], 1, baL, rExp-doExpand(q1L, baL)),
  calcInnerProdListGen([x], [[0,dx]], 1, baR, rExp-doExpand(q1R, baR))
) $
rSol : linsolve(recEqList, makelist(r[i], i, 1, 2*N)) $
rSub : fullratsimp(subst(rSol, rExp)) $

projCoeff : calcInnerProdList([x], 1, basis1D, doExpand(q2, basis2D)) $
q1LProj : subst(makelist(q2[i]=q2L[i], i, 1, length(basis2D)), projCoeff) $
q1RProj : subst(makelist(q2[i]=q2R[i], i, 1, length(basis2D)), projCoeff) $

projSubList : append (
  makelist(q1L[i]=q1LProj[i], i, 1, N),
  makelist(q1R[i]=q1RProj[i], i, 1, N)
) $
r2Sub : subst(projSubList, rSub) $

hLSubList : append(
  makelist(q2L[i]=hLPtr[i], i, 1, length(basis2D)),
  makelist(q2R[i]=hPtr[i], i, 1, length(basis2D))
) $
hRSubList : append(
  makelist(q2L[i]=hPtr[i], i, 1, length(basis2D)),
  makelist(q2R[i]=hRPtr[i], i, 1, length(basis2D))
) $
fLSubList : append(
  makelist(q2L[i]=fLPtr[i], i, 1, length(basis2D)),
  makelist(q2R[i]=fPtr[i], i, 1, length(basis2D))
) $
fRSubList : append(
  makelist(q2L[i]=fPtr[i], i, 1, length(basis2D)),
  makelist(q2R[i]=fRPtr[i], i, 1, length(basis2D))
) $

surfR : calcInnerProdListGen([y], [[-dy/2, dy/2]], 1, subst(x=dx/2, baC),
  subst(x=0, diff(subst(hRSubList, r2Sub), x)*subst(fRSubList, r2Sub))*2/dy) $
surfL : calcInnerProdListGen([y], [[-dy/2, dy/2]], 1, subst(x=-dx/2, baC),
  subst(x=0, diff(subst(hLSubList, r2Sub), x)*subst(fLSubList, r2Sub))*2/dy) $

fh : openw("~/max-out/drag_x")$
printf(fh, "if isLeftEdge then~%") $
gs : float(expand(surfR)) $
for i : 1 thru length(baC) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fPtr[i] - dt*gs[i]) $
printf(fh, "elseif isRightEdge then~%") $
gs : float(expand(-surfL)) $
for i : 1 thru length(baC) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fPtr[i] - dt*gs[i]) $
printf(fh, "else~%") $
gs : float(expand(surfR-surfL)) $
for i : 1 thru length(baC) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fPtr[i] - dt*gs[i]) $
printf(fh, "end~%~%") $

vol : calcInnerProdListGen([x,y], [[-dx/2, dx/2],[-dy/2, dy/2]], 1, diff(baC, x),
    diff(doExpand(hPtr, baC), x)*doExpand(fPtr, baC)*4/(dx*dy)) $
  
gs : float(expand(vol)) $
for i : 1 thru length(baC) do printf(fh, "fOutPtr[~a] = ~a~%", i, fOutPtr[i] + dt*gs[i]) $

close(fh) $