load("modal-basis")$
load("out-scripts")$
load(stringproc)$
fpprec : 24$
load("eigen")$

nodes1xp1 : [[-1],[1]]$
nodes1xp2 : [[-1],[0],[1]]$
nodes2xp1 : [[-1,-1],[1,-1],[-1,1],[1,1]]$
nodes2xp2 : [[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]]$
nodes3xp1 : [[-1,-1,-1],[1,-1,-1],[-1,1,-1],[1,1,-1],[-1,-1,1],[1,-1,1],[-1,1,1],[1,1,1]]$
nodes3xp2 : [[-1,-1,-1],[0,-1,-1],[1,-1,-1],[-1,0,-1],[1,0,-1],[-1,1,-1],[0,1,-1],[1,1,-1],
            [-1,-1,0],[1,-1,0],[-1,1,0],[1,1,0],
            [-1,-1,1],[0,-1,1],[1,-1,1],[-1,0,1],[1,0,1],[-1,1,1],[0,1,1],[1,1,1]]$

/* calculate modal-to-nodal transformation matrix */
calcModToNod(cdim, p) := block([], 
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
nodes : eval_string(sconcat("nodes", cdim, "xp", p)),
n : length(nodes),
if cdim=1 then (
modToNod : (
  for i:1 thru n do (
  col : subst(nodes[i][1],x,basis),
  col : columnvector(col),
  if i = 1 then modToNod:col else modToNod:addcol(modToNod,col)
  ),modToNod)
) else if cdim=2 then (
modToNod:(
    for i:1 thru n do (
    col : subst(nodes[i][1],x,basis),
    col : subst(nodes[i][2],y,col),
    col : columnvector(col),
    if i = 1 then modToNod:col else modToNod:addcol(modToNod,col)
    ),modToNod)
) else (
modToNod:(
    for i:1 thru n do (
    col : subst(nodes[i][1],x,basis),
    col : subst(nodes[i][2],y,col),
    col : subst(nodes[i][3],z,col),
    col : columnvector(col),
    if i = 1 then modToNod:col else modToNod:addcol(modToNod,col)
    ),modToNod)
),
return(modToNod)
)$

/* calculate nodal-to-modal transformation matrix */
calcNodToModPerp(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
modToNod : calcModToNod(cdim, p),
nodToMod:float(invert(transpose(modToNod)))
)$

calcNodToModPar(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
if cdim=1 then modToNod : calcModToNod(cdim, p)
else if cdim=3 then (
nodes : eval_string(sconcat("nodes", cdim, "xp", p)),
n : length(nodes),
modToNod:(
    for i:1 thru n do (
    col : subst(nodes[i][1],z,basis),
    col : subst(nodes[i][2],x,col),
    col : subst(nodes[i][3],y,col),
    col : columnvector(col),
    if i = 1 then modToNod:col else modToNod:addcol(modToNod,col)
    ),modToNod)
),
nodToMod:float(invert(transpose(modToNod)))
)$

/* calculate weighted nodal mass matrix */
calcMass(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
w_expd : doExpand1(w, basis),
massMod : calcMassMatrix(varsC, w_expd, basis),
modToNod : calcModToNod(cdim, p),
massNod:float(expand(ratsimp(ratsimp(invert(modToNod)).massMod.ratsimp(invert(transpose(modToNod)))))),
return(massNod)
)$

/* calculate unweighted nodal mass matrix */
calcUnweightedMass(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
w_expd : doExpand1(w, basis),
massMod : calcMassMatrix(varsC, 1, basis),
modToNod : calcModToNod(cdim, p),
massNod:float(expand(ratsimp(ratsimp(invert(modToNod)).massMod.ratsimp(invert(transpose(modToNod)))))),
return(massNod)
)$

/* calculate weighted nodal perpendicular stiffness matrix (cdim=2,3 only) */
calcStiffPerp(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
w_expd : doExpand1(w, basis),
modToNod : calcModToNod(cdim, p),
stiffPerpMod:dfacx2*calcWeightedStiffMatrix(x,varsC,w_expd,basis)+dfacy2*calcWeightedStiffMatrix(y,varsC,w_expd,basis),
stiffPerpNod:float(expand(ratsimp(ratsimp(invert(modToNod)).stiffPerpMod.ratsimp(invert(transpose(modToNod)))))),
return(stiffPerpNod)
)$

/* calculate unweighted nodal perpendicular stiffness matrix (cdim=2,3 only) */
calcUnweightedStiffPerp(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
w_expd : 1,
modToNod : calcModToNod(cdim, p),
stiffPerpMod:dfacx2*calcWeightedStiffMatrix(x,varsC,w_expd,basis)+dfacy2*calcWeightedStiffMatrix(y,varsC,w_expd,basis),
stiffPerpNod:float(expand(ratsimp(ratsimp(invert(modToNod)).stiffPerpMod.ratsimp(invert(transpose(modToNod)))))),
return(stiffPerpNod)
)$

/* calculate weighted nodal perpendicular stiffness matrix (cdim=2,3 only) */
calcStiffPerpMetric(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
wxx_expd : doExpand1(w, basis)*doExpand1(gxx, basis),
wxy_expd : doExpand1(w, basis)*doExpand1(gxy, basis),
wyy_expd : doExpand1(w, basis)*doExpand1(gyy, basis),
modToNod : calcModToNod(cdim, p),
stiffPerpMod:dfacx2*calcWeightedStiffMatrix(x,varsC,wxx_expd,basis)+dfacy2*calcWeightedStiffMatrix(y,varsC,wyy_expd,basis)+dfacxy*calcWeightedStiffMatrixCross(x,y,varsC,wxy_expd,basis),
stiffPerpNod:float(expand(ratsimp(ratsimp(invert(modToNod)).stiffPerpMod.ratsimp(invert(transpose(modToNod)))))),
return(stiffPerpNod)
)$

/* calculate weighted nodal parallel stiffness matrix (cdim=1,3 only) */
calcStiffPar(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
w_expd : doExpand1(w, basis),
if cdim=1 then modToNod : calcModToNod(cdim, p)
else if cdim=3 then (
nodes : eval_string(sconcat("nodes", cdim, "xp", p)),
n : length(nodes),
modToNod:(
    for i:1 thru n do (
    col : subst(nodes[i][1],z,basis),
    col : subst(nodes[i][2],x,col),
    col : subst(nodes[i][3],y,col),
    col : columnvector(col),
    if i = 1 then modToNod:col else modToNod:addcol(modToNod,col)
    ),modToNod)
),
stiffParMod:dfacz2*calcWeightedStiffMatrix(varsC[cdim],varsC,w_expd,basis),
stiffParNod:float(expand(ratsimp(ratsimp(invert(modToNod)).stiffParMod.ratsimp(invert(transpose(modToNod)))))),
return(stiffParNod)
)$

/* calculate unweighted nodal parallel stiffness matrix (cdim=1,3 only) */
calcUnweightedStiffPar(cdim, p) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basisSer", cdim, "x"),
load(modNm),
basis : basisC[p],
w_expd : 1,
if cdim=1 then modToNod : calcModToNod(cdim, p)
else if cdim=3 then (
nodes : eval_string(sconcat("nodes", cdim, "xp", p)),
n : length(nodes),
modToNod:(
    for i:1 thru n do (
    col : subst(nodes[i][1],z,basis),
    col : subst(nodes[i][2],x,col),
    col : subst(nodes[i][3],y,col),
    col : columnvector(col),
    if i = 1 then modToNod:col else modToNod:addcol(modToNod,col)
    ),modToNod)
),
stiffParMod:dfacz2*calcWeightedStiffMatrix(varsC[cdim],varsC,w_expd,basis),
stiffParNod:float(expand(ratsimp(ratsimp(invert(modToNod)).stiffParMod.ratsimp(invert(transpose(modToNod)))))),
return(stiffParNod)
)$

/* write a C++ function that sets up a matrix for various dimensionalities and polynomial orders */
writeCMatFunc(prototype, func, onlyDims, printDfacsPerp, printDfacsPar) := block([],
printf(fh, "~a~%", prototype),
printf(fh, "{~%"),
if printDfacsPerp then (
printf(fh, "  double dfacx2 = 4.0/(dx*dx);~%"),
printf(fh, "  double dfacxy = 4.0/(dx*dy);~%"),
printf(fh, "  double dfacy2 = 4.0/(dy*dy);~%")
),
if printDfacsPar then (
printf(fh, "  double dfacz2 = 4.0/(dz*dz);~%")
),
first : true,
if member(1, onlyDims) then (
if first then (
  printf(fh, "  if(ndim==1) {~%"),
  first : false
)
else printf(fh, "  else if(ndim==1) {~%"),
printf(fh, "    if(polyOrder == 1)~%"),
printf(fh, "    {~%"),
mat : func(1,1),
writeEigenMatrix(mat),
printf(fh, "    }~%"),
printf(fh, "    else if (polyOrder == 2)~%"),
printf(fh, "    {~%"),
mat : func(1,2),
writeEigenMatrix(mat),
printf(fh, "    }~%"),
printf(fh, "  }~%")
),
if member(2, onlyDims) then (
if first then (
  printf(fh, "  if(ndim==2) {~%"),
  first : false
)
else printf(fh, "  else if(ndim==2) {~%"),
printf(fh, "    if(polyOrder == 1)~%"),
printf(fh, "    {~%"),
mat : func(2,1),
writeEigenMatrix(mat),
printf(fh, "    }~%"),
printf(fh, "    else if (polyOrder == 2)~%"),
printf(fh, "    {~%"),
mat : func(2,2),
writeEigenMatrix(mat),
printf(fh, "    }~%"),
printf(fh, "  }~%")
),
if member(3, onlyDims) then (
if first then (
  printf(fh, "  if(ndim==3) {~%"),
  first : false
)
else printf(fh, "  else if(ndim==3) {~%"),
printf(fh, "    if(polyOrder == 1)~%"),
printf(fh, "    {~%"),
mat : func(3,1),
writeEigenMatrix(mat),
printf(fh, "    }~%"),
printf(fh, "    else if (polyOrder == 2)~%"),
printf(fh, "    {~%"),
mat : func(3,2),
writeEigenMatrix(mat),
printf(fh, "    }~%"),
printf(fh, "  }~%")
),
printf(fh, "}~%~%")
)$

fh : openw("~/max-out/FemMatrices.cpp")$
header : openw("~/max-out/FemMatrices.h")$
printf(header, "#include <Eigen/Core> ~%")$
printf(fh, "#include <FemMatrices.h> ~%")$
/* write getMassMatrix C function */
prototype:"void getMassMatrix(Eigen::MatrixXd& mat, double *w, int ndim, int polyOrder)"$
writeCMatFunc(prototype, calcMass, [1,2,3], false, false)$
printf(header, "~a;~%", prototype)$
/* write getMassMatrix (unweighted) C function */
prototype:"void getMassMatrix(Eigen::MatrixXd& mat, int ndim, int polyOrder)"$
writeCMatFunc(prototype, calcUnweightedMass, [1,2,3], false, false)$
printf(header, "~a;~%", prototype)$
/* write getPerpNodToModMatrix C function */
prototype:"void getPerpNodToModMatrix(Eigen::MatrixXd& mat, int ndim, int polyOrder)"$
writeCMatFunc(prototype, calcNodToModPerp, [2,3], false, false)$
printf(header, "~a;~%", prototype)$
/* write getParNodToModMatrix C function */
prototype:"void getParNodToModMatrix(Eigen::MatrixXd& mat, int ndim, int polyOrder)"$
writeCMatFunc(prototype, calcNodToModPar, [1,3], false, false)$
printf(header, "~a;~%", prototype)$
/* write getPerpStiffnessMatrix C function */
prototype:"void getPerpStiffnessMatrix(Eigen::MatrixXd& mat, double *w, int ndim, int polyOrder, double dx, double dy)"$
writeCMatFunc(prototype, calcStiffPerp, [2,3], true, false)$
printf(header, "~a;~%", prototype)$
/* write getPerpStiffnessMatrix C function with metric */
prototype:"void getPerpStiffnessMatrix(Eigen::MatrixXd& mat, double *w, double *gxx, double *gxy, double *gyy, int ndim, int polyOrder, double dx, double dy)"$
writeCMatFunc(prototype, calcStiffPerpMetric, [2,3], true, false)$
printf(header, "~a;~%", prototype)$
/* write getPerpStiffnessMatrix (unweighted) C function */
prototype:"void getPerpStiffnessMatrix(Eigen::MatrixXd& mat, int ndim, int polyOrder, double dx, double dy)"$
writeCMatFunc(prototype, calcUnweightedStiffPerp, [2,3], true, false)$
printf(header, "~a;~%", prototype)$
/* write getParStiffnessMatrix C function */
prototype:"void getParStiffnessMatrix(Eigen::MatrixXd& mat, double *w, int ndim, int polyOrder, double dz)"$
writeCMatFunc(prototype, calcStiffPar, [1,3], false, true)$
printf(header, "~a;~%", prototype)$
/* write getParStiffnessMatrix (unweighted) C function */
prototype:"void getParStiffnessMatrix(Eigen::MatrixXd& mat, int ndim, int polyOrder, double dz)"$
writeCMatFunc(prototype, calcUnweightedStiffPar, [1,3], false, true)$
printf(header, "~a;~%", prototype)$
close(fh)$
close(header)$
