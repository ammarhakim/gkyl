/* Compute the surf term for ONLY the streaming term (v . grad(f))
   in the Vlasov-Poisson and Vlasov-Maxwell equations. */
load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("scifac")$
fpprec : 24$

varsV : [vx, vy, vz]$
cvars : [X, Y, Z]$
vvars : [VX, VY, VZ]$

vc : [vx_c, vy_c, vz_c]$ /* For velocity components pointer. */

cidx(cdim)      := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

/* Helper functions for expanding in basis functions a quantity we know should be sparse  */
/* For example, alpha, the phase space flow only depends on a few phase space coordinates */
doMakeExprLst(vals, S)  := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

calcVlasovGenGeoSurfUpdater(dir, fh, funcNm, cdim, vdim, basisFun, p) := block([bP,numBasisP,cid,vid,wvl,wvr,dvl,dvr,cv,vv,surfVars,fL_e,fR_e,fhat,surfTerm,incr_r,clst,incr_s],

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v")),

  bC        : basisC[p],
  bP        : basisP[p],
  NC        : length(bC),
  numBasisP : length(bP),

  printf(fh, "__host__ __device__ void ~a_~a_P~a(const double *wl, const double *wr, const double *dxvl, const double *dxvr, const double *tvComp,  double const *gxx, double const *gxy, double const *gxz, double const *gyz, double const *gzz, const double *jacobGeo, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, cvars[dir], p),
  printf(fh, "  // w[NDIM]:   Cell-center coordinates.~%"),
  printf(fh, "  // dxv[NDIM]: Cell spacing.~%"),
  printf(fh, "  // tvComp:    Tangent vector components.~%"),  
  printf(fh, "  // gij:       Contravariant metric coefficients.~%"), 
  printf(fh, "  // jacobGeo:  General geometry Jacobian.~%"),
  printf(fh, "  // fl/fr:     Distribution function in left/right cells.~%"),
  printf(fh, "  // outl/outr: Incremented distribution function in left/right cells.~%"),

  printf(fh, "~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),

  /* Cell centers and lengths along velocity space. */
  wvl : wl[vid[dir]],
  wvr : wr[vid[dir]],
  dvl : dxvl[vid[dir]],
  dvr : dxvr[vid[dir]],

  printf(fh, "  double rdxl2 = 2.0/dxvl[~a]; ~%", cid[dir]),
  printf(fh, "  double rdxr2 = 2.0/dxvr[~a]; ~%~%", cid[dir]),

  cv : varsP[dir],
  vv : varsV[dir],
  surfVars : delete(cv,varsP),

  tvComp_e : doExpand1(tvComp, bP),
  gxx_e : doExpand1(gxx, bC),
  gxy_e : doExpand1(gxy, bC),
  gxz_e : doExpand1(gxz, bC),
  gyy_e : doExpand1(gyy, bC),
  gyz_e : doExpand1(gyz, bC),
  gzz_e : doExpand1(gzz, bC),

  /* For multiple components, change indices. */
  tvComp_e : psubst(makelist(tvComp[i]=tvComp[a0+i],i,0,NC-1),tvComp_e),

  vTemp_c :  makelist(0, i, 1, cdim), 				 
  /* Calculate v_i components: v_x = v_X*dX/dx + v_Y*dY/dx + v_Z*dZ/dx, ...  in left cell. */
  for dir1 : 1 thru cdim do (
    vTemp_c[dir1] : 0,
    for dir2 : 1 thru vdim do (
    	tvi : (dir1 - 1)*cdim + (dir2-1),
    	vTemp_c[dir1] : vTemp_c[dir1]
             +calcInnerProdList(varsP, 1, bP, (dxvl[vid[dir2]]/2*varsV[dir2] + wl[vid[dir2]])*subst(a0=NC*(tvi),tvComp_e)))
  ),
  printf(fh, "~%"),

  /* Expand in phase basis. */
  v_x_e : doExpandLst(vTemp_c[1], bP),
  v_y_e : doExpandLst(vTemp_c[1], bP),
  v_z_e : doExpandLst(vTemp_c[1], bP),

  /* Calculate v^i : v^x = gxx*v_x + gxy*v_y + gxz*v_z, ... */
  vx_c : calcInnerProdList(varsP, 1, bP, (gxx_e*v_x_e + gxy_e*v_y_e + gxz_e*v_z_e)),
  vy_c : calcInnerProdList(varsP, 1, bP, (gxy_e*v_x_e + gyy_e*v_y_e + gyz_e*v_z_e)),
  vz_c : calcInnerProdList(varsP, 1, bP, (gxz_e*v_x_e + gyz_e*v_y_e + gzz_e*v_z_e)),

  /* Generate surface basis. this produces the ndim-1 orthogonal basis with no vv dependence. */
  bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsP,1,bP,subst([cv^2=var2,var2=1/3,cv=0],bP)))*bP),

  fL_e : doExpand1(fl, bP),
  fR_e : doExpand1(fr, bP),
  jacGeo_e : doExpand1(jacobGeo, bC),
  vComp_e : doExpandLst(vc[dir], bP),
  
  /* Ghat is the projection of fL onto the surface basis (if v>0)
     or the projection of fR onto the surface basis (if v<0) */
  printf(fh, "  double Ghat[~a]; ~%", length(bSurf)),
  /* alpha is the phase space flux at the surface. */
  printf(fh, "  double alpha[~a]; ~%", length(bSurf)),
  printf(fh, "~%"),

  /* Project alpha_v onto surface basis, and print resulting coefficients. */
  alpha_c : calcInnerProdList(surfVars, 1, bSurf, subst(cv=1, vComp_e*jacGeo_e)), /* Do I need a subst() here? */
  writeCExprsCollect1lhsc(alpha, radcan(alpha_c)),
  printf(fh, "~%"),
  flush_output(fh),
  /* Zero out components of alpha which are empty. */
  alphaNoZero : doMakeExprLst(alpha_c, alpha),
  alpha_e     : doExpandLst(alphaNoZero, bSurf),

  printf(fh, "  if (~a>0) { ~%",wvr),

  Ghat_c : calcInnerProdList(surfVars, alpha_e, bSurf, subst(cv=1, fL_e)), /* Multiplication by vComp*jacGeo occurs here. */
  clst   : [wvl, dvl],
  writeCExprsCollect1(Ghat, Ghat_c, clst),
  printf(fh, "~%"),
  Ghat_c : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpandLst(Ghat_c, bSurf),
  flush_output(fh),

  incr_r : calcInnerProdList(surfVars, 1, subst(cv=-1, bP), Ghat_e),

  writeCIncrExprs1(outr, incr_r*rdxr2),
  printf(fh, "~%"),
  
  incr_l : calcInnerProdList(surfVars, -1, subst(cv=1, bP), Ghat_e),

  /* Left contribution is the same as the right contribution up to sign changes.
     Can exploit this fact that reduce the number of multiplications. */
  signs    : fullratsimp(incr_l/incr_r),
  incr_new : makelist(signs[i]*incr_r[i], i, 1, length(bP)),
  writeCIncrExprs1(outl, rdxl2*incr_new),

  printf(fh, "  } else { ~%"),
  
  Ghat_c : calcInnerProdList(surfVars, subst(cv=1, alpha_e), bSurf, subst(cv=-1, fR_e)),
  clst   : [wvr, dvr],
  writeCExprsCollect1(Ghat, Ghat_c, clst),
  printf(fh, "~%"),
  Ghat_c : doMakeExprLst(Ghat_c, Ghat),
  Ghat_e : doExpandLst(Ghat_c, bSurf),
  flush_output(fh),

  incr_r : calcInnerProdList(surfVars, 1, subst(cv=-1, bP), Ghat_e),

  clst   : [wvr, dvr],
  writeCIncrExprs1(outr, incr_r*rdxr2),
  printf(fh, "~%"),

  incr_l : calcInnerProdList(surfVars, -1, subst(cv=1, bP), Ghat_e),

  /* Left contribution is the same as the right contribution up to sign changes.
     Can exploit this fact that reduce the number of multiplications. */
  signs    : fullratsimp(incr_l/incr_r),
  incr_new : makelist(signs[i]*incr_r[i], i, 1, length(bP)),
  writeCIncrExprs1(outl, rdxl2*incr_new),
  
  printf(fh, "  } ~%"),
  printf(fh, "} ~%")
);

calcVlasovStreamSurfUpdater(fh, funcNm, cdim, vdim, basisFun, p) := block([dir],
  printf(fh, "#include <VlasovModDecl.h> ~%"),
  for dir : 1 thru cdim do ( calcStreamUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun, p) )
)$

