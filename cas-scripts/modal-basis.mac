/* Code to work with modal basis functions */

/* In the following "vars" is the list of independent variables */

/* Inner product of functions f1 and f2 with weight w */
innerProd(vars, w, f1, f2) := block([n, r],
    n : length(vars),
    r : integrate(w*f1*f2, vars[1], -1, 1),
    for i: 2 thru n do r : integrate(r, vars[i], -1, 1),
    return (r)
);

/* Norm of a function f */
norm(vars, f) := sqrt(innerProd(vars, 1, f, f));

/** Use Gram-Schmidt procedure to make a set of orthonormal basis set */
a(vars, i,j,u,phi) := -innerProd(vars,1,u[i],phi[j]);
gsOrthoNorm(vars, u) := block([nbasis, phi, v],
  nbasis : length(u),
  phi : (phi : [u[1]/norm(vars, u[1])], for i from 2 thru nbasis
          do (v : u[i] + sum( a(vars,i,j,u,phi)*phi[j], j, 1, i-1 ),
              phi : endcons(v/norm(vars,v), phi)),
          phi)
);

listifyListOfSets(los) := block([b],
   b : [],
   for pl in los do (for p in pl do b : append(b,[p])),
   return(b)
);

makeMaxOrderPermutationList(nvar,pmax) := block([pl],
   pl : [],
   for i from 1 thru pmax
     do (pl : append(pl, map(permutations, listify(integer_partitions(i,nvar))))),
   return (listifyListOfSets(pl))
);

makeTensorPermutationList(nvar,pmax) := sublist(
   makeMaxOrderPermutationList(nvar,nvar*pmax),
   lambda ([p], apply(max,p)<=pmax)
);

d2sum(lst) := lsum(i,i,sublist(lst, lambda([x], x>1)));
makeSerendipPermutationList(nvar,pmax) := sublist(
   makeTensorPermutationList(nvar,pmax),
   lambda ([p], d2sum(p) <= pmax)
);

calcPowers(var, pl) := product(var[i]^pl[i], i, 1, length(var));
makeBasis(var, permList) := cons(1,map(lambda ([p],calcPowers(var,p)), permList));

/* Make maximum order basis set */
makeMaxOrderBasis(var,n) := makeBasis(reverse(var),makeMaxOrderPermutationList(length(var),n));

/* Make tensor-product order basis set */
makeTensorBasis(var,n) := makeBasis(reverse(var),makeTensorPermutationList(length(var),n));

/* Make serendipity order basis set */
makeSerendipBasis(var,n) := makeBasis(reverse(var),makeSerendipPermutationList(length(var),n));

/* Compute mass matrix, i.e M_ij = <w phi_i phi_j> */
calcMassMatrix(vars, w, basis) := block([n, mass],
                n : length(basis),
		mass : (mass : zeromatrix(n,n), for i from 1 thru n
		         do (for j from 1 thru n
			   do (mass[i,j] : innerProd(vars, w, basis[i], basis[j]))),
			   mass),
	        return (mass)
);

/** Function to compute grad-stiffness matrix */
calcGradStiffMatrix(v, vars, basis) := block([n, stiff],
                n : length(basis),
		stiff : (stiff : zeromatrix(n,n), for i from 1 thru n
		          do (for j from 1 thru n
			    do (stiff[i,j] : innerProd(vars, 1, diff(basis[i],v), basis[j])
                               )),
	                  stiff),
	        return (stiff)
);

/** Function to compute stiffness matrix */
calcStiffMatrix(v, vars, basis) := block([n, stiff],
                n : length(basis),
		stiff : (stiff : zeromatrix(n,n), for i from 1 thru n
		          do (for j from 1 thru n
			    do (stiff[i,j] : innerProd(vars, 1, diff(basis[i],v), diff(basis[j],v))
                               )),
	                  stiff),
	        return (stiff)
);