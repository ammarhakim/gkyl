/* Code to work with modal basis functions */

/* In the following "vars" is the list of independent variables */

/** Return a small matrix only retaining 'cols' columns */
shaveCols(Abig, cols) := block([nx,ny,nc,Asmall],
		[nx,ny] : matrix_size(Abig),
		nc : length(cols),
		Asmall : (Asmall : matrix([]), for i from 1 thru nc
		           do (Asmall : addcol(Asmall, col(Abig, cols[i]))),
			  Asmall),
	        return (Asmall)
);

/* Inner product of functions f1 and f2 with weight w */
innerProd(vars, w, f1, f2) := block([n, r],
    n : length(vars),
    r : integrate(w*f1*f2, vars[1], -1, 1),
    for i: 2 thru n do r : integrate(r, vars[i], -1, 1),
    return (r)
)$

/* Norm of a function f */
norm(vars, f) := sqrt(innerProd(vars, 1, f, f))$

/** Use Gram-Schmidt procedure to make a set of orthonormal basis set */
a(vars, i,j,u,phi) := -innerProd(vars,1,u[i],phi[j])$
gsOrthoNorm(vars, u) := block([nbasis, phi, v],
  nbasis : length(u),
  phi : (phi : [u[1]/norm(vars, u[1])], for i from 2 thru nbasis
          do (v : u[i] + sum( a(vars,i,j,u,phi)*phi[j], j, 1, i-1 ),
              phi : endcons(v/norm(vars,v), phi)),
          phi)
)$

listifyListOfSets(los) := block([b],
   b : [],
   for pl in los do (for p in pl do b : append(b,[p])),
   return(b)
)$

makeMaxOrderPermutationList(nvar,pmax) := block([pl],
   pl : [],
   for i from 1 thru pmax
     do (pl : append(pl, map(permutations, listify(integer_partitions(i,nvar))))),
   return (listifyListOfSets(pl))
)$

makeTensorPermutationList(nvar,pmax) := sublist(
   makeMaxOrderPermutationList(nvar,nvar*pmax),
   lambda ([p], apply(max,p)<=pmax)
)$

d2sum(lst) := lsum(i,i,sublist(lst, lambda([x], x>1)))$
makeSerendipPermutationList(nvar,pmax) := sublist(
   makeTensorPermutationList(nvar,pmax),
   lambda ([p], d2sum(p) <= pmax)
)$

calcPowers(var, pl) := product(var[i]^pl[i], i, 1, length(var))$
makeBasis(var, permList) := cons(1,map(lambda ([p],calcPowers(var,p)), permList))$

/* Make maximum order basis set */
makeMaxOrderBasis(var,n) := makeBasis(reverse(var),makeMaxOrderPermutationList(length(var),n))$

/* Make tensor-product order basis set */
makeTensorBasis(var,n) := makeBasis(reverse(var),makeTensorPermutationList(length(var),n))$

/* Make serendipity order basis set */
makeSerendipBasis(var,n) := makeBasis(reverse(var),makeSerendipPermutationList(length(var),n))$

/* Count number of non-zero entries in matrix */
numNonZero(mat) := block([nc,nr,nz],
  [nr,nc] : matrix_size(mat),
  nz : 0,
  for i : 1 thru nr do (nz : nz+lsum( if x = 0 then 0 else 1, x, mat[i])),
  return (nz)
)$

/* Compute mass matrix, i.e M_ij = <w phi_i phi_j> */
calcMassMatrix(vars, w, basis) := block([n, mass],
                n : length(basis),
		mass : (mass : zeromatrix(n,n), for i from 1 thru n
		         do (for j from 1 thru n
			   do (mass[i,j] : innerProd(vars, w, basis[i], basis[j]))),
			   mass),
	        return (mass)
)$

calcWeightedGradStiffMatrix(v, vars, w, basis) := block([n, stiff],
                n : length(basis),
		stiff : (stiff : zeromatrix(n,n), for i from 1 thru n
		          do (for j from 1 thru n
			    do (stiff[i,j] : innerProd(vars, w, diff(basis[i],v), basis[j])
                               )),
	                  stiff),
	        return (stiff)
)$


/** Function to compute grad-stiffness matrix */
calcGradStiffMatrix(v, vars, basis) := calcWeightedGradStiffMatrix(v, vars, 1, basis)$

/** Function to compute (part of) stiffness matrix */
calcStiffMatrix(v, vars, basis) := block([n, stiff],
                n : length(basis),
		stiff : (stiff : zeromatrix(n,n), for i from 1 thru n
		          do (for j from 1 thru n
			    do (stiff[i,j] : innerProd(vars, 1, diff(basis[i],v), diff(basis[j],v))
                               )),
	                  stiff),
	        return (stiff)
)$

/* Canonical PB in 2D */
PB(f,g) := diff(f,x)*diff(g,y) - diff(f,y)*diff(g,x);
/* Compute mass matrix, i.e M_ij = <w phi_i phi_j> */
calcPbMatrix(basis) := block([n, mass],
                n : length(basis),
		mass : (mass : zeromatrix(n,n), for i from 1 thru n
		         do (for j from 1 thru n
			   do (mass[i,j] : PB(basis[i], basis[j]))),
			   mass),
	        return (mass)
)$