load(stringproc)$
load("modal-basis")$
simpsum : true$

basis : ["Ser", "Max"]$
for bIdx : 1 thru length(basis) do (
  for xIdx : 1 thru 1 do (
    for vIdx : 1 thru 1 do (
      /* Prepare the CPP file */
      fname : sconcat("~/max-out/lagrangeFix", basis[bIdx], xIdx, "x", vIdx, "v.cpp"),
      fh : openw(fname),
      printf(fh, "#include <math.h> ~%"),
      printf(fh, "#include <lagrangeFixDecl.h> ~%"),
      printf(fh, "~%"),

      kill(varsC, varsP, basisC, basisP),
      load(sconcat("basis-precalc/basis", basis[bIdx], xIdx, "x", vIdx, "v")),
      varsV : makelist(varsP[i], i, length(varsC)+1, length(varsP)),
      for polyOrder : 1 thru 1 do (
        /* Load basis and expand the new distribution function g */
        bc : basisC[polyOrder],
        bp : basisP[polyOrder],
        gExp : doExpand(g, bp),
        
        /* Get expansion coefficiens of the moments in terms of g */
        m0 : dv/2 * calcInnerProdList(varsC, 1, bc, integrate(gExp, vx, -1,1)),
        m1 : dv/2 * calcInnerProdList(varsC, 1, bc, integrate((dv/2*vx + vc[j])*gExp, vx, -1,1)),
        m2 : dv/2 * calcInnerProdList(varsC, 1, bc, integrate((dv/2*vx + vc[j])^2*gExp, vx, -1,1)),
        
        /* Taking a derivatives with respect to the expansion
        coefficients simpliefies to kronecker deltas */
        gDerk : makelist(g[i]=kron_delta(i, k), i, 1, length(bp)),
        m0Der : subst(gDerk, m0),
        m1Der : subst(gDerk, m1),
        m2Der : subst(gDerk, m2),
        
        /* RHS is obtained by taking derivatices of the "Lagrange
        multiplier terms" */
        lambda0k : makelist(lambda0[i], i, 1, length(bc)),
        lambda1k : makelist(lambda1[i], i, 1, length(bc)),
        lambda2k : makelist(lambda2[i], i, 1, length(bc)),
        RHS : m0Der.lambda0k + m1Der.lambda1k + m2Der.lambda2k,
        /* The system of equations is solved by adding the k expansion
        coefficient equations to get the difference in moments on the
        LHS; therefore, it is advantageous to set the following
        'g[i]=...' substitution because then we can use the previously
        defined formulas for m0, m1, and m2. We do no claim the g[i]
        really equals subst(k=i, RHS). */
        RHSk : makelist(g[i]=subst(k=i, RHS), i, 1, length(bp)),
        eq0 : makelist(dm0s[i]=sum(subst(RHSk, m0[i]), j, 1, Nv), i, 1, length(bc)),
        eq1 : makelist(dm1s[i]=sum(subst(RHSk, m1[i]), j, 1, Nv), i, 1, length(bc)),
        eq2 : makelist(dm2s[i]=sum(subst(RHSk, m2[i]), j, 1, Nv), i, 1, length(bc)),
        eqns : fullratsimp(subst(vc[j]=-Nv/2*dv+(j-1/2)*dv, append(eq0, eq1, eq2))),
        sol : linsolve(eqns, append(lambda0k, lambda1k, lambda2k)),
        
        /* The solution of the system gives the lagrange multipliers;
        they need to be then substituted to the RHS in order to get
        the corrections of the distribution function, i.e., get g out
        of f */
        deltaF : subst(sol, RHS),
        deltaFk : subst(dv=L/Nv, makelist(subst(k=i, deltaF), i, 1, length(bp))),
        expr : float(fullratsimp(subst(vc[j]=vc, deltaFk))),

        printf(fh, "void lagrangeFix~a~ax~av~ap(const double *dm0, const double *dm1, const double*dm2, double *f, const double vc, const double L, const double Nv) {~%", basis[bIdx], xIdx, vIdx, polyOrder),
        printf(fh, "  double *dm0s = dm0 - 1;~%"),
        printf(fh, "  double *dm1s = dm1 - 1;~%"),
        printf(fh, "  double *dm2s = dm2 - 1;~%"),  
        for i : 1 thru length(bp) do (
          printf(fh, "  f[~a] = f[~a] +  ~a;~%", i-1, i-1, expr[i])
        ),
        printf(fh, "}~%")
      ),
      close(fh)
    )
  )
);