/** Perfectly-Hyperbolic Maxwell equations. Eigensystem and other stuff */

assume(c>0);
assume(chi>0);
assume(gamma>0);

VL : [ExL, EyL, EzL, BxL, ByL, BzL, phiL, psiL]$
VR : [ExR, EyR, EzR, BxR, ByR, BzR, phiR, psiR]$

/* Compute upwinded flux */
calcNumFlux(V, flx) := block([Aij, A, vals, vects, Rev, Lev, Evs, vlSub, vrSub],
  A : genmatrix(lambda ([i,j], diff(flx[i],V[j])), 8, 8),

  [vals, vects] : eigenvectors(A),
  Rev : (Rev : matrix([]), for i from 1 thru length(vals[1])
          do (for j from 1 thru vals[2][i]
	    do (Rev : addcol(Rev, transpose(matrix(vects[i][j]))))), Rev),
  Lev : invert (Rev),
  Evs : (Evs : [], for i from 1 thru length(vals[1])
          do (for j from 1 thru vals[2][i]
            do (Evs : append(Evs, [vals[1][i]]))), Evs),

  vlSub : makelist(V[i]=VL[i], i, 1, 8),
  vrSub : makelist(V[i]=VR[i], i, 1, 8),

   W : Lev . V,
   Wup : transpose(makelist(if Evs[i] > 0 then subst(vlSub, W[i][1]) else subst(vrSub, W[i][1]), i, 1, 8)),
   Vup : fullratsimp(Rev . Wup),
   return (A.Vup)
)$

flux(Ex,Ey,Ez,Bx,By,Bz,phi,psi) := [c^2*chi*phi, c^2*Bz, -c^2*By, gamma*psi, -Ez, Ey, Ex*chi, Bx*c^2*gamma]$

valPlus(x) := if x>0 then 1 else (if x=0 then 1/2 else 0);
valMinus(x) := if x<0 then 1 else (if x=0 then 1/2 else 0);

Apdq(R,L,EVS,dq) := sum(valPlus(EVS[i])*col(R,i)*row(L,i).dq, i, 1, 8)$
Amdq(R,L,EVS,dq) := sum(valMinus(EVS[i])*col(R,i)*row(L,i).dq, i, 1, 8)$

/* Compute upwinded flux */
calcNumFlux(V, flx) := block([Aij, A, vals, vects, Rev, Lev, Evs, vlSub, vrSub],
  A : genmatrix(lambda ([i,j], diff(flx[i],V[j])), 8, 8),

  [vals, vects] : eigenvectors(A),
  Rev : (Rev : matrix([]), for i from 1 thru length(vals[1])
          do (for j from 1 thru vals[2][i]
	    do (Rev : addcol(Rev, transpose(matrix(vects[i][j]))))), Rev),
  Lev : invert (Rev),
  Evs : (Evs : [], for i from 1 thru length(vals[1])
          do (for j from 1 thru vals[2][i]
            do (Evs : append(Evs, [vals[1][i]]))), Evs),

  df : transpose(flux(VR[1]-VL[1],VR[2]-VL[2],VR[3]-VL[3],VR[4]-VL[4],VR[5]-VL[5],VR[6]-VL[6],VR[7]-VL[7],VR[8]-VL[8])),

  apdq_I : Apdq(Rev,Lev,Evs,df),
  amdq_I : Amdq(Rev,Lev,Evs,df),
 
  fCent : transpose(flux(VR[1]+VL[1],VR[2]+VL[2],VR[3]+VL[3],VR[4]+VL[4],VR[5]+VL[5],VR[6]+VL[6],VR[7]+VL[7],VR[8]+VL[8])),
  return (1/2*fCent - 1/2*(apdq_I-amdq_I))
)$