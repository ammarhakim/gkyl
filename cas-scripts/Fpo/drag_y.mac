kill(all) $
load("modal-basis") $
assume(dx>0, dy>0) $

polyOrder : 1 $
N : polyOrder + 1 $
load("basis-precalc/basisSer1x") $
basis1D : subst(x=y, basisC[polyOrder]) $
load("basis-precalc/basisSer2x") $
basis2D : basisC[polyOrder] $

eta(xc, yc, dx, dy, basis) := subst([wx=x, wy=y], subst([x=(wx-xc)/(dx/2), y=(wy-yc)/(dy/2)] , basis)) $
dx : 2 $
dy : 2 $
baC2D : eta(0, 0, dx, dy, basis2D) $
baC1D : eta(0, 0, dx, dy, basis1D) $
baT1D : eta(0, dy/2, dx, dy, basis1D) $
baB1D : eta(0, -dy/2, dx, dy, basis1D) $

/* 1-step 2-cell 1D recovery */
rExp : doExpand(r, makelist(y^i, i, 0, 2*N-1)) $
recEqList : append(
  calcInnerProdListGen([y], [[-dy,0]], 1, baB1D, rExp-doExpand(q1B, baB1D)),
  calcInnerProdListGen([y], [[0,dy]], 1, baT1D, rExp-doExpand(q1T, baT1D))
) $
rSol : linsolve(recEqList, makelist(r[i], i, 1, 2*N)) $
rSub : fullratsimp(subst(rSol, rExp)) $

/* 2-step 3-cell 1D recovery */
qTSubList : makelist(q1B[i]=q1C[i], i, 1, length(basis1D)) $
qBSubList : makelist(q1T[i]=q1C[i], i, 1, length(basis1D)) $
rrExp : doExpand(rr, makelist(y^i, i, 0, (N-1)+2)) $
recEqList : append(
  [subst(y=0, subst(qTSubList, rSub))-subst(y=dy/2, rrExp)],
  [subst(y=0, subst(qBSubList, rSub))-subst(y=-dy/2, rrExp)],
  calcInnerProdListGen([y], [[-dy/2,dy/2]], 1, baC1D, rrExp-doExpand(q1C, baC1D))
) $
rrSol : linsolve(recEqList, makelist(rr[i], i, 1, N+2)) $
rrSub : fullratsimp(subst(rrSol, rrExp)) $

/* Creating substitution lists to get the y-dependance */
projCoeff : calcInnerProdList([y], 1, basis1D, doExpand(q2, basis2D)) $
q1TProj : subst(makelist(q2[i]=q2T[i], i, 1, length(basis2D)), projCoeff) $
q1CProj : subst(makelist(q2[i]=q2C[i], i, 1, length(basis2D)), projCoeff) $
q1BProj : subst(makelist(q2[i]=q2B[i], i, 1, length(basis2D)), projCoeff) $
projSubList : append (
  makelist(q1T[i]=q1TProj[i], i, 1, N),
  makelist(q1C[i]=q1CProj[i], i, 1, N),
  makelist(q1B[i]=q1BProj[i], i, 1, N)
) $
r2Sub : subst(projSubList, rSub) $
rr2Sub : subst(projSubList, rrSub) $

/* h and g substitions for q */
hTSubList : append(
  makelist(q2T[i]=hTPtr[i], i, 1, length(basis2D)),
  makelist(q2B[i]=hPtr[i], i, 1, length(basis2D))
) $
hCSubList : append(
  makelist(q2T[i]=hTPtr[i], i, 1, length(basis2D)),
  makelist(q2C[i]=hPtr[i], i, 1, length(basis2D)),
  makelist(q2B[i]=hBPtr[i], i, 1, length(basis2D))
) $
hBSubList : append(
  makelist(q2T[i]=hPtr[i], i, 1, length(basis2D)),
  makelist(q2B[i]=hBPtr[i], i, 1, length(basis2D))
) $
fTSubList : append(
  makelist(q2T[i]=fTPtr[i], i, 1, length(basis2D)),
  makelist(q2B[i]=fPtr[i], i, 1, length(basis2D))
) $
fBSubList : append(
  makelist(q2T[i]=fPtr[i], i, 1, length(basis2D)),
  makelist(q2B[i]=fBPtr[i], i, 1, length(basis2D))
) $

/* Putting together the surface terms and integration over y */
surfT : calcInnerProdListGen([x], [[-dx/2, dx/2]], 1, subst(y=dy/2, baC2D),
  subst(y=0, diff(subst(hTSubList, r2Sub), y)*subst(fTSubList, r2Sub))*2/dx) $
surfB : calcInnerProdListGen([x], [[-dx/2, dx/2]], 1, subst(y=-dy/2, baC2D),
  subst(y=0, diff(subst(hBSubList, r2Sub), y)*subst(fBSubList, r2Sub))*2/dx) $

/* Writting surface terms */
fh : openw("~/max-out/drag_y")$
printf(fh, "if isTopEdge then~%") $
gs : float(expand(-surfB)) $
for i : 1 thru length(basis2D) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fOutPtr[i] - dt*gs[i]) $
printf(fh, "elseif isBotEdge then~%") $
gs : float(expand(surfT)) $
for i : 1 thru length(basis2D) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fOutPtr[i] - dt*gs[i]) $
printf(fh, "else~%") $
gs : float(expand(surfT-surfB)) $
for i : 1 thru length(basis2D) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fOutPtr[i] - dt*gs[i]) $
printf(fh, "end~%~%") $

/* Putting together the volume term */
vol : calcInnerProdListGen([x,y], [[-dx/2, dx/2], [-dy/2, dy/2]], 1, diff(baC2D, y),
  diff(subst(hCSubList, rr2Sub), y)*doExpand(fPtr, baC2D)*4/(dx*dy)) $
/* vol : calcInnerProdListGen([x,y], [[-dx/2, dx/2], [-dy/2, dy/2]], 1, diff(baC2D, y), */
/*   diff(doExpand(hPtr, baC2D), y)*doExpand(fPtr, baC2D)*4/(dx*dy)) $ */

/* Writting the volume term */
gs : float(expand(vol)) $
for i : 1 thru length(basis2D) do printf(fh, "fOutPtr[~a] = ~a~%", i, fOutPtr[i] + dt*gs[i]) $

close(fh) $