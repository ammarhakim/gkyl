kill(all) $
load("modal-basis") $
load("recovery-calc/recovery") $
assume(dv[0]>0, dv[1]>0, dv[2]>0) $
numDims : 2 $

eta(xc, yc, basis) := subst([wx=x, wy=y], subst([x=(wx-xc), y=(wy-yc)] , basis)) $

for polyOrder : 1 thru 2 do (
  load("basis-precalc/basisSer1x"),
  basis1D : basisC[polyOrder],
  load("basis-precalc/basisSer2x"),
  basis2D : basisC[polyOrder],
  
  recx2Cell : getRecov2Cell(x, polyOrder, numDims, qL, qR),
  recx3Cell : getRecov3Cell(x, polyOrder, numDims, 0, qL, qC, qR),
  
  /* h and g substitions for q; accounting for C 0-indexes */
  gLSubList : append(
    makelist(qL[i]=gL[i-1], i, 1, length(basis2D)),
    makelist(qR[i]=g[i-1], i, 1, length(basis2D))
    ),
  gCSubList : append(
    makelist(qL[i]=gL[i-1], i, 1, length(basis2D)),
    makelist(qC[i]=g[i-1], i, 1, length(basis2D)),
    makelist(qR[i]=gR[i-1], i, 1, length(basis2D))
    ),
  gRSubList : append(
    makelist(qL[i]=g[i-1], i, 1, length(basis2D)),
    makelist(qR[i]=gR[i-1], i, 1, length(basis2D))
    ),
  fLSubList : append(
    makelist(qL[i]=fL[i-1], i, 1, length(basis2D)),
    makelist(qR[i]=f[i-1], i, 1, length(basis2D))
    ),
  fRSubList : append(
    makelist(qL[i]=f[i-1], i, 1, length(basis2D)),
    makelist(qR[i]=fR[i-1], i, 1, length(basis2D))
    ),
  
  /* Putting together the surface terms and integration over y */
  J : (2/dv[0])^4,
  baC2D : eta(0, 0, basis2D),
  surfLa : calcInnerProdListGen([y], [[-1, 1]], 1, subst(x=-1, baC2D),
    subst(x=0, diff(diff(diff(subst(gLSubList, recx2Cell), x), x)*subst(fLSubList, recx2Cell), x))) * J,
  surfLb : calcInnerProdListGen([y], [[-1, 1]], 1, subst(x=-1, diff(baC2D, x)),
    subst(x=0, diff(diff(subst(gLSubList, recx2Cell), x), x)*subst(fLSubList, recx2Cell))) * J,
  
  surfRa : calcInnerProdListGen([y], [[-1, 1]], 1, subst(x=1, baC2D),
    subst(x=0, diff(diff(diff(subst(gRSubList, recx2Cell), x), x)*subst(fRSubList, recx2Cell), x))) * J,
  surfRb : calcInnerProdListGen([y], [[-1, 1]], 1, subst(x=1, diff(baC2D, x)),
    subst(x=0, diff(diff(subst(gRSubList, recx2Cell), x), x)*subst(fRSubList, recx2Cell))) * J,

  /* Putting together the volume term */
  vol : calcInnerProdListGen([x,y], [[-1, 1], [-1, 1]], 1, diff(diff(baC2D, x), x),
    diff(diff(subst(gCSubList, recx3Cell), x), x)*doExpand1(f, baC2D)) * J,
  
  /* Writting surface terms */
  fname : sconcat("~/max-out/fpoDiffKernelP", polyOrder, ".cpp"),
  fh : openw(fname),
  printf(fh, "#include <math.h>~%"),
  printf(fh, "#include <fpoKernelsDecl.h>~%~%"),

  printf(fh, "void fpoDiffKernelP~a(const double dt, const double *dv, const double *f, const double *fL, const double *fR, const double *fT, const double *fB, const double *g, const double *gL, const double *gR, const double *gT, const double *gB, const int isTopEdge, const int isBotEdge, const int isLeftEdge, const int isRightEdge, double *fOut) {~%", polyOrder),

  printf(fh, "  if (isLeftEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp((surfRa-surfRb)/2))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "  } else if (isRightEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp((-surfLa+surfLb)/2))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "  } else {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp((surfRa-surfRb-surfLa+surfLb)/2))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "  }~%~%"),
  
  /* Writting the volume term */
  gs : subst(gkyl_ipow, "^", float(fullratsimp(vol/2))),
  for i : 1 thru length(basis2D) do printf(fh, "  fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "~%"),
  
  recy2Cell : getRecov2Cell(y, polyOrder, numDims, qB, qT),
  recy3Cell : getRecov3Cell(y, polyOrder, numDims, 0, qB, qC, qT),
  
  /* g and f substitions for q; accounting for C 0-indexes */
  gBSubList : append(
    makelist(qB[i]=gB[i-1], i, 1, length(basis2D)),
    makelist(qT[i]=g[i-1], i, 1, length(basis2D))
    ),
  gCSubList : append(
    makelist(qB[i]=gB[i-1], i, 1, length(basis2D)),
    makelist(qC[i]=g[i-1], i, 1, length(basis2D)),
    makelist(qT[i]=gT[i-1], i, 1, length(basis2D))
    ),
  gTSubList : append(
    makelist(qB[i]=g[i-1], i, 1, length(basis2D)),
    makelist(qT[i]=gT[i-1], i, 1, length(basis2D))
    ),
  fBSubList : append(
    makelist(qB[i]=fB[i-1], i, 1, length(basis2D)),
    makelist(qT[i]=f[i-1], i, 1, length(basis2D))
    ),
  fTSubList : append(
    makelist(qB[i]=f[i-1], i, 1, length(basis2D)),
    makelist(qT[i]=fT[i-1], i, 1, length(basis2D))
    ),
  
  /* Putting together the surface terms and integration over x */
  J : (2/dv[1])^4, /* !!!! 0-indexed !!!! */
  baC2D : eta(0, 0, basis2D),
  surfBa : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=-1, baC2D),
    subst(y=0, diff(diff(diff(subst(gBSubList, recy2Cell), y), y)*subst(fBSubList, recy2Cell), y))) * J,
  surfBb : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=-1, diff(baC2D, y)),
    subst(y=0, diff(diff(subst(gBSubList, recy2Cell), y), y)*subst(fBSubList, recy2Cell))) * J,
  
  surfTa : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=1, baC2D),
    subst(y=0, diff(diff(diff(subst(gTSubList, recy2Cell), y), y)*subst(fTSubList, recy2Cell), y))) * J,
  surfTb : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=1, diff(baC2D, y)),
    subst(y=0, diff(diff(subst(gTSubList, recy2Cell), y), y)*subst(fTSubList, recy2Cell))) * J,

  /* Putting together the volume term */
  vol : calcInnerProdListGen([x,y], [[-1, 1], [-1, 1]], 1, diff(diff(baC2D, y), y),
    diff(diff(subst(gCSubList, recy3Cell), y), y)*doExpand1(f, baC2D)) * J,
  
  /* Writting surface terms */
  printf(fh, "  if (isBotEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp((surfTa-surfTb)/2))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "  } else if (isTopEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp((-surfBa+surfBb)/2))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "  } else {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp((surfTa-surfTb-surfBa+surfBb)/2))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "  }~%~%"),
  
  /* Writting the volume term */
  gs : subst(gkyl_ipow, "^", float(fullratsimp(vol/2))),
  for i : 1 thru length(basis2D) do printf(fh, "  fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  
  printf(fh, "}"),
  close(fh)
  )