kill(all) $
load("modal-basis") $
load("recovery-calc/recovery") $
assume(dv[0]>0, dv[1]>0, dv[2]>0) $
numDims : 2 $

for polyOrder : 1 thru 2 do (
  fname : sconcat("~/max-out/fpoDragKernelP", polyOrder, ".cpp"),
  fh : openw(fname),
  printf(fh, "#include <math.h>~%"),
  printf(fh, "#include <fpoKernelsDecl.h>~%~%"),

  printf(fh, "void fpoDragKernelP~a(const double dt, const double *dv, const double *f, const double *fL, const double *fR, const double *fT, const double *fB, const double *h, const double *hL, const double *hR, const double *hT, const double *hB, const int isTopEdge, const int isBotEdge, const int isLeftEdge, const int isRightEdge, double *fOut) {~%", polyOrder),
  load("basis-precalc/basisSer1x"),
  basis1D : basisC[polyOrder],
  load("basis-precalc/basisSer2x"),
  basis2D : basisC[polyOrder],
  basis2DL : eta([-1,0], [2,2], basis2D),
  basis2DR : eta([1,0], [2,2], basis2D),
  basis2DT : eta([0,1], [2,2], basis2D),
  basis2DB : eta([0,-1], [2,2], basis2D),
  
  xRecov : getRecov2CellGen(x, [2,2], polyOrder, qL, qR),
  /* h substitions for q; accounting for C 0-indexes */
  hLSubList : append(
    makelist(qL[i]=hL[i-1], i, 1, length(basis2D)),
    makelist(qR[i]=h[i-1], i, 1, length(basis2D))
    ),
  hRSubList : append(
    makelist(qL[i]=h[i-1], i, 1, length(basis2D)),
    makelist(qR[i]=hR[i-1], i, 1, length(basis2D))
    ),
  hxfLL : calcInnerProdListGen([x, y], [[-2,0], [-1,1]], 1, basis2DL,
    diff(subst(hLSubList, xRecov), x)*doExpand1(fL, basis2DL)),
  hxfLC : calcInnerProdListGen([x, y], [[0,2], [-1,1]], 1, basis2DR,
    diff(subst(hLSubList, xRecov), x)*doExpand1(f, basis2DR)),
  hxfRC : calcInnerProdListGen([x, y], [[-2,0], [-1,1]], 1, basis2DL,
    diff(subst(hRSubList, xRecov), x)*doExpand1(f, basis2DL)),
  hxfRR : calcInnerProdListGen([x, y], [[0,2], [-1,1]], 1, basis2DR,
    diff(subst(hRSubList, xRecov), x)*doExpand1(fR, basis2DR)),

  hxfLSubList : append(
    makelist(qL[i]=hxfLL[i], i, 1, length(basis2D)),
    makelist(qR[i]=hxfLC[i], i, 1, length(basis2D))
    ),
  hxfRSubList : append(
    makelist(qL[i]=hxfRC[i], i, 1, length(basis2D)),
    makelist(qR[i]=hxfRR[i], i, 1, length(basis2D))
    ),
  
  /* Putting together the surface terms and integration over y */
  J : (2/dv[0])^2, /* !!!! 0-indexed !!!! */
  surfL : calcInnerProdListGen([y], [[-1, 1]], 1, subst(x=-1, basis2D),
    subst(x=0, subst(hxfLSubList, xRecov))) * J,
  surfR : calcInnerProdListGen([y], [[-1, 1]], 1, subst(x=1, basis2D),
    subst(x=0, subst(hxfRSubList, xRecov))) * J,
  
  /* Putting together the volume term */
  vol : calcInnerProdListGen([x,y], [[-1, 1], [-1, 1]], 1, diff(basis2D, x),
    diff(doExpand1(h, basis2D), x)*doExpand1(f, basis2D)) * J,
  
  printf(fh, "  if (isLeftEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp(surfR))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] = f[~a] + ~a;~%", i-1, i-1, -dt*gs[i]),
  printf(fh, "  } else if (isRightEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp(-surfL))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] = f[~a] + ~a;~%", i-1, i-1, -dt*gs[i]),
  printf(fh, "  } else {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp(surfR-surfL))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] = f[~a] + ~a;~%", i-1, i-1, -dt*gs[i]),
  printf(fh, "  }~%~%"),
  
  /* Writting the volume term */
  gs :  subst(gkyl_ipow, "^", float(fullratsimp(vol))),
  for i : 1 thru length(basis2D) do printf(fh, "  fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  printf(fh, "~%"),

  yRecov : getRecov2CellGen(y, [2,2], polyOrder, qB, qT),
  /* h substitions for q; accounting for C 0-indexes */
  hBSubList : append(
    makelist(qB[i]=hB[i-1], i, 1, length(basis2D)),
    makelist(qT[i]=h[i-1], i, 1, length(basis2D))
    ),
  hTSubList : append(
    makelist(qB[i]=h[i-1], i, 1, length(basis2D)),
    makelist(qT[i]=hT[i-1], i, 1, length(basis2D))
    ),
  
  hyfBB : calcInnerProdListGen([x, y], [[-1,1], [-2,0]], 1, basis2DB,
    diff(subst(hBSubList, yRecov), y)*doExpand1(fB, basis2DB)),
  hyfBC : calcInnerProdListGen([x, y], [[-1,1], [0,2]], 1, basis2DT,
    diff(subst(hBSubList, yRecov), y)*doExpand1(f, basis2DT)),
  hyfTC : calcInnerProdListGen([x, y], [[-1,1], [-2,0]], 1, basis2DB,
    diff(subst(hTSubList, yRecov), y)*doExpand1(f, basis2DB)),
  hyfTT : calcInnerProdListGen([x, y], [[-1,1], [0,2]], 1, basis2DT,
    diff(subst(hTSubList, yRecov), y)*doExpand1(fT, basis2DT)),
  hyfBSubList : append(
    makelist(qB[i]=hyfBB[i], i, 1, length(basis2D)),
    makelist(qT[i]=hyfBC[i], i, 1, length(basis2D))
    ),
  hyfTSubList : append(
    makelist(qB[i]=hyfTC[i], i, 1, length(basis2D)),
    makelist(qT[i]=hyfTT[i], i, 1, length(basis2D))
    ),
  /* Putting together the surface terms and integration over y */
  J : (2/dv[1])^2, /* !!!! 0-indexed !!!! */
  surfB : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=-1, basis2D),
    subst(y=0, subst(hyfBSubList, yRecov))) * J,
  surfT : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=1, basis2D),
    subst(y=0, subst(hyfTSubList, yRecov))) * J,

  /* Putting together the volume term */
  vol : calcInnerProdListGen([x,y], [[-1, 1], [-1, 1]], 1, diff(basis2D, y),
    diff(doExpand1(h, basis2D), y)*doExpand1(f, basis2D)) * J,
  
  /* Writting surface terms */
  printf(fh, "  if (isBotEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp(surfT))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, -dt*gs[i]),
  printf(fh, "  } else if (isTopEdge) {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp(-surfB))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, -dt*gs[i]),
  printf(fh, "  } else {~%"),
  gs : subst(gkyl_ipow, "^", float(fullratsimp(surfT-surfB))),
  for i : 1 thru length(basis2D) do printf(fh, "    fOut[~a] += ~a;~%", i-1, -dt*gs[i]),
  printf(fh, "  }~%~%"),
  
  /* Writting the volume term */
  gs : subst(gkyl_ipow, "^", float(fullratsimp(vol))),
  for i : 1 thru length(basis2D) do printf(fh, "  fOut[~a] += ~a;~%", i-1, dt*gs[i]),
  
  printf(fh, "}"),
  close(fh)
  )