kill(all) $
load("modal-basis") $
load("recovery-calc/recovery") $
assume(dv[0]>0, dv[1]>0, dv[2]>0) $
numDims : 2 $

getPerpDir(dir) := block( /* Hard-coded; needs generalization for 3D */
  if dir = x then return(y) else return(x)
  ) $

fgConvolution(dir, der, polyOrder, fL, fU, gL, gU) := block(
  [gRec, gDer, ba, baL, baU, perpDir, outL, outU],
  gRec : getRecov2CellGen(dir, [2,2], polyOrder, gL, gU),
  gDer : diff(diff(gRec, der[1]), der[2]),
  
  ba : getBasis("basis-precalc/basisSer2x", polyOrder),
  baL : etaDir(dir, -1, 2, ba),
  baU : etaDir(dir, 1, 2, ba),
  
  perpDir : getPerpDir(dir),
  outL : calcInnerProdListGen([dir, perpDir], [[-2,0], [-1,1]], 1, baL, gDer*doExpand(fL, baL)),
  outU : calcInnerProdListGen([dir, perpDir], [[0,2], [-1,1]], 1, baU, gDer*doExpand(fU, baU)),
  return([outL, outU])
  ) $

getSurfTerm(fh, dir, edge, polyOrder,
  fLL, fLU, fCL, fCU, fUL, fUU,
  gLL, gLU, gCL, gCU, gUL, gUU) := block(
  [perpDir, edgeNm, ba,
  giifCL, giifCU, gijfLL, gijfLU, gijfCL, gijfCU, gijfUL, gijUU,
  rec2, rec6, giif, giifi, gijf, gijfj, Jii, Jij, t1, t2, t3, t4],
  perpDir : getPerpDir(dir),
  /*if edge = -1 then edgeNm : "L" else edgeNm : "U",*/
  ba : getBasis("basis-precalc/basisSer2x", polyOrder),
  
  [giifCL, giifCU] : fgConvolution(dir, [dir,dir], polyOrder, fCL, fCU, gCL, gCU),
  [gijfLL, gijfLU] : fgConvolution(dir, [dir,perpDir], polyOrder, fLL, fLU, gLL, gLU),
  [gijfCL, gijfCU] : fgConvolution(dir, [dir,perpDir], polyOrder, fCL, fCU, gCL, gCU),
  [gijfUL, gijfUU] : fgConvolution(dir, [dir,perpDir], polyOrder, fUL, fUU, gUL, gUU),

  rec2 : getRecov2CellGen(dir, [2,2], polyOrder, giifCL, giifCU),
  giif : subst(dir=0, rec2),
  giifi : subst(dir=0, diff(rec2, dir)),
  
  rec2 : getRecov2CellGen(dir, [2,2], polyOrder, gijfCL, gijfCU),
  gijf : subst(dir=0, rec2),
  
  rec6 : getRecov6CellGen(perpDir, [2,2], polyOrder, 0,
    gijfLL, gijfLU, gijfCL, gijfCU, gijfUL, gijfUU),
  gijfj : diff(rec6, perpDir),
  
  Jii : eval_string(sconcat("J", dir, dir)),
  Jij : eval_string(sconcat("J", dir, perpDir)),
  t1 : calcInnerProdListGen([perpDir], [[-1,1]], Jii, subst(dir=edge, ba), giifi),
  t2 : calcInnerProdListGen([perpDir], [[-1,1]], Jii, subst(dir=edge, diff(ba, dir)), giif),
  t3 : calcInnerProdListGen([perpDir], [[-1,1]], Jij, subst(dir=edge, ba), gijfj),
  t4 : calcInnerProdListGen([perpDir], [[-1,1]], Jij, subst(dir=edge, diff(ba, perpDir)), gijf),
  return(t1-t2+t3-t4)
  ) $

for polyOrder : 1 thru 1 do (
  fname : sconcat("~/max-out/fpoDiffKernelP", polyOrder, ".cpp"),
  fh : openw(fname),
  printf(fh, "#include <math.h>~%"),
  printf(fh, "#include <fpoKernelsDecl.h>~%~%"),

  printf(fh, "void fpoDiffKernelP~a(const double dt, const double *dv, const double *fTL, const double *fT, const double *fTR, const double *fL, const double *fC, const double *fR, const double *fBL, const double *fB, const double *fBR, const double *gTL, const double *gT, const double *gTR, const double *gL, const double *gC, const double *gR, const double *gBL, const double *gB, const double *gBR, const int isTopEdge, const int isBotEdge, const int isLeftEdge, const int isRightEdge, double *fOut) {~%", polyOrder),
  
  baC : getBasis("basis-precalc/basisSer2x", polyOrder),

  /* N : polyOrder + 3, */
  
  indexSubList : append(
    /* diff potential */
    makelist(gC[i]=gC[i-1], i, 1, length(baC)),
    makelist(gL[i]=gL[i-1], i, 1, length(baC)),
    makelist(gR[i]=gR[i-1], i, 1, length(baC)),
    makelist(gB[i]=gB[i-1], i, 1, length(baC)),
    makelist(gT[i]=gT[i-1], i, 1, length(baC)),
    makelist(gTL[i]=gTL[i-1], i, 1, length(baC)),
    makelist(gTR[i]=gTR[i-1], i, 1, length(baC)),
    makelist(gBL[i]=gBL[i-1], i, 1, length(baC)),
    makelist(gBR[i]=gBR[i-1], i, 1, length(baC)),
    /* distribution functions */
    makelist(fC[i]=fC[i-1], i, 1, length(baC)),
    makelist(fL[i]=fL[i-1], i, 1, length(baC)),
    makelist(fR[i]=fR[i-1], i, 1, length(baC)),
    makelist(fB[i]=fB[i-1], i, 1, length(baC)),
    makelist(fT[i]=fT[i-1], i, 1, length(baC)),
    makelist(fTL[i]=fTL[i-1], i, 1, length(baC)),
    makelist(fTR[i]=fTR[i-1], i, 1, length(baC)),
    makelist(fBL[i]=fBL[i-1], i, 1, length(baC)),
    makelist(fBR[i]=fBR[i-1], i, 1, length(baC))
    /* recoveries */
    ),
  
  printf(fh, "  double Jxx = 16/(dv[0]*dv[0]*dv[0]*dv[0]);~%"),
  printf(fh, "  double Jyy = 16/(dv[1]*dv[1]*dv[1]*dv[1]);~%"),
  printf(fh, "  double Jxy = 16/(dv[0]*dv[0]*dv[1]*dv[1]);~%"),
  printf(fh, "  double Jyx = Jxy;~%~%"),

  /* Putting together the volume terms */
  gxxfPhixxVol : calcInnerProdListGen([x,y], [[-1,1], [-1,1]], Jxx, diff(baC, x, 2),
    diff(doExpand(gC, baC), x, 2)*doExpand(fC, baC)),
  gyyfPhiyyVol : calcInnerProdListGen([x,y], [[-1,1], [-1,1]], Jyy, diff(baC, y, 2),
    diff(doExpand(gC, baC), y, 2)*doExpand(fC, baC)),
  gxyfPhixyVol : calcInnerProdListGen([x,y], [[-1,1], [-1,1]], Jxy, diff(diff(baC, x), y),
    diff(diff(doExpand(gC, baC), x), y)*doExpand(fC, baC)),
  
  surfT : getSurfTerm(fh, y, 1, polyOrder, fL, fTL, fC, fT, fR, fTR, gL, gTL, gC, gT, gR, gTR),
  surfB : getSurfTerm(fh, y, -1, polyOrder, fBL, fL, fB, fC, fBR, fR, gBL, gL, gB, gC, gBR, gR),
  surfL : getSurfTerm(fh, x, -1, polyOrder, fBL, fB, fL, fC, fTL, fT, gBL, gB, gL, gC, gTL, gT),
  surfR : getSurfTerm(fh, x, 1, polyOrder, fB, fBR, fC, fR, fT, fTR, gB, gBR, gC, gR, gT, gTR),

  /* printf(fh, "  if (isLeftEdge) {~%"), */
  /* tmp : (gxxfxPhiSurR-gxxfPhixSurR + gxyfyPhiSurR-gxyfPhiySurR)/2, */
  /* out : subst(indexSubList, subst(gkyl_ipow, "^", float(expand(fullratsimp(tmp))))), */
  /* for i : 1 thru length(baC) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*out[i]), */

  /* printf(fh, "  } else if (isRightEdge) {~%"), */
  /* tmp : (-gxxfxPhiSurL+gxxfPhixSurL - gxyfyPhiSurL+gxyfPhiySurL)/2, */
  /* out : subst(indexSubList, subst(gkyl_ipow, "^", float(expand(fullratsimp(tmp))))), */
  /* for i : 1 thru length(baC) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*out[i]), */

  /* printf(fh, "  } else {~%"), */
  tmp : (surfR - surfL + surfT - surfB)/2,
  out : subst(indexSubList, expand(float(fullratsimp(tmp)))),
  for i : 1 thru length(baC) do printf(fh, "  fOut[~a] += ~a;~%", i-1, dt*out[i]),
  /* printf(fh, "  }~%~%"), */

  /* printf(fh, "  if (isBotEdge) {~%"), */
  /* tmp : (gyyfyPhiSurT-gyyfPhiySurT + gyxfxPhiSurT-gyxfPhixSurT)/2, */
  /* out : subst(indexSubList, subst(gkyl_ipow, "^", float(expand(fullratsimp(tmp))))), */
  /* for i : 1 thru length(baC) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*out[i]), */

  /* printf(fh, "  } else if (isTopEdge) {~%"), */
  /* tmp : (-gyyfyPhiSurB+gyyfPhiySurB - gyxfxPhiSurB+gyxfPhixSurB)/2, */
  /* out : subst(indexSubList, subst(gkyl_ipow, "^", float(expand(fullratsimp(tmp))))), */
  /* for i : 1 thru length(baC) do printf(fh, "    fOut[~a] += ~a;~%", i-1, dt*out[i]), */
  
  /* printf(fh, "  } else {~%"), */
  /* tmp : ()/2, */
  /* out : subst(indexSubList, float(expand(fullratsimp(tmp)))), */
  /* for i : 1 thru length(baC) do printf(fh, "  fOut[~a] += ~a;~%", i-1, dt*out[i]), */
  /* printf(fh, "  }~%~%"), */
  
  /* Writting the volume term */
  tmp : (gxxfPhixxVol + gyyfPhiyyVol + 2*gxyfPhixyVol)/2,
  out : subst(indexSubList, expand(float(fullratsimp(tmp)))),
  for i : 1 thru length(baC) do printf(fh, "  fOut[~a] += ~a;~%", i-1, dt*out[i]),


  printf(fh, "}"),
  close(fh)
  )