kill(all) $
load("modal-basis") $

polyOrder : 2 $
N : polyOrder + 1 $
load("basis-precalc/basisSer1x") $
basis1D : subst(x=y, basisC[polyOrder]) $
load("basis-precalc/basisSer2x") $
basis2D : basisC[polyOrder] $

eta(xc, yc, basis) := subst([wx=x, wy=y], subst([x=(wx-xc), y=(wy-yc)] , basis)) $
baB1D : eta(0, -1, basis1D) $
baC1D : eta(0, 0, basis1D) $
baT1D : eta(0, 1, basis1D) $

/* 1-step 2-cell 1D recovery */
rExp : doExpand(r, makelist(y^i, i, 0, 2*N-1)) $
recEqList : append(
  calcInnerProdListGen([y], [[-2, 0]], 1, baB1D, rExp-doExpand(q1B, baB1D)),
  calcInnerProdListGen([y], [[0, 2]], 1, baT1D, rExp-doExpand(q1T, baT1D))
) $
rSol : linsolve(recEqList, makelist(r[i], i, 1, 2*N)) $
rSub : fullratsimp(subst(rSol, rExp)) $

/* 2-step 3-cell 1D recovery */
qBSubList : makelist(q1T[i]=q1C[i], i, 1, length(basis1D)) $
qTSubList : makelist(q1B[i]=q1C[i], i, 1, length(basis1D)) $
rrExp : doExpand(rr, makelist(y^i, i, 0, (N-1)+2)) $
recEqList : append(
  [subst(y=0, subst(qBSubList, rSub)) - subst(y=-1, rrExp)],
  [subst(y=0, subst(qTSubList, rSub)) - subst(y=1, rrExp)],
  calcInnerProdListGen([y], [[-1, 1]], 1, baC1D, rrExp-doExpand(q1C, baC1D))
) $
rrSol : linsolve(recEqList, makelist(rr[i], i, 1, N+2)) $
rrSub : fullratsimp(subst(rrSol, rrExp)) $

/* Creating substitution lists to get the y-dependence */
baB1D : eta(0, -1, basis1D) $
baB2D : eta(0, -1, basis2D) $
baT1D : eta(0, 1, basis1D) $
baT2D : eta(0, 1, basis2D) $
q1BProj : calcInnerProdListGen([y], [[-2, 0]], 1, baB1D, doExpand(q2B, baB2D)) $
q1TProj : calcInnerProdListGen([y], [[0, 2]], 1, baT1D, doExpand(q2T, baT2D)) $
projSubList : append (
  makelist(q1B[i]=q1BProj[i], i, 1, N),
  makelist(q1T[i]=q1TProj[i], i, 1, N)
) $
r2Sub : subst(projSubList, rSub) $

baB1D : eta(0, -2, basis1D) $
baB2D : eta(0, -2, basis2D) $
baC1D : eta(0, 0, basis1D) $
baC2D : eta(0, 0, basis2D) $
baT1D : eta(0, 2, basis1D) $
baT2D : eta(0, 2, basis2D) $
q1BProj : calcInnerProdListGen([y], [[-3, -1]], 1, baB1D, doExpand(q2B, baB2D)) $
q1CProj : calcInnerProdListGen([y], [[-1, 1]], 1, baC1D, doExpand(q2C, baC2D)) $
q1TProj : calcInnerProdListGen([y], [[1, 3]], 1, baT1D, doExpand(q2T, baT2D)) $
projSubList : append (
  makelist(q1B[i]=q1BProj[i], i, 1, N),
  makelist(q1C[i]=q1CProj[i], i, 1, N),
  makelist(q1T[i]=q1TProj[i], i, 1, N)
) $
rr2Sub : subst(projSubList, rrSub) $

/* g and f substitions for q */
gBSubList : append(
  makelist(q2B[i]=gBPtr[i], i, 1, length(basis2D)),
  makelist(q2T[i]=gPtr[i], i, 1, length(basis2D))
) $
gCSubList : append(
  makelist(q2B[i]=gBPtr[i], i, 1, length(basis2D)),
  makelist(q2C[i]=gPtr[i], i, 1, length(basis2D)),
  makelist(q2T[i]=gTPtr[i], i, 1, length(basis2D))
) $
gTSubList : append(
  makelist(q2B[i]=gPtr[i], i, 1, length(basis2D)),
  makelist(q2T[i]=gTPtr[i], i, 1, length(basis2D))
) $
fBSubList : append(
  makelist(q2B[i]=fBPtr[i], i, 1, length(basis2D)),
  makelist(q2T[i]=fPtr[i], i, 1, length(basis2D))
) $
fTSubList : append(
  makelist(q2B[i]=fPtr[i], i, 1, length(basis2D)),
  makelist(q2T[i]=fTPtr[i], i, 1, length(basis2D))
) $

/* Putting together the surface terms and integration over x */
J : (2/dy)^4 $
baC2D : eta(0, 0, basis2D) $
surfBa : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=-1, baC2D),
  subst(y=0, diff(diff(diff(subst(gBSubList, r2Sub), y), y)*subst(fBSubList, r2Sub), y))) * J $
surfBb : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=-1, diff(baC2D, y)),
  subst(y=0, diff(diff(subst(gBSubList, r2Sub), y), y)*subst(fBSubList, r2Sub))) * J $

surfTa : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=1, baC2D),
  subst(y=0, diff(diff(diff(subst(gTSubList, r2Sub), y), y)*subst(fTSubList, r2Sub), y))) * J $
surfTb : calcInnerProdListGen([x], [[-1, 1]], 1, subst(y=1, diff(baC2D, y)),
  subst(y=0, diff(diff(subst(gTSubList, r2Sub), y), y)*subst(fTSubList, r2Sub))) * J $

/* Writting surface terms */
fh : openw("~/max-out/diff_yy")$
printf(fh, "if isBotEdge then~%") $
gs : float(expand((surfTa-surfTb)/2)) $
for i : 1 thru length(basis2D) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fOutPtr[i] + dt*gs[i]) $
printf(fh, "elseif isTopEdge then~%") $
gs : float(expand((-surfBa+surfBb)/2)) $
for i : 1 thru length(basis2D) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fOutPtr[i] + dt*gs[i]) $
printf(fh, "else~%") $
gs : float(expand((surfTa-surfTb-surfBa+surfBb)/2)) $
for i : 1 thru length(basis2D) do printf(fh, "    fOutPtr[~a] = ~a~%", i, fOutPtr[i] + dt*gs[i]) $
printf(fh, "end~%~%") $

/* Putting together the volume term */
vol : calcInnerProdListGen([x,y], [[-1, 1], [-1, 1]], 1, diff(diff(baC2D, y), y),
    diff(diff(subst(gCSubList, rr2Sub), y), y)*doExpand(fPtr, baC2D)) * J $

/* Writting the volume term */
gs : float(expand(vol/2)) $
for i : 1 thru length(basis2D) do printf(fh, "fOutPtr[~a] = ~a~%", i, fOutPtr[i] + dt*gs[i]) $

close(fh) $