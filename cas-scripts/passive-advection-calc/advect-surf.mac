load("modal-basis")$
load("out-scripts")$
load(stringproc)$
load("positivity-calc/fhatAL-calc")$
load("scifac")$
fpprec : 24$

wc : [w1, w2, w3]$
derivfac : [dfac1, dfac2, dfac3]$

cvars : [X1, X2, X3]$

doMakeExprLst(vals, S) := makelist(if vals[i] # 0 then S[i-1] else 0, i, 1, length(vals))$
doExpandLst(lst, basis) := sum(lst[i]*basis[i], i, 1, length(basis))$

/* set up some vector calculus functions */
load("vect")$
fgrad(f):= ev(express(grad(f)),diff)*derivfacsC$

calcUpdateInDir(surfDir, fh, funcNm, cdim, basisFun, i) := block([],
kill(varsC, varsC, basisC, basisP),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x"),
load(modNm),
  bC : basisC[i],
  numC : length(bC),
  volfac : 1,
  /* get surface variable */
  surfVar : varsC[surfDir],
  /* remove surface variable from integrand of surface integrals */
  surfIntVars : delete(surfVar,varsC),
  dirlabel : cvars[surfDir],
  dfacSurf : derivfac[surfDir], 
  wSurf : wc[surfDir],

  /* remove volume contribution from surface variable, which is not integrated */
  surfac : fullratsimp(volfac*dfacSurf),

  print("Working on ", funcNm, "_", dirlabel, "_P", i),
  printf(fh, "double ~a_~a_P~a(const double *cflRateCtrlL, const double *cflRateCtrlR, const double *w, const double *dxv, const double dtApprox, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, dirlabel, i),
  printf(fh, "// w[NDIM]: Cell-center coordinates. dxv[NDIM]: Cell spacing. ~%"),

  for dir : 1 thru cdim do (
    printf(fh, "  double dfac~a = 2.0/dxv[~a]; ~%", dir, dir-1),
    printf(fh, "  double w~a = w[~a]; ~%", dir, dir-1)
  ),

  for dir : 1 thru cdim do (
    printf(fh, "  const double *v~a = &fr[~a]; ~%", dir, numC*(dir))
  ),
  flush_output(fh),

  printf(fh, "  double incr[~a]; ~%", length(bC)),
  flush_output(fh),

  /* expand distribution function on basis */
  fL_expd:doExpand1(fl,bC),
  fR_expd:doExpand1(fr,bC),
  v_expd:[],
  for dir : 1 thru cdim do (
    vd : verbify(sconcat("v",dir)),
    v_expd:append(v_expd, [doExpand1(vd,bC)])
  ),

  /* calculate phase space velocity alpha in direction of surfVar */
  /* we assume alpha.n is continuous across boundary */
  alpha_expd : v_expd[surfDir],
  /* calculate expression for surface-averaged alpha, and print to c variable alpha0 */
  alpha0expr : gcfac(fullratsimp(innerProd(surfIntVars, 1, subst(surfVar=-1,alpha_expd), subst(surfVar=-1, bC[1]))*bC[1])),
  printf(fh, "  // surface-averaged phase velocity in this direction ~%"),
  printf(fh, "  double alpha0 = ~a; ~%~%", float(alpha0expr)),
  flush_output(fh),

  /* generate surface basis */
  bSurf : sqrt(2)*delete(0,fullratsimp(innerProd(varsC,1,bC,subst([surfVar^2=var2,var2=1/3,surfVar=0],bC)))*bC),

  /* project full alpha expression evaluatated at interior surface onto surface basis and print to c variable alpha */
  printf(fh, "  double alpha[~a]; ~%", length(bSurf)),
  alpha_k : fullratsimp(innerProd(surfIntVars, 1, bSurf, subst(surfVar=-1,alpha_expd))),
  flush_output(fh),
  writeCExprsNoExpand1(alpha, subst([wv^2=wv2,dfac_v^2=dfac_v2, m_^2=m2, q_^2=q2],alpha_k)),
  alphaNoZero_k : doMakeExprLst(alpha_k, alpha),
  alphaSurf_expd : doExpandLst(alphaNoZero_k, bSurf),
  flush_output(fh),

  if (alphaSurf_expd = 0) then (
    printf(fh, "  // alpha == 0, so nothing to do ~%"),
    printf(fh, "  return std::abs(alpha0); ~%"),
    printf(fh, "} ~%"),
    flush_output(fh)
  )
  else (
    if positivity then ( 
      fhatSurf_expd : fhatALgenUpwindNoLim(fL_expd, 
              fR_expd, alphaSurf_expd, 
              surfVar, cflL, cflR, cdim, 0, i),

      Ghat_k : surfac*calcInnerProdList(surfIntVars, alphaSurf_expd, bSurf, fhatSurf_expd),
      Ghat_expd : Ghat_k.bSurf,
      cSurfNodes : eval_string(sconcat("nodes", cdim-1, "xp", p))/3,
      qSurfNodes : eval_string(sconcat("nodes", cdim-1, "xp", p))/sqrt(3),
      nodesub(f,nodes):=makelist(subst(makelist(surfIntVars[j]=nodes[i][j],j,1,length(surfIntVars)),f),i,1,length(nodes)),
      GhatC : nodesub(Ghat_expd, cSurfNodes), 
      printf(fh, "  double GhatCtrl[~a];~%", length(cSurfNodes)),
      for i:1 thru length(cSurfNodes) do (
        printf(fh, "  // control node ~a = ~a ~%", surfIntVars, cSurfNodes[i]), 
        printf(fh, "  GhatCtrl[~a] = ~a; ~%", i-1, gcfac(float(GhatC[i]))),
        printf(fh, "  if(std::abs(GhatCtrl[~a]) < EPSILON) GhatCtrl[~a] = 0.; ~%", i-1, i-1)
      ),
      modToNodC : calcModToNodPhaseWithNodesAndBasis(cSurfNodes, bSurf, surfIntVars),
      Ghat_k:fullratsimp(invert(transpose(modToNodC)).makelist(GhatCtrl[i-1],i,1,length(cSurfNodes))),
      Ghat_k:gcfac(makelist(Ghat_k[i][1],i,1,length(Ghat_k))),
      Ghat_expd : Ghat_k.bSurf,

      t : calcInnerProdList(surfIntVars, 1, subst(surfVar=-1, bC), Ghat_expd),
      incr_r : facsum(fullratsimp(t),dxv),
      t : calcInnerProdList(surfIntVars, 1, subst(surfVar=1, bC), Ghat_expd),
      incr_l : -t,

      cVolNodes : eval_string(sconcat("nodes", cdim, "xp", p))/3,
      nodesubVol(f,nodes):=makelist(subst(makelist(varsC[j]=nodes[i][j],j,1,length(varsC)),f),i,1,length(nodes)),
      incrC_r : gcfac(float(fullratsimp(nodesubVol(incr_r.bC, cVolNodes)))),
      incrC_l : gcfac(float(fullratsimp(nodesubVol(incr_l.bC, cVolNodes)))),
      printf(fh, "  double uFrac = 0., fCtrl = 0., alphaCtrl = 0.;~%"),
      for i:1 thru length(cVolNodes) do (
        GlimL : gcfac(float(nodesubVol(fL_expd, cVolNodes)[i])),
        GlimR : gcfac(float(nodesubVol(fR_expd, cVolNodes)[i])),
        if incrC_r[i]#0.0 then (
           printf(fh, "  if(~a<-EPSILON) {~%", incrC_r[i]),
           printf(fh, "    alphaCtrl = ~a; ~%", gcfac(float(nodesubVol(alphaSurf_expd, cVolNodes)[i]))),
           printf(fh, "    uFrac = ~a; ~%", gcfac(float(surfac*alphaCtrl/cflRateCtrlR[i-1]))),
           printf(fh, "    fCtrl = ~a; ~%", GlimR),
           printf(fh, "    if(std::abs(alphaCtrl)<EPSILON || std::abs(fCtrl)<EPSILON) ~a = 0.;~%", incrC_r[i]),
           printf(fh, "    else ~a = -std::min(std::abs(~a), std::abs(uFrac)*fCtrl/dtApprox);~%", incrC_r[i], incrC_r[i]),
           printf(fh, "  }~%")
        ),
        if incrC_l[i]#0.0 then (
           printf(fh, "  if(~a>EPSILON) {~%", fullratsimp(-incrC_l[i])),
           printf(fh, "    alphaCtrl = ~a; ~%", gcfac(float(nodesubVol(alphaSurf_expd, cVolNodes)[i]))),
           printf(fh, "    uFrac = ~a; ~%", gcfac(float(surfac*alphaCtrl/cflRateCtrlL[i-1]))),
           printf(fh, "    fCtrl = ~a; ~%", GlimL),
           printf(fh, "    if(std::abs(alphaCtrl)<EPSILON || std::abs(fCtrl)<EPSILON) ~a = 0.;~%", fullratsimp(-incrC_l[i])),
           printf(fh, "    else ~a = std::min(~a, std::abs(uFrac)*fCtrl/dtApprox);~%", fullratsimp(-incrC_l[i]), fullratsimp(-incrC_l[i])),
           printf(fh, "  }~%")
        )
      ), 

      printf(fh, "~%"),
      flush_output(fh),
      writeCExprsNoExpand1(incr, subst([wv^2=wv2,q_^2=q2], incr_r)),
      printf(fh, "~%"),

      incr_s : makelist(incr[i-1], i, 1, length(bC)),
      writeCIncrExprsNoExpand1(outr, incr_s),  
      printf(fh, "~%"),
      flush_output(fh),
      signs : fullratsimp(incr_l/incr_r),
      incr_s : makelist(signs[i]*incr[i-1], i, 1, length(bC)),
      writeCIncrExprsNoExpand1(outl, incr_s),
      flush_output(fh)
    )
    else (
      if cdim>1 then (
      printf(fh, "#if upwindType == SURFAVG ~%")
      ),
      printf(fh, "  if (alpha0>0) { ~%"),
      fhatSurf_expd : subst(surfVar=1, fL_expd),

      t : surfac*calcInnerProdList(surfIntVars, alphaSurf_expd, subst(surfVar=-1, bC), fhatSurf_expd),
      incr_r : facsum(fullratsimp(t),dxv),
      writeCExprsNoExpand1(incr, subst([wv^2=wv2,q_^2=q2], incr_r)),
      flush_output(fh),

      printf(fh, "  } else { ~%"),
      fhatSurf_expd : subst(surfVar=-1, fR_expd),

      t : surfac*calcInnerProdList(surfIntVars, alphaSurf_expd, subst(surfVar=-1, bC), fhatSurf_expd),
      incr_r : facsum(fullratsimp(t),dxv),
      writeCExprsNoExpand1(incr, subst([wv^2=wv2,q_^2=q2], incr_r)),
      printf(fh, "  }~%"),
      flush_output(fh),

     if cdim>1 then (
      printf(fh, "#elif upwindType == QUAD ~%"),
      printf(fh, "double fupwind[~a];~%", length(bSurf)),
      printf(fh, "double fupwindQuad[~a];~%", length(bSurf)),
      printf(fh, "double alphaQuad;~%"),
      if i=1 then quad:1/sqrt(3),
      if i=2 then quad:sqrt(3/5),
      nodes : eval_string(sconcat("nodes", cdim-1, "xp", p)),
      /* function to evaluate expansion g at surface quadrature nodes */
      nodesub(g):=makelist(subst(makelist(surfIntVars[j]=nodes[i][j],j,1,length(varsC)-1),g),i,1,length(nodes)),
      /* evaluate fl, fr, and alpha at surface quadrature nodes */
      frQ:gcfac(float(nodesub(subst(surfVar=-1,fR_expd)))),
      flQ:gcfac(float(nodesub(subst(surfVar=1,fL_expd)))), 
      /* note: alphaSurf_expd is already a surface expansion */
      alphaq:gcfac(float(nodesub(alphaSurf_expd))),
      /* determine upwinding at each surface quadrature node */
      fupQ : gcfac(.5*(flQ+frQ)+.5*sgn(alphaQuad)*(flQ-frQ)),
      for i:1 thru length(alphaq) do (
      printf(fh, "  alphaQuad = ~a; ~%", alphaq[i]),
      printf(fh, "  fupwindQuad[~a] = ~a; ~%", i-1, fupQ[i])
      ),
      flush_output(fh),
      /* use modToNod transformation to get modal surface expansion from nodal quadrature points */
      modToNod:fullratsimp(calcModToNodPhaseWithNodesAndBasis(nodes,bSurf,surfIntVars)),
      fupwind_k:invert(transpose(float(modToNod))).makelist(fupwindQuad[i-1],i,1,length(nodes)),
      fupwind_k:gcfac(makelist(fupwind_k[i][1],i,1,length(fupwind_k))),
      /* write coefficients of modal surface expansion fupwind */
      writeCExprsNoExpand1(fupwind, fupwind_k),
      fhatSurf_expd:doExpand1(fupwind,bSurf),
      flush_output(fh),

      t : surfac*calcInnerProdList(surfIntVars, alphaSurf_expd, subst(surfVar=-1, bC), fhatSurf_expd),
      incr_r : facsum(fullratsimp(t),dxv),
      writeCExprsNoExpand1(incr, subst([wv^2=wv2,q_^2=q2], incr_r)),
      printf(fh, "~%"),
      flush_output(fh),
      printf(fh, "#endif ~%")
     ),

     incr_s : makelist(incr[i-1], i, 1, length(bC)),
     writeCIncrExprsNoExpand1(outr, incr_s),  
     printf(fh, "~%"),
     flush_output(fh),
     t : surfac*calcInnerProdList(surfIntVars, alphaSurf_expd, subst(surfVar=1, bC), fhatSurf_expd),
     incr_l : -t,
     signs : fullratsimp(incr_l/incr_r),
     incr_s : makelist(signs[i]*incr[i-1], i, 1, length(bC)),
     writeCIncrExprsNoExpand1(outl, incr_s),
     flush_output(fh)
    ),


    printf(fh, "  return std::abs(alpha0); ~%"),
    printf(fh, "} ~%"),
    flush_output(fh)
    
  )
)$

calcAdvectionSurfUpdater(fh, funcNm, cdim, basisFun,p) := block([],
  for dir : 1 thru cdim do (
    calcUpdateInDir(dir, fh, funcNm, cdim, basisFun,p)
  )
)$

for pos: 0 thru 1 do (
if pos=0 then positivity:false
else positivity:true,
if positivity then (posString : "Positivity", cmin:2)
else (posString : "", cmin:1),

for c : cmin thru 3 do (
pmax:1,
if c=1 then (pmax:2),
if positivity then pmax:1,
for p:1 thru pmax do (
/* separate file for positivity implementation */
fname : sconcat("~/max-out/PassiveAdvectionSurf", posString, "Ser", c, "xP", p, ".cpp"),
fh : openw(fname),
printf(fh, "#include <PassiveAdvectionModDecl.h> ~%"),
funcName : sconcat("PassiveAdvectionSurf", posString, c, "xSer"),
calcAdvectionSurfUpdater(fh, funcName, c, "Ser", p),
close(fh)
)))$

