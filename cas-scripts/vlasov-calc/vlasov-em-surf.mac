load("modal-basis");
load("out-scripts");
load(stringproc)$
fpprec : 24$

varsV : [vx, vy, vz]$
cvars : [X, Y, Z]$
vvars : [VX, VY, VZ]$

dvdx : [dv0dx0, dv1dx1, dv2dx2]$
wdx : [w0dx0, w1dx1, w2dx2]$
dv11 : [dv10, dv11, dv12]$
Efld : [E0, E1, E2]$
Bfld : [B0, B1, B2]$

vTransSubs : [vvx=vx*dv1/2+wv1, vvy=vy*dv2/2+wv2, vvz=vz*dv3/2+wv3]$

ax(vx, vy, vz, bc) := doExpand1(Efld[1],bc) + vy*doExpand1(Bfld[3],bc) - vz*doExpand1(Bfld[2],bc)$
ay(vx, vy, vz, bc) := doExpand1(Efld[2],bc) + vz*doExpand1(Bfld[1],bc) - vx*doExpand1(Bfld[3],bc)$
az(vx, vy, vz, bc) := doExpand1(Efld[3],bc) + vx*doExpand1(Bfld[2],bc) - vy*doExpand1(Bfld[1],bc)$

vzero(vdim) := if vdim = 1 then [vvy=0, vvz=0] elseif vdim = 2 then [vvz=0] else [] $

calcAccel(vdir, vdim, bc) :=
  if vdir = 1
    then subst(vTransSubs, subst(vzero(vdim), ax(vvx,vvy,vvz,bc)))
  elseif vdir = 2
    then subst(vTransSubs, subst(vzero(vdim), ay(vvx,vvy,vvz,bc)))
  else
    subst(vTransSubs, subst(vzero(vdim), az(vvx,vvy,vvz,bc)))$

slcn(lst, n) := makelist(lst[i], i, 1, n)$

cidx(cdim) := makelist(i,i,0,cdim-1)$
vidx(cdim,vdim) := makelist(i,i,cdim,cdim+vdim-1)$

calcUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun) := block([],
kill(varsC, varsP, basisC, basisP),
modNm : sconcat("basis-precalc/basis", basisFun, cdim, "x", vdim, "v"),
load(modNm),
for i : 1 thru 2 do (
  bP : basisP[i],
  varsC : slcn(varsP, cdim),
  bC : basisC[i],
  numC : length(bC),
  zr : makelist(varsC[d]=0, d, 1, cdim),

  printf(fh, "void ~a_~a_P~a(const double *w, const double *dxv, const double *Ein, const double *fl, const double *fr, double *outl, double *outr) ~%{ ~%", funcNm, vvars[dir], i),
  printf(fh, "// w: Cell-center coordinates. dxv[NDIM]: Cell spacing. E: electric field, fl/fr: Distribution function in left/right cells ~%"),
  printf(fh, "// outl/outr: output distribution function in left/right cells ~%"),

  cid : cidx(cdim),
  vid : vidx(cdim,vdim),
  printf(fh, "  double dv1 = 2/dxv[~a]; ~%", vid[dir]),
  printf(fh, "  const double *E = &Ein[~a]; ~%", numC*(dir-1)),
  printf(fh, "  double incr[~a]; ~%~%", length(bP)),
  cv : varsP[dir],
  vv : varsV[dir],
  surfVars : delete(vv,varsP),
  fl_L : doExpand1(fl, bP),
  fl_R : doExpand1(fr, bP),
  El : doExpand1(E, bC),

  Emid : float(expand(fullratsimp(subst(zr,El)))),

  printf(fh, "  if (E[0]>0) { ~%"),
  fhat : subst(vv=1, fl_L),
  t : dv1*calcInnerProdList(surfVars, El, subst(vv=-1, bP), fhat),
  incr_r : t,
  writeCExprs1(incr, incr_r),
  printf(fh, "~%"),
  incr_s : makelist(incr[i-1], i, 1, length(bP)),
  writeCIncrExprs1(outr, incr_s),  
  printf(fh, "~%"),
  t : dv1*calcInnerProdList(surfVars, El, subst(vv=1, bP), fhat),
  incr_l : -t,
  signs : fullratsimp(incr_l/incr_r),
  incr_s : makelist(signs[i]*incr[i-1], i, 1, length(bP)),
  writeCIncrExprs1(outl, incr_s),
  
  printf(fh, "  } else { ~%"),
  fhat : subst(vv=-1, fl_R),
  t : dv1*calcInnerProdList(surfVars, El, subst(vv=-1, bP), fhat),
  incr_r : t,
  writeCExprs1(incr, incr_r),
  printf(fh, "~%"),
  incr_s : makelist(incr[i-1], i, 1, length(bP)),
  writeCIncrExprs1(outr, incr_s),  
  printf(fh, "~%"),
  t : dv1*calcInnerProdList(surfVars, El, subst(vv=1, bP), fhat),
  incr_l : -t,
  signs : fullratsimp(incr_l/incr_r),
  incr_s : makelist(signs[i]*incr[i-1], i, 1, length(bP)),
  writeCIncrExprs1(outl, incr_s),
  printf(fh, "  } ~%"),
  printf(fh, "} ~%")
));

calcVlasovSurfUpdater(fh, funcNm, cdim, vdim, basisFun) := block([],
  printf(fh, "#include <VlasovModDecl.h> ~%"),
  for dir : 1 thru vdim do ( calcUpdateInDir(dir, fh, funcNm, cdim, vdim, basisFun) )
)$