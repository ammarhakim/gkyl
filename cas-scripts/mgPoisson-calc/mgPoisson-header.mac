/* Create header file for multigrid Poisson solver. */

fh : openw("~/max-out/MGpoissonModDecl.h")$

polyOrderMax : 2$

bName        : ["Ser"]$


VarsC : [X, Y, Z]$

/* This variable obviates some if-statements. */
boundStrKey : [[-1,"L"],[0,""],[1,"U"]]$
/* Types of boundary conditions for which to generate kernels.
     =0 periodic
     =1 Dirichlet
     =2 Neumann
     =3 Robin
   For periodic we'll assume ghost cells are filled accordingly
   and use an interior stencil. */
bcTypesDG  : [0, 3]$
bcStrsDG   : ["", "Robin"]$
bcTypesFEM : [0, 1, 2, 3]$
bcStrsFEM  : ["", "Dirichlet", "Neumann", "Robin"]$
bcKeyDG    : makelist([bcTypesDG[i],bcStrsDG[i]],i,1,length(bcTypesDG))$
bcKeyFEM   : makelist([bcTypesFEM[i],bcStrsFEM[i]],i,1,length(bcTypesFEM))$

printf(fh, "#ifndef MG_POISSON_MOD_DECL_H ~%")$
printf(fh, "#define MG_POISSON_MOD_DECL_H ~%")$
printf(fh, " ~%")$

printf(fh, "#include <cmath>~%")$
printf(fh, " ~%")$

printf(fh, "extern \"C\" { ~%")$
printf(fh, " ~%")$

findBoundaryStrCombo(fhIn, funcNameStr, funcArgsStr, basisFun, dim, bcKey) := block([],
  /* Obtain the various string combinations for the names of the
     kernels used near boundaries. */

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  /* This will well with (string) variable selection
     depending on stencil location. */
  sVarsC : copylist(varsC),
  for d : 1 thru dim do (
    sVarsC[d] : string(varsC[d])
  ),
  condVarsC : [[-1,sVarsC],[0,makelist("",i,1,dim)],[1,sVarsC]],
  
  /* Create a list with 3^dim elements. Each element is itself an dim-long
     list indicating whether the cell has a lower (=-1) or upper (=1)
     boundary, or no boundary (=0) in that direction. */
  cD : 1,
  stencilLoc  : [makelist(0,i,1,dim)],  /* Center stencil, all zeros. */
  
  for dir : 1 thru dim do (
    /* Loop through cells already added to stencilLoc. */
    for acI : 1 thru 3^(dir-1) do (
      /* Loop over lower and upper. */
      for bI : -1 thru 1 step 2 do (
        stencilLoc : append(stencilLoc, copylist([stencilLoc[acI]])),
        stencilLoc[length(stencilLoc)][dir] : bI
      )
    )
  ),

  for sI : 2 thru length(stencilLoc) do (
  
    /* Count the number of non-periodic boundaries. */
    npBCs : 0,
    for d : 1 thru dim do (
      if (stencilLoc[sI][d] # 0) then (
        npBCs : npBCs + 1
      )
    ),
  
    /* Given npBCs non-periodic BCs there are bcN^npBCs possible combinations of
       of that cell's stencil, assuming there are bcN types of BCs. For now
       only Robin BCs are supported (also used for Dirichlet/Neumann). */
    npBCcombos : makelist([bcKey[i][1]],i,2,length(bcKey)),
    for l : 2 thru npBCs do (
      tmp : copylist(npBCcombos),
      npBCcombos : [],
      for cI : 1 thru length(tmp) do (
        for bI : 2 thru length(bcKey) do (
          npBCcombos : append(npBCcombos,[ append(tmp[cI],[bcKey[bI][1]]) ])
        )
      )
    ),

    for bcI : 1 thru length(npBCcombos) do (
      /* Loop over BC combinations. Will create a separate kernel for each. */

      currBCs : copylist(npBCcombos[bcI]),
      /* It's easier to work with a list of dim elements indicating the BC
         in each direction (rather than npBCcombos), even if it's periodic. */
      nInc : 0,
      for d : 1 thru dim do (
        if (stencilLoc[sI][d] = 0) then (
          currBCs :Â append(firstn(currBCs,d+nInc-1),[0],lastn(currBCs,length(currBCs)-(d+nInc-1))),
          nInc    : nInc+1
        )
      ),

      boundaryStr : "",
      for d : 1 thru dim do (
        boundaryStr : sconcat(boundaryStr,assoc(stencilLoc[sI][d],boundStrKey),
                              assoc(stencilLoc[sI][d],condVarsC)[d],assoc(currBCs[d],bcKey))
      ),
      boundaryStr : sconcat(boundaryStr,"_"),

      printf(fhIn, sconcat("void ",funcNameStr,"~ax~a_~aP~a(",funcArgsStr,");~%"), dim, bName[bInd], boundaryStr, polyOrder)
    )
  )
)$

getDGtoFEMboundaryStrs(fhIn, funcNameStr, funcArgsStr, basisFun, dim) := block([],
  /* Obtain the various string combinations for the names of the
     kernels used near boundaries. */

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  /* Create a list with 3^dim elements. Each element is itself an dim-long
     list indicating whether the cell is next to a lower (=-1) or upper (=1)
     boundary, or no boundary (=0) in that direction. */
  stencilLoc : [makelist(0,i,1,dim)],  /* Lower left stencil, all zeros. */
  for dir : 1 thru dim do (
    /* Loop through cells already added to stencilLoc. */
    for acI : 1 thru 3^(dir-1) do (
      /* Loop over lower and upper. */
      for bI : -1 thru 1 step 2 do (
        stencilLoc : append(stencilLoc, copylist([stencilLoc[acI]])),
        stencilLoc[length(stencilLoc)][dir] : bI
      )
    )
  ),

  /* This is used in placing (string) variables in kernel boundary names. */
  sVarsC : copylist(varsC),
  for d : 1 thru dim do (
    sVarsC[d] : string(varsC[d])
  ),
  condVarsC : [[-1,sVarsC],[0,makelist("",i,1,dim)],[1,sVarsC]],

  for sI : 2 thru length(stencilLoc) do (
    /* Number of non-periodic boundaries. */
    npBCs : sum(stencilLoc[sI][i],i,1,length(stencilLoc[sI])),

    boundaryStr : "",
    for d : 1 thru dim do (
      boundaryStr : sconcat(boundaryStr,assoc(stencilLoc[sI][d],boundStrKey),
                            assoc(stencilLoc[sI][d],condVarsC)[d])
    ),
    boundaryStr : sconcat(boundaryStr,"_"),

    printf(fhIn, sconcat("void ",funcNameStr,"~ax~a_~aP~a(",funcArgsStr,");~%"), dim, bName[bInd], boundaryStr, polyOrder)
  )
)$

for bInd : 1 thru length(bName) do (

  for polyOrder : 1 thru polyOrderMax do (
    for ci : 1 thru 2 do (

      /* ~~~~~~~~~~~~~~ DG solver kernels ~~~~~~~~~~~~~~ */

      /* Prolongation and restriction operators. */
      printf(fh, "void MGpoissonDGProlong~ax~a_P~a(const double *fldC, double **fldF);~%", ci, bName[bInd], polyOrder),
      printf(fh, "void MGpoissonDGRestrict~ax~a_P~a(double **fldF, double *fldC);~%", ci, bName[bInd], polyOrder),
      printf(fh, "~%"),

      /* Smoothers. */
      printf(fh, "void MGpoissonDGDampedGaussSeidel~ax~a_P~a(const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi);~%", ci, bName[bInd], polyOrder),
      printf(fh, "void MGpoissonDGDampedJacobi~ax~a_P~a(const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi);~%", ci, bName[bInd], polyOrder),
      /* Boundary smoothers. */
      findBoundaryStrCombo(fh, "MGpoissonDGDampedGaussSeidel", "const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi", bName[bInd], ci, bcKeyDG),
      findBoundaryStrCombo(fh, "MGpoissonDGDampedJacobi", "const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi", bName[bInd], ci, bcKeyDG),
      printf(fh, "~%"),

      /* Residue kernels. */
      printf(fh, "void MGpoissonDGResidue~ax~a_P~a(double **dx, const double *bcVals, double **rho, double **phi, double *resOut);~%", ci, bName[bInd], polyOrder),
      findBoundaryStrCombo(fh, "MGpoissonDGResidue", "double **dx, const double *bcVals, double **rho, double **phi, double *resOut", bName[bInd], ci, bcKeyDG),
      printf(fh, "~%"),

      /* ~~~~~~~~~~~~~~ FEM solver kernels. ~~~~~~~~~~~~~~ */
      /* Translating between DG and FEM. */
      printf(fh, "void MGpoissonFEM_DGtoFEM_~ax~a_P~a(const double *dgFld, double **femOut);~%", ci, bName[bInd], polyOrder),
      getDGtoFEMboundaryStrs(fh, "MGpoissonFEM_DGtoFEM_", "const double *dgFld, double **femOut", bName[bInd], ci),
      printf(fh, "~%"),

      /* Smoothers. */
      printf(fh, "void MGpoissonFEMDampedJacobi~ax~a_P~a(const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi);~%", ci, bName[bInd], polyOrder),
      printf(fh, "void MGpoissonFEMDampedGaussSeidel~ax~a_P~a(const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi);~%", ci, bName[bInd], polyOrder),
      /* Boundary smoothers. */
      findBoundaryStrCombo(fh, "MGpoissonFEMDampedJacobi", "const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi", bName[bInd], ci, bcKeyFEM),
      findBoundaryStrCombo(fh, "MGpoissonFEMDampedGaussSeidel", "const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi", bName[bInd], ci, bcKeyFEM),
      printf(fh, "~%"),

      /* Prolongation and restriction operators. */
      printf(fh, "void MGpoissonFEMProlong~ax~a_P~a(const double *fldC, double **fldF);~%", ci, bName[bInd], polyOrder),
      findBoundaryStrCombo(fh, "MGpoissonFEMProlong", "const double *fldC, double **fldF", bName[bInd], ci, bcKeyFEM),
      printf(fh, "void MGpoissonFEMRestrict~ax~a_P~a(double **fldF, double *fldC);~%", ci, bName[bInd], polyOrder),
      findBoundaryStrCombo(fh, "MGpoissonFEMRestrict", "double **fldF, double *fldC", bName[bInd], ci, bcKeyFEM),
      printf(fh, "~%"),

      /* Residue kernels. */
      printf(fh, "void MGpoissonFEMResidue~ax~a_P~a(double **dx, const double *bcVals, double **rho, double **phi, double *resOut);~%", ci, bName[bInd], polyOrder),
      findBoundaryStrCombo(fh, "MGpoissonFEMResidue", "double **dx, const double *bcVals, double **rho, double **phi, double *resOut", bName[bInd], ci, bcKeyFEM),
      printf(fh, "~%")

    ),
    printf(fh, "~%")
  )

);

printf(fh, "} ~%")$

printf(fh, "#endif ~%")$

close(fh)$
