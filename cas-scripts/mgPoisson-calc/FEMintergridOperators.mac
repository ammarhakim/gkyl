/* Generate kernels for FEM inter-grid operators: prolongation and restiction */

load("modal-basis");
load("out-scripts");
load("nodalOperations/nodalFunctions");
load("mgPoisson-calc/FEMnodalFuncs");

fpprec : 24$

calcFEMProlongationOp(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Prolongation operator transfering a coarse-grid field to the
     fine grid. Currently limited to coarsening 2^a grids by a
     factor of 2 in both directions. */

  /* Number of fine cells span by a single coarse cell in one direction. */ 
  beta         : 2,
  numFineCells : beta^dim,
  stencilSizeF : (beta*2)^dim,
  stencilSizeC : beta^dim,

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  for polyOrder : 1 thru pMax do (
    bN : getNodalBasis(basisFun, dim, polyOrder),
    N  : length(bN),

    nodes : args(getNodes(basisFun, dim, polyOrder)),

    /* Each cell only stores the lower left nodes. */
    storedNodes    : getStoredNodes(nodes,makelist(0,i,1,dim)),
    numStoredNodes : length(storedNodes), 

    /* Create a table of the relationship between the logical coordinates
       in each direction of the coarse and fine grids. */
    wFsten  : [makelist(wF[i],i,0,dim-1)],
    wCsten  : [makelist(wF[i]-dxC[i]/4,i,0,dim-1)],
    dxFsten : [makelist(dxC[i]/2,i,0,dim-1)],
    dxCsten : [makelist(dxC[i],i,0,dim-1)],
    eLo     : fullratsimp(makelist(max(-1,1-(2/dxFsten[1][i])*(wFsten[1][i]+dxFsten[1][i]/2-(wCsten[1][i]-dxCsten[1][i]/2))),i,1,dim)),
    eUp     : fullratsimp(makelist(min(1,-1+(2/dxFsten[1][i])*(wCsten[1][i]+dxCsten[1][i]/2-(wFsten[1][i]-dxFsten[1][i]/2))),i,1,dim)),
    intLims : [makelist([eLo[d], eUp[d]],d,1,dim)],
    varMap  : [fullratsimp(makelist((2/dxCsten[1][i])*(wFsten[1][i]-wCsten[1][i]+(dxFsten[1][i]/2)*varsC[i]),i,1,dim))],
    for dI : 1 thru dim do (
      numVarMap : length(varMap),
      for pS : 1 thru numVarMap do (
        /* Add 2*beta-1 nearest lower cells. */
        for k : 1 thru (2*beta-1) do (
          /* Add the variable transformation in nearest upper cell. */
          wCsten  : endcons(copylist(wCsten[pS]),wCsten),
          dxCsten : endcons(copylist(dxCsten[pS]),dxCsten),
          wFsten  : endcons(copylist(wFsten[pS]),wFsten),
          dxFsten : endcons(copylist(dxFsten[pS]),dxFsten),

          curr : length(wCsten),

          wFsten[curr][dI] : wFsten[curr][dI]-k*dxC[dI-1]/2,
          wCsten[curr][dI] : wCsten[curr][dI]-floor(k/2)*dxC[dI-1],

          wFp  : wFsten[curr],
          wCp  : wCsten[curr],
          dxFp : dxFsten[curr],
          dxCp : dxCsten[curr],

          eLo     : fullratsimp(makelist(max(-1,1-(2/dxFp[i])*(wFp[i]+dxFp[i]/2-(wCp[i]-dxCp[i]/2))),i,1,dim)),
          eUp     : fullratsimp(makelist(min(1,-1+(2/dxFp[i])*(wCp[i]+dxCp[i]/2-(wFp[i]-dxFp[i]/2))),i,1,dim)),
          intLims : endcons(makelist([eLo[d], eUp[d]],d,1,dim),intLims),

          varMap  : endcons(copylist(varMap[pS]),varMap),
          varMap[curr][dI] : fullratsimp((2/dxCp[dI])*(wFp[dI]-wCp[dI]+(dxFp[dI]/2)*varsC[dI]))
        )
      )
    ),

    /* Associative list of nodes in each fine-grid cell nodesExF, nodes involved in the weak equality
       without duplication (weqNodesExF), and nodes stored in each cell (storedNodesExF).
       Each fine-grid cell has an element in these lists. Each element is a 2-entry list;
       the 1st entry is the cell coordinate (relative to the upper-right corner), the 2nd
       is a list of nodes in that cell, with coordinates on the extended [-7,1] logical space. */
    nodesExF       : [[makelist(0,i,1,dim), nodes]],
    weqNodesExF    : [[makelist(0,i,1,dim), nodes]],
    storedNodesExF : [[makelist(0,i,1,dim), storedNodes]],
    for dI: 1 thru dim do (
      cellsSoFar : length(nodesExF),
      for pS : 1 thru cellsSoFar do (
        prevNodes       : nodesExF[pS][2],
        prevWeqNodes    : deleteNodes(weqNodesExF[pS][2],[[dI,1]],true),
        prevStoredNodes : deleteNodes(storedNodesExF[pS][2],[[dI,1]],true),
        /* Add 2*beta-1 nearest lower cells. */
        for k : 1 thru (2*beta-1) do (

          loc            : copylist(nodesExF[pS][1]),
          loc[dI]        : -1*k,

          newNodes       : copylist(prevNodes),
          for i : 1 thru length(prevNodes) do ( newNodes[i][dI] : prevNodes[i][dI]-2*k ),
          nodesExF       : endcons([loc,newNodes],nodesExF),

          newNodes       : copylist(prevWeqNodes),
          for i : 1 thru length(prevWeqNodes) do ( newNodes[i][dI] : prevWeqNodes[i][dI]-2*k ),
          weqNodesExF    : endcons([loc,newNodes],weqNodesExF),

          newNodes       : copylist(prevStoredNodes),
          for i : 1 thru length(prevStoredNodes) do ( newNodes[i][dI] : prevStoredNodes[i][dI]-2*k ),
          storedNodesExF : endcons([loc,newNodes],storedNodesExF)
        )
      )
    ),
    /* Associative list of fine-grid nodes on [-7,1] logical space, and
       the cell that contributes that node to the weak equality. */
    weqNodeToCellF : [],
    for i : 1 thru length(weqNodesExF) do (
      for k : 1 thru length(weqNodesExF[i][2]) do (
        weqNodeToCellF : endcons([weqNodesExF[i][2][k],weqNodesExF[i][1]],weqNodeToCellF)
      )
    ),
    /* Associative list of nodes on [-7,1] logical space, and the cell that stores that node. */
    storedNodeToCellF : [],
    for i : 1 thru length(storedNodesExF) do (
      for k : 1 thru length(storedNodesExF[i][2]) do (
        storedNodeToCellF : endcons([storedNodesExF[i][2][k],storedNodesExF[i][1]],storedNodeToCellF)
      )
    ),
    /* Associative list between fine cell coordinates and a linear index. */
    idx        : 0,
    cellToIdxF : [[makelist(0,i,1,dim),idx]],
    for dI : 1 thru dim do (
      cellsSoFar : length(cellToIdxF),
      for pS : 1 thru cellsSoFar do (
        for k : 1 thru (2*beta-1) do ( /* Add 2*beta-1 nearest lower cells. */
          cellToIdxF : endcons(copylist(cellToIdxF[pS]),cellToIdxF),
          idx        : idx+1,
          cellToIdxF[idx+1][1][dI] : -k,
          cellToIdxF[idx+1][2]     : idx
        )
      )
    ),
    /* Associative list of fine-grid cell coordinate, and the memory location of each node. */
    weqOwnerIdx      : 0,
    currCoord        : makelist(0,i,1,dim),
    locNodesEx       : assoc(currCoord,nodesExF),
    fakeMemIdx       : numStoredNodes,
    memLoc           : [],
    storedNodeCoefsF : [[]],
    for k : 1 thru N do (
      memIdx : sublist_indices(assoc(currCoord,storedNodesExF),lambda([x],x=locNodesEx[k])),
      if length(memIdx)>0 then (
        memIdx     : memIdx[1]-1
      ) else (
        memIdx     : fakeMemIdx,
        fakeMemIdx : fakeMemIdx+1
      ),
      storedNodeCoefsF[1] : endcons(memIdx,storedNodeCoefsF[1]), 
      memLoc : endcons(eval_string(sconcat("fldF",weqOwnerIdx))[memIdx],memLoc)
    ),
    cellToCoefF : [[makelist(0,i,1,dim),memLoc]],
    for dI: 1 thru dim do (
      cellsSoFar : length(cellToCoefF),
      for pS : 1 thru cellsSoFar do (
        for j : 1 thru (2*beta-1) do (  /* Add 2*beta-1 nearest lower cells. */
          currCoord     : copylist(cellToCoefF[pS][1]),
          currCoord[dI] : -j,
          locNodesEx    : assoc(currCoord,nodesExF),
          fakeMemIdx    : numStoredNodes,
          memLoc        : [],
          memIdxs       : [],
          for k : 1 thru N do (
            weqCell            : assoc(locNodesEx[k],weqNodeToCellF),
            weqCellStoredNodes : assoc(weqCell,storedNodesExF),
            memIdx             : sublist_indices(weqCellStoredNodes,lambda([x],x=locNodesEx[k])),
            if length(memIdx)>0 then (
              memIdx     : memIdx[1]-1
            ) elseif weqCell=currCoord then (
              memIdx     : fakeMemIdx,
              fakeMemIdx : fakeMemIdx+1
            ) else (
              memIdx     : storedNodeCoefsF[assoc(weqCell,cellToIdxF)+1][sublist_indices(assoc(weqCell,nodesExF),lambda([x],x=locNodesEx[k]))[1]]
            ),
            memIdxs : endcons(memIdx,memIdxs),
            memLoc  : endcons(eval_string(sconcat("fldF",assoc(assoc(locNodesEx[k],weqNodeToCellF),cellToIdxF)))[memIdx],memLoc)
          ),
          storedNodeCoefsF : endcons(memIdxs,storedNodeCoefsF), 
          cellToCoefF      : endcons([currCoord,memLoc],cellToCoefF)
        )
      )
    ),

    /* Associative list of nodes in each coarse-grid cell nodesExC, nodes involved in the weak equality
       without duplication (weqNodesExC), and nodes stored in each cell (storedNodesExC).
       Each fine-grid cell has an element in these lists. Each element is a 2-entry list;
       the 1st entry is the cell coordinate (relative to the upper-right corner), the 2nd
       is a list of nodes in that cell, with coordinates on the extended [-3,1] logical space. */
    nodesExC       : [[makelist(0,i,1,dim), nodes]],
    weqNodesExC    : [[makelist(0,i,1,dim), nodes]],
    storedNodesExC : [[makelist(0,i,1,dim), storedNodes]],
    for dI: 1 thru dim do (
      cellsSoFar : length(nodesExC),
      for pS : 1 thru cellsSoFar do (
        prevNodes       : nodesExC[pS][2],
        prevWeqNodes    : deleteNodes(weqNodesExC[pS][2],[[dI,1]],true),
        prevStoredNodes : deleteNodes(storedNodesExC[pS][2],[[dI,1]],true),

        loc            : copylist(nodesExC[pS][1]),
        loc[dI]        : -1,

        newNodes       : copylist(prevNodes),
        for i : 1 thru length(prevNodes) do ( newNodes[i][dI] : prevNodes[i][dI]-2 ),
        nodesExC       : endcons([loc,newNodes],nodesExC),

        newNodes       : copylist(prevWeqNodes),
        for i : 1 thru length(prevWeqNodes) do ( newNodes[i][dI] : prevWeqNodes[i][dI]-2 ),
        weqNodesExC    : endcons([loc,newNodes],weqNodesExC),

        newNodes       : copylist(prevStoredNodes),
        for i : 1 thru length(prevStoredNodes) do ( newNodes[i][dI] : prevStoredNodes[i][dI]-2 ),
        storedNodesExC : endcons([loc,newNodes],storedNodesExC)
      )
    ),
    /* Associative list of coarse-grid nodes on [-3,1] logical space, and
       the cell that contributes that node to the weak equality. */
    weqNodeToCellC : [],
    for i : 1 thru length(weqNodesExC) do (
      for k : 1 thru length(weqNodesExC[i][2]) do (
        weqNodeToCellC : endcons([weqNodesExC[i][2][k],weqNodesExC[i][1]],weqNodeToCellC)
      )
    ),
    /* Associative list of coarse-grid nodes on [-3,1] logical space, and the cell that stores that node. */
    storedNodeToCellC : [],
    for i : 1 thru length(storedNodesExC) do (
      for k : 1 thru length(storedNodesExC[i][2]) do (
        storedNodeToCellC : endcons([storedNodesExC[i][2][k],storedNodesExC[i][1]],storedNodeToCellC)
      )
    ),
    /* Associative list between coarse cell coordinates and a linear index. */
    idx        : 0,
    cellToIdxC : [[makelist(0,i,1,dim),idx]],
    for dI : 1 thru dim do (
      numCoordIdx : length(cellToIdxC),
      for pS : 1 thru numCoordIdx do (
        /* Add nearest lower cell. */
        cellToIdxC : endcons(copylist(cellToIdxC[pS]),cellToIdxC),
        idx        : idx+1,
        cellToIdxC[idx+1][1][dI] : -1,
        cellToIdxC[idx+1][2]     : idx
      )
    ),
    /* Associative list of coarse-grid cell coordinate, and the memory location of each node. */
    weqOwnerIdx      : 0,
    currCoord        : makelist(0,i,1,dim),
    locNodesEx       : assoc(currCoord,nodesExC),
    fakeMemIdx       : numStoredNodes,
    memLoc           : [],
    storedNodeCoefsC : [[]],
    for k : 1 thru N do (
      memIdx : sublist_indices(assoc(currCoord,storedNodesExC),lambda([x],x=locNodesEx[k])),
      if length(memIdx)>0 then (
        memIdx     : memIdx[1]-1
      ) else (
        memIdx     : fakeMemIdx,
        fakeMemIdx : fakeMemIdx+1
      ),
      storedNodeCoefsC[1] : endcons(memIdx,storedNodeCoefsC[1]),
      memLoc : endcons(eval_string(sconcat("fldC",weqOwnerIdx))[memIdx],memLoc)
    ),
    cellToCoefC : [[makelist(0,i,1,dim),memLoc]],
    for dI: 1 thru dim do (
      cellsSoFar : length(cellToCoefC),
      for pS : 1 thru cellsSoFar do (
        currCoord     : copylist(cellToCoefC[pS][1]),
        currCoord[dI] : -1,
        locNodesEx    : assoc(currCoord,nodesExC),
        fakeMemIdx    : numStoredNodes,
        memLoc        : [],
        memIdxs       : [],
        for k : 1 thru N do (
          weqCell            : assoc(locNodesEx[k],weqNodeToCellC),
          weqCellStoredNodes : assoc(weqCell,storedNodesExC),
          memIdx             : sublist_indices(weqCellStoredNodes,lambda([x],x=locNodesEx[k])),
          if length(memIdx)>0 then (
            memIdx     : memIdx[1]-1
          ) elseif weqCell=currCoord then (
            memIdx     : fakeMemIdx,
            fakeMemIdx : fakeMemIdx+1
          ) else (
            memIdx     : storedNodeCoefsC[assoc(weqCell,cellToIdxC)+1][sublist_indices(assoc(weqCell,nodesExC),lambda([x],x=locNodesEx[k]))[1]]
          ),
          memIdxs : endcons(memIdx,memIdxs),
          memLoc  : endcons(eval_string(sconcat("fldC",assoc(assoc(locNodesEx[k],weqNodeToCellC),cellToIdxC)))[memIdx],memLoc)
        ),
        storedNodeCoefsC : endcons(memIdxs,storedNodeCoefsC),
        cellToCoefC      : endcons([currCoord,memLoc],cellToCoefC)
      )
    ),

    /* Associative list of coordinates of the fine-grid cell, and the
       coarse-grid cell that overlaps with it. */
    coordFtoC : [[makelist(0,i,1,dim),makelist(0,i,1,dim)]],
    for dI : 1 thru dim do (
      cellsSoFar : length(coordFtoC),
      for pS : 1 thru cellsSoFar do (
        for k : 1 thru (2*beta-1) do (  /* Add 2*beta-1 nearest lower fine-grid cells. */
          coordF     : copylist(coordFtoC[pS][1]),
          coordC     : copylist(coordFtoC[pS][2]),
          coordF[dI] : -k,
          coordC[dI] : -floor(k/2),
          coordFtoC  : endcons([coordF,coordC],coordFtoC)
        )
      )
    ),

    /* Loop over fine cells involved in weak equality. Each cell either adds a
       new equation to the system (for nodes it owns), or contributes to existing
       equations (for nodes owned by another cell). */
    cFld_e : doExpand(assoc(coordFtoC[1][2],cellToCoefC),bN),
    fFld_e : doExpand(cellToCoefF[1][2],bN),
    weqLHS : [calcInnerProdListGen(varsC,intLims[1],1,bN,subst(makelist(varsC[i]=varMap[1][i],i,1,dim),cFld_e))],
    weqRHS : [calcInnerProdList(varsC,1,bN,fFld_e)],
    cI     : 1,
    for dir : 1 thru dim do (
      numWeq : length(weqLHS),
      for pS : 1 thru numWeq do (
        /* Add contributions from 2*beta-1 nearest lower cells. */
        for s : 1 thru (2*beta-1) do (
          cI : cI+1,

          /* Create three lists. One indicates which contributions should be
             appended as new equations. The other two are to/from lists indicating
             where this new contribution gets added to/from. */
          parentNodes : nodesExF[pS][2],
          childNodes  : nodesExF[cI][2],

          newEqI   : makelist(sublist_indices(childNodes,lambda([x],x=weqNodesExF[cI][2][i]))[1],i,1,length(weqNodesExF[cI][2])),
          contFrom : listify(setdifference(makeset(i,[i],makelist([i],i,1,N)),setify(newEqI))),
          contFromNodes : makelist(nodesExF[cI][2][contFrom[i]],i,1,length(contFrom)),
          weqOwnersIdx  : makelist(assoc(assoc(contFromNodes[i],weqNodeToCellF),cellToIdxF),i,1,length(contFromNodes)),
          contTo : makelist(sublist_indices(weqNodesExF[weqOwnersIdx[i]+1][2],lambda([x],x=contFromNodes[i]))[1],i,1,length(contFromNodes)),

          /* Use the local expansion coefficients, with. */
          cFld_e : doExpand(assoc(coordFtoC[cI][2],cellToCoefC),bN),
          fFld_e : doExpand(cellToCoefF[cI][2],bN),

          /* Compute the inner product, on fine grid of current cell,
             of the coarse field times the basis fine-grid functions. */
          innerProdLHS : calcInnerProdListGen(varsC,intLims[cI],1,bN,subst(makelist(varsC[i]=varMap[cI][i],i,1,dim),cFld_e)),
          innerProdRHS : calcInnerProdListGen(varsC,intLims[cI],1,bN,fFld_e),

          /* New equations. */
          weqLHS : endcons(makelist(innerProdLHS[newEqI[k]],k,1,length(newEqI)),weqLHS),
          weqRHS : endcons(makelist(innerProdRHS[newEqI[k]],k,1,length(newEqI)),weqRHS),
          /* Contributions to existing equations. */
          for k : 1 thru length(contTo) do (
            weqLHS[weqOwnersIdx[k]+1][contTo[k]] : weqLHS[weqOwnersIdx[k]+1][contTo[k]]+innerProdLHS[contFrom[k]],
            weqRHS[weqOwnersIdx[k]+1][contTo[k]] : weqRHS[weqOwnersIdx[k]+1][contTo[k]]+innerProdRHS[contFrom[k]]
          )

        )
      )
    ),
    weqLHS      : flatten(weqLHS),
    weqRHS      : flatten(weqRHS),
    weqUnknowns : listofvars(weqRHS),
    weqKnowns   : listofvars(weqLHS),
    eqSolv      : linsolve(makelist(weqLHS[i]=weqRHS[i],i,1,length(weqLHS)),weqUnknowns),

    eqSolvLHS : makelist(lhs(eqSolv[i]),i,1,length(eqSolv)),
    eqSolvRHS : makelist(rhs(eqSolv[i]),i,1,length(eqSolv)),

    /* Remove contributions to memory locations in fine-grid
       cells not passed to the kernel. */
    fFldCoefs : [makelist(fldF0[i],i,0,numStoredNodes-1)],
    idx       : 1,
    for dI : 1 thru dim do (
      cellsSoFar : length(fFldCoefs),
      for pS : 1 thru cellsSoFar do (
        for k : 1 thru (2*beta-1) do (  /* Add 2*beta-1 nearest lower fine-grid cells. */
          fFldCoefs : endcons([makelist(eval_string(sconcat("fldF",idx))[i],i,0,numStoredNodes-1)],fFldCoefs),
          idx       : idx+1
        )
      )
    ),
    dummyVars : listify(setdifference(setify(weqUnknowns),setify(flatten(fFldCoefs)))),
    keepIdx   : listify(setdifference(makeset(i,[i],makelist([i],i,1,length(eqSolvRHS))),setify(makelist(sublist_indices(weqUnknowns,lambda([x],x=dummyVars[i]))[1],i,1,length(dummyVars))))),
    eqSolvLHS : makelist(eqSolvLHS[keepIdx[i]],i,1,length(keepIdx)),
    eqSolvRHS : makelist(eqSolvRHS[keepIdx[i]],i,1,length(keepIdx)),

    /* Only retain the contributions from the coarse cell passed to the kernel. */
    cFldCoefs : makelist(fldC0[i],i,0,numStoredNodes-1),
    dummyVars : listify(setdifference(setify(weqKnowns),setify(cFldCoefs))),
    eqSolvRHS : subst(makelist(dummyVars[i]=0,i,1,length(dummyVars)),eqSolvRHS),
    keepIdx   : listify(setdifference(makeset(i,[i],makelist([i],i,1,length(eqSolvRHS))),setify(sublist_indices(eqSolvRHS,lambda([x],x=0))))), 
    eqSolvLHS : makelist(eqSolvLHS[keepIdx[i]],i,1,length(keepIdx)),
    eqSolvRHS : makelist(eqSolvRHS[keepIdx[i]],i,1,length(keepIdx)),
    /* Also need to remove the number from the coarse-grid field variable name. */
    eqSolvRHS : subst(makelist(fldC0[i]=fldC[i],i,0,numStoredNodes-1),eqSolvRHS),


    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const double *fldC, double **fldF) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // fldC: coarse-grid field.~%"),
    printf(fh, "  // fldF: fine-grid field in cells pointed to by the stencil.~%"),
    printf(fh, "~%"),

    /* Create a pointer to each cell used by stencil. */
    ptrIdxsF : unique(makelist(eval_string(split(strim("fldF",string(eqSolvLHS[i])),"[")[1]),i,1,length(eqSolvLHS))),
    for i : 1 thru length(ptrIdxsF) do (
      printf(fh, "  double *fldF~a = fldF[~a];~%", ptrIdxsF[i], ptrIdxsF[i])
    ),
    printf(fh, "~%"),

    writeIncrExprs(eqSolvLHS,eqSolvRHS),

    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$

calcFEMRestrictionOp(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Restriction operator transfering a fine-grid field to the
     coarse grid. For now we'll limit ourselves to the compact
     stencil of width=2. */
  stencilWidth : 2,
  stencilSize  : stencilWidth^dim,
  fldF         : [fldF1, fldF2, fldF3, fldF4, fldF5, fldF6, fldF7, fldF8],

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  for polyOrder : 1 thru pMax do (
    bN : getNodalBasis(basisFun, dim, polyOrder),
    N  : length(bN),

    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(double **fldF, double *fldC) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // fldF: fine-grid field in stencils pointed to by the stencil.~%"),
    printf(fh, "  // fldC: coarse-grid field.~%"),
    printf(fh, "~%"),

    /* Create a pointer to each cell used by stencil. */
    for sI : 1 thru stencilSize do (
      printf(fh, "  double *fldF~a = fldF[~a];~%", sI, sI-1)
    ),
    printf(fh, "~%"),

    /* Coarse field expansion and list of coefficients. */
    cFld_e : doExpand1(fldC,bN),         /* Expand coarse field in basis. */
    cFld_c : makelist(fldC[i],i,0,N-1),

    /* Create a table of the relationship between the logical coordinates
       in each direction of the coarse and fine grids, that is, the linear map
         xi_c = L(xi_f)
       where xi_c and xi_f are the is the coarse and fine logical coordinates. */
    varMap    : makelist(0,i,1,stencilSize),
    varMap[1] : makelist((varsC[i]-1)/2,i,1,dim),
    cellCount : 1,
    for dir : 1 thru dim do (
      for rI : 1 thru stencilWidth^(dir-1) do (
        cellCount              : cellCount + 1,
        varMap[cellCount]      : copylist(varMap[rI]),
        varMap[cellCount][dir] : (varsC[dir]+1)/2
      )
    ),

    IfFld : 0,
    /* Loop through fine-grid cells contributing to this coarse cell. */
    for sI : 1 thru stencilSize do (

      /* Expansion and coefficients of current cell fine-grid field. */
      fFld_e : doExpand1(fldF[sI],bN),
      fFld_c : makelist(fldF[sI][i],i,0,N-1),

      /* Compute the inner product, on fine grid of current cell,
         of the coarse field times the basis fine-grid functions. */
      IcFld : calcInnerProdList(varsC,1.0,bN,subst(makelist(varsC[i]=varMap[sI][i],i,1,dim),cFld_e)),

      /* IcFld gives the prolongation operator transformations.
         The restriction operator is the transpose of that, times some
         power of the coarsening factor. */
      IfFld_v : (1/2^dim)*(transpose(coefmatrix(IcFld,cFld_c))).fFld_c,
      IfFld   : IfFld+makelist(IfFld_v[i][1],i,1,N)

    ),
    
    writeCExprs1(fldC,IfFld),
    printf(fh, "~%"),

    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$
