/* Kernels for the smoothing/relaxation operators for
   the Poisson equation
         - L(phi) = rho
   where L=Laplacian, using an FEM method. */

load("modal-basis");
load("out-scripts");
load("nodalOperations/nodalFunctions");
fpprec : 24$

/* String used for identifying nearest neighbor cells. */
neighStrKey : [[-1,"L"],[0,""],[1,"U"]]$

/* Types of boundary conditions for which to generate kernels.
     =0 periodic
     =3 Robin (also used for Dirichlet and Neumann)
   For periodic we'll assume ghost cells are filled accordingly
   and use an interior stencil. */
bcTypes  : [0, 3]$
bcStrs   : ["", "Robin"]$
bcKey    : [[bcTypes[1],bcStrs[1]],[bcTypes[2],bcStrs[2]]]$


writeCExprs1noPowers(lhs, rhs, qPow, numElemMax) := block([expr],
  /* Search for powers of the quantities in qPow. If one of them is found
     then define a temporary variable for it before writing out the increment. */

  exprN : length(rhs),

  /* Elimate the exponents as needed. */
  subList : [],
  maxExponent : 8,
  for eI : 1 thru length(qPow) do (
    for d : 0 thru numElemMax-1 do (
      for f : 2 thru maxExponent do (
        doSub : false,
        for k : 1 thru exprN do (
          if (not freeof(qPow[eI][d]^f,rhs[k])) then ( doSub : true )
        ),
        if (doSub) then (
          /* Define a separate variable. */
          lhsS : sconcat("  const double ",string(qPow[eI]),d,"R",f),
          rhsS : sconcat("std::pow(",string(qPow[eI][d]),",",f,");~%"),
          printf(fh, sconcat(lhsS," = ",rhsS)),
          /* Add to the string substitution list, used in writing file. */
          subList : append(subList,[[sconcat(string(qPow[eI][d]), "^",f), sconcat(string(qPow[eI]),d,"R",f)]])
        )
      )
    )
  ),
  printf(fh, "~%"),

  expr : float(rhs),
  for i : 1 thru exprN do (
    if expr[i] # 0.0 then (
      ep : string(expr[i]),
      if (length(subList) > 0) then (
        outStr : ssubst(subList[1][2],subList[1][1],ep),
        for s : 2 thru length(subList) do (
          outStr : ssubst(subList[s][2],subList[s][1],outStr)
        )
      ) else (
        outStr : ep
      ),
      printf(fh, "  ~a = ~a; ~%", lhs[i-1], outStr)
    )
  )
)$

calcGaussSeidelOp(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Cellwise (damped) Gauss-Seidel relaxation on the Poisson
     equation using an FEM method. */

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  /* This is used in placing (string) variables in kernel boundary names. */
  sVarsC    : copylist(varsC),
  for d : 1 thru dim do ( sVarsC[d] : string(varsC[d]) ),
  condVarsC : [[-1,sVarsC],[0,makelist("",i,1,dim)],[1,sVarsC]],

  for polyOrder : 1 thru pMax do (

    bN : getNodalBasis(basisFun, dim, polyOrder),

    /* Figure out which nodes are saved in this cell. */
    nodes     : args(getNodes(basisFun, dim, polyOrder)),
    numNodes  : length(nodes), 
    cellNodes : copylist(nodes),
    for i : 1 thru numNodes do (
      removeNode : false,
      for d : 1 thru dim do (
        if (nodes[i][d] = 1) then ( removeNode : true )
      ),
      if removeNode then ( cellNodes : delete(nodes[i],cellNodes) )
    ),

    numCellNodes : 1+(polyOrder-1)*dim, /* Number of nodes stored per cell. */

    /* We can build the stencil by mapping a single inner product to that
       of 2^dim cells. Need to map the contribution of each basis function.
       basisMap is a list with an element for each cell abutting the lower left node.
       Each of these elements is itself a list of two indices, the first indicating which
       node contributes from that cell, and the second indicating to which node in the
       first cell it contributes. */
    basisMap : [],
    firstMap : [],
    for k : 1 thru numCellNodes do (
      idx : sublist_indices(nodes,lambda([x],x=cellNodes[k]))[1],
      firstMap : endcons([idx,idx],firstMap)
    ),
    basisMap : endcons(firstMap,basisMap),
    prevToNodes   : [],
    prevFromNodes : [],
    prevToNodes   : endcons(cellNodes,prevToNodes),
    prevFromNodes : endcons(cellNodes,prevFromNodes),
    for dI : 1 thru dim do (
      prevMap : copylist(basisMap),
      for pS : 1 thru length(prevMap) do (
        /* First discard notes from this cell that don't contribute. */
        toNodes   : copylist(sublist(prevToNodes[pS],lambda([x],x[dI]=-1))),
        fromNodes : copylist(sublist(prevFromNodes[pS], lambda([x],x[dI]=-1))),

        for j : 1 thru length(fromNodes) do ( fromNodes[j][dI] : (-1)*fromNodes[j][dI] ),

        prevToNodes   : endcons(toNodes,prevToNodes),
        prevFromNodes : endcons(fromNodes,prevFromNodes),

        newNodeMap : [],
        for k : 1 thru length(toNodes) do (
          toIdx      : sublist_indices(nodes,lambda([x],x=toNodes[k]))[1],
          fromIdx    : sublist_indices(nodes,lambda([x],x=fromNodes[k]))[1],
          newNodeMap : endcons([fromIdx,toIdx],newNodeMap)
        ),
        basisMap : endcons(newNodeMap,basisMap)
      )
    ),

    nodeToCoef : [],
    for i : 1 thru numCellNodes do (
      nodeToCoef : append(nodeToCoef,[[cellNodes[i],i-1]])
    ),

    /* Create a map (dataMap) indicating, for the inner product in each cell abutting the
       lower left nodes, where the coefficients come from (cell and node). */
    dataMap     : [],
    cellNodeLoc : [makelist(makelist(0,k,1,dim),i,1,numNodes)],
    fromCoef    : makelist(0,i,1,numNodes),
    for i : 1 thru numNodes do (
      for d : 1 thru dim do ( if (nodes[i][d] = 1) then ( 
        cellNodeLoc[1][i][d] : 1+cellNodeLoc[1][i][d]
      ) ),
      fromCell : "",
      for d : 1 thru dim do (
        fromCell : sconcat(fromCell,assoc(cellNodeLoc[1][i][d],neighStrKey),assoc(cellNodeLoc[1][i][d],condVarsC)[d])
      ),
      if (slength(fromCell) = 0) then ( fromCell : "C" ),

      localNode : copylist(nodes[i]),
      for d : 1 thru dim do ( if (localNode[d] = 1) then ( localNode[d] : -1 ) ),
      fromCoef[i] : sconcat(fromCell,string([assoc(localNode,nodeToCoef)]))
    ),
    dataMap : endcons(fromCoef,dataMap),

    for dI : 1 thru dim do (
      prevMap : copylist(dataMap),
      for pS : 1 thru length(prevMap) do (
        newLoc     : copylist(cellNodeLoc[pS]),
        fromCoef   : makelist(0,i,1,numNodes),
        for i : 1 thru numNodes do (
          newLoc[i][dI] : newLoc[i][dI]-1,
          fromCell : "",
          for d : 1 thru dim do (
            fromCell : sconcat(fromCell,assoc(newLoc[i][d],neighStrKey),assoc(newLoc[i][d],condVarsC)[d])
          ),
          if (slength(fromCell) = 0) then ( fromCell : "C" ),

          localNode : copylist(nodes[i]),
          for d : 1 thru dim do ( if (localNode[d] = 1) then ( localNode[d] : -1 ) ),
          fromCoef[i] : sconcat(fromCell,string([assoc(localNode,nodeToCoef)]))
        ),
        cellNodeLoc : endcons(newLoc,cellNodeLoc),
        dataMap     : endcons(fromCoef,dataMap)
      )
    ),

    phi_e : doExpand1(phi,bN),
    rho_e : doExpand1(rho,bN),

    /* Lists where we will store the actual stencil.*/
    stencilLHS : makelist(0,i,1,numNodes),
    stencilRHS : makelist(0,i,1,numNodes),

    innerProdLHS : makelist(0,i,1,numNodes),
    innerProdRHS : makelist(0,i,1,numNodes),

    for dI : 1 thru dim do (

      bNp    : diff(bN,varsC[dI]),
      phip_e : diff(phi_e,varsC[dI]),

      /* Only need to perform the inner product once, and the
         contribution from the various cells will get added
         with a careful mapping of the contributions/nodes. */
      innerProdLHS : innerProdLHS+rdx2SqVol[dI-1]*calcInnerProdList(varsC,1,bNp,phip_e),
      innerProdRHS : innerProdRHS+volFac*calcInnerProdList(varsC,1,bN,rho_e)

    ),

    for nC : 1 thru length(basisMap) do (

      for k : 1 thru length(basisMap[nC]) do (
      
        /* Pick out the corresponding contribution from the generic inner product. */
        currLHS : innerProdLHS[basisMap[nC][k][1]],
        currRHS : innerProdRHS[basisMap[nC][k][1]],
        for s : 1 thru length(dataMap[nC]) do (
          currLHS : subst(phi[s-1]=eval_string(sconcat("phi",dataMap[nC][s])),currLHS),
          currRHS : subst(rho[s-1]=eval_string(sconcat("rho",dataMap[nC][s])),currRHS)
        ),

        /* Change the variable names accordingly. */
        stencilLHS[basisMap[nC][k][2]] : stencilLHS[basisMap[nC][k][2]] + currLHS,
        stencilRHS[basisMap[nC][k][2]] : stencilRHS[basisMap[nC][k][2]] + currRHS

      )

    ),

    /* Solve for the coefficients of this cell to get the stencil. */
    phiC_c       : makelist(phiC[i],i,0,numCellNodes-1),
    cellNodesI   : makelist(basisMap[1][i][1],i,1,numCellNodes),
    stencilSolve : linsolve(makelist(stencilLHS[cellNodesI[i]]=stencilRHS[cellNodesI[i]],i,1,numCellNodes),phiC_c),

    /* Damped Gauss-Seidel method. */
    gsStencil : (1-omega)*phiC_c + omega*makelist(rhs(stencilSolve[i]),i,1,numCellNodes),
    gsStencil : fullratsimp(gsStencil),

    printf(fh, "void ~a_P~a(const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // omega:   relaxation parameter.~%"),
    printf(fh, "  // dx:      cell lengths of cells pointed to by the stencil.~%"),
    printf(fh, "  // bcVals:  values to impose as BCs.~%"),
    printf(fh, "  // rho:     right-side source in the current cell.~%"),
    printf(fh, "  // phiPrev: (Jacobi-only) iterate cells pointed to by the stencil (only use neighbor cells).~%"),
    printf(fh, "  // phi:     iterate cells pointed to by the stencil (Gauss-Seidel), or cell we are currently updating (Jacobi).~%"),
    printf(fh, "~%"),

    /* Pointers to the cell lengths in cells pointed to by the stencil. */
    printf(fh, "  double *dxC  = dx[0]; ~%"),
    printf(fh, "~%"),

    /* This volume factors appears in front of the right-side source term. */
    volumeFac : (1/2)^dim,
    for dir : 1 thru dim do (
      volumeFac : volumeFac*dxC[dir-1]
    ),
    printf(fh, "  double volFac = ~a; ~%", float(volumeFac)),
    printf(fh, "~%"),

    /* Some factors based on cell lengths. */
    printf(fh, "  double rdx2SqVol[~a]; ~%", dim),

    for dir : 1 thru dim do (
      printf(fh, "  rdx2SqVol[~a] = volFac*4.0/(dxC[~a]*dxC[~a]); ~%", dir-1, dir-1, dir-1)
    ),
    printf(fh, "~%"),

    /* Pointers to the data in cells pointed to by the stencil. */
    printf(fh, "  double *phiC = phi[0]; ~%"),
    printf(fh, "  double *rhoC = rho[0]; ~%"),
    i : 1,
    varStrs : [""],
    for d : 1 thru dim do (
      for sI : 1 thru 3^(d-1) do (
        for pm : -1 thru 1 step 2 do (
          i : i + 1,
          varStrs : append(varStrs, [sconcat(varStrs[sI],assoc(pm,neighStrKey),string(varsC[d]))]),
          printf(fh, "  double *phi~a = phi[~a]; ~%", varStrs[i], i-1),
          printf(fh, "  double *rho~a = rho[~a]; ~%", varStrs[i], i-1)
        )
      )
    ),
    printf(fh, "~%"),

    /* Write the relaxation stencil. */
    writeCExprs1noPowers(phiC,gsStencil,[rdx2SqVol],12),
    printf(fh, "~%"),

    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$

calcGaussSeidelOpBoundary(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Boundary kernels for cellwise (damped) Gauss-Seidel relaxation
     on the Poisson equation using an FEM method. */

  kill(varsC, varsP, basisC, basisP),

  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),

  /* This is used in placing (string) variables in kernel boundary names. */
  sVarsC    : copylist(varsC),
  for d : 1 thru dim do ( sVarsC[d] : string(varsC[d]) ),
  condVarsC : [[-1,sVarsC],[0,makelist("",i,1,dim)],[1,sVarsC]],

  /* Create a list with 3^dim elements. Each element is itself an dim-long
     list indicating whether the cell has a lower (=-1) or upper (=1)
     boundary, or no boundary (=0) in that direction. */
  cD : 1,
  stencilLoc  : [makelist(0,i,1,dim)],  /* Center stencil, all zeros. */
  for dir : 1 thru dim do (
    for acI : 1 thru 3^(dir-1) do (  /* Loop through cells already added to stencilLoc. */
      for bI : -1 thru 1 step 2 do (  /* Loop over lower and upper. */
        stencilLoc : append(stencilLoc, copylist([stencilLoc[acI]])),
        stencilLoc[length(stencilLoc)][dir] : bI
      )
    )
  ),

  for sI : 2 thru length(stencilLoc) do (

    /* Count the number of non-periodic boundaries. */
    npBCs : 0,
    for d : 1 thru dim do (
      if (stencilLoc[sI][d] # 0) then ( npBCs : npBCs + 1 )
    ),

    /* Given npBCs non-periodic BCs there are bcN^npBCs possible combinations of
       of that cell's stencil, assuming there are bcN types of BCs. For now
       only Robin BCs are supported (also used for Dirichlet/Neumann). */
    npBCcombos : makelist([bcTypes[i]],i,2,length(bcTypes)),
    for l : 2 thru npBCs do (
      tmp : copylist(npBCcombos),
      npBCcombos : [],
      for cI : 1 thru length(tmp) do ( for bI : 2 thru length(bcTypes) do (
        npBCcombos : append(npBCcombos,[ append(tmp[cI],[bcTypes[bI]]) ])
      ) )
    ),

    /* Loop over BC combinations. Will create a separate kernel for each. */
    for bcI : 1 thru length(npBCcombos) do (

      currBCs : copylist(npBCcombos[bcI]),
      /* It's easier to work with a list of dim elements indicating the BC
         in each direction (rather than npBCcombos), even if it's periodic. */
      nInc : 0,
      for d : 1 thru dim do (
        if (stencilLoc[sI][d] = 0) then (
          currBCs : append(firstn(currBCs,d+nInc-1),[0],lastn(currBCs,length(currBCs)-(d+nInc-1))),
          nInc    : nInc+1
        )
      ),

      boundaryStr : "",
      for d : 1 thru dim do (
        boundaryStr : sconcat(boundaryStr,assoc(stencilLoc[sI][d],boundStrKey),
                              assoc(stencilLoc[sI][d],condVarsC)[d],assoc(currBCs[d],bcKey))
      ),
      boundaryStr : sconcat(boundaryStr,"_"),

      for polyOrder : 1 thru pMax do (

        bN : getNodalBasis(basisFun, dim, polyOrder),

        /* Figure out which nodes are saved in this cell. */
        nodes     : args(getNodes(basisFun, dim, polyOrder)),
        numNodes  : length(nodes),
        cellNodes : copylist(nodes),
        for i : 1 thru numNodes do (
          removeNode : false,
          for d : 1 thru dim do (
            if (nodes[i][d]=1) and (stencilLoc[sI][d]<1) then ( removeNode : true )
          ),
          if removeNode then ( cellNodes : delete(nodes[i],cellNodes) )
        ),
        numCellNodes : length(cellNodes),  /* Number of nodes stored per cell. */

        /* It'll be convenient to have a list of the nodes saved in each
           neighboring cell. neighCellNodes has a list that identifies the cell,
           followed by a list of nodes with coordinates on the [-3,3] extended logical space. */
        neighCellNodes : [[makelist(0,i,1,dim),cellNodes]],
        for dI: 1 thru dim do (
          prevNeighCellNodes : copylist(neighCellNodes),
          for pS : 1 thru length(prevNeighCellNodes) do (
            prevNodes : copylist(neighCellNodes[pS][2]),
            /* Cell one step left. */
            if (stencilLoc[sI][dI] > -1) then (
              if (stencilLoc[sI][dI] = 1) then (
                tmp : copylist(prevNodes),
                for i : 1 thru length(tmp) do (
                  if (tmp[i][dI]=1) then ( prevNodes : delete(tmp[i],prevNodes) )
                )
              ),
              for i : 1 thru length(prevNodes) do ( prevNodes[i][dI] : prevNodes[i][dI]-2 ),
              loc     : copylist(neighCellNodes[pS][1]),
              loc[dI] : -1, 
              neighCellNodes : endcons([loc,prevNodes],neighCellNodes)
            ),
            /* Cell one step right. */
            if (stencilLoc[sI][dI] < 1) then (
              prevNodes      : copylist(neighCellNodes[pS][2]),
              for i : 1 thru length(prevNodes) do ( prevNodes[i][dI] : prevNodes[i][dI]+2 ),
              loc            : copylist(neighCellNodes[pS][1]),
              loc[dI]        : 1, 
              neighCellNodes : endcons([loc,prevNodes],neighCellNodes)
            )
          )
        ),
        /* Make another associative list of nodes on [-3,3] logical
           space, and the cell that holds that node. */
        nodeToCell : [],
        for i : 1 thru length(neighCellNodes) do (
          for k : 1 thru length(neighCellNodes[i][2]) do (
            newEntry   : [neighCellNodes[i][2][k],neighCellNodes[i][1]],
            nodeToCell : endcons(newEntry,nodeToCell)
          )
        ),

        /* We can build the stencil by mapping a single inner product to that
           of 2^dim cells. Need to map the contribution of each basis function.
           basisMap is a list with an element for each cell abutting the lower left node.
           Each of these elements is itself a list of two indices, the first indicating which
           node contributes from that cell, and the second indicating to which node in the
           first cell it contributes. */
        basisMap : [],
        firstMap : [],
        for k : 1 thru numCellNodes do (
          idx : sublist_indices(nodes,lambda([x],x=cellNodes[k]))[1],
          firstMap : endcons([idx,idx],firstMap)
        ),
        basisMap : endcons(firstMap,basisMap),
        prevToNodes   : [],
        prevFromNodes : [],
        prevToNodes   : endcons(cellNodes,prevToNodes),
        prevFromNodes : endcons(cellNodes,prevFromNodes),
        for dI : 1 thru dim do (
          prevMap : copylist(basisMap),
          for pS : 1 thru length(prevMap) do (
            if (stencilLoc[sI][dI]>-1) or (currBCs[dI]=0) then (
              /* First discard notes from this cell that don't contribute. */
              toNodes   : copylist(sublist(prevToNodes[pS],lambda([x],x[dI]=-1))),
              fromNodes : copylist(sublist(prevFromNodes[pS], lambda([x],x[dI]=-1))),
  
              for j : 1 thru length(fromNodes) do ( fromNodes[j][dI] : (-1)*fromNodes[j][dI] ),
  
              prevToNodes   : endcons(toNodes,prevToNodes),
              prevFromNodes : endcons(fromNodes,prevFromNodes),
  
              newNodeMap : [],
              for k : 1 thru length(toNodes) do (
                toIdx      : sublist_indices(nodes,lambda([x],x=toNodes[k]))[1],
                fromIdx    : sublist_indices(nodes,lambda([x],x=fromNodes[k]))[1],
                newNodeMap : endcons([fromIdx,toIdx],newNodeMap)
              ),
              basisMap : endcons(newNodeMap,basisMap)
            )
          )
        ),
 
        nodeToCoef : [],
        for i : 1 thru numCellNodes do (
          nodeToCoef : append(nodeToCoef,[[cellNodes[i],i-1]])
        ),

        /* Create a map (dataMap) indicating, for the inner product in each cell abutting the
           lower left nodes, where the coefficients come from (cell and node). */
        dataMap      : [],
        cellNodeLoc  : [makelist(makelist(0,k,1,dim),i,1,numNodes)],
        fromCoef     : makelist(0,i,1,numNodes),
        innerProdLoc : [makelist(0,i,1,dim)],
        for i : 1 thru numNodes do (
          for d : 1 thru dim do (
            if (nodes[i][d]=1) and ((stencilLoc[sI][d]<1) or (currBCs[d]=0)) then ( 
              cellNodeLoc[1][i][d] : 1+cellNodeLoc[1][i][d]
            )
          ),
          fromCell : "",
          for d : 1 thru dim do (
            fromCell : sconcat(fromCell,assoc(cellNodeLoc[1][i][d],neighStrKey),assoc(cellNodeLoc[1][i][d],condVarsC)[d])
          ),
          if (slength(fromCell) = 0) then ( fromCell : "C" ),

          localNode : copylist(nodes[i]),
          for d : 1 thru dim do (
            if (localNode[d] = 1) and ((stencilLoc[sI][d]<1) or (currBCs[d]=0)) then (
              localNode[d] : -1
            )
          ),
          fromCoef[i] : sconcat(fromCell,string([assoc(localNode,nodeToCoef)]))
        ),
        dataMap : endcons(fromCoef,dataMap),

        
        for dI : 1 thru dim do (
          prevMap : copylist(dataMap),
          for pS : 1 thru length(prevMap) do (
            if (stencilLoc[sI][dI]>-1) or (currBCs[dI]=0) then (
              ipLoc        : copylist(innerProdLoc[pS]),
              ipLoc[dI]    : -1,
              innerProdLoc : endcons(ipLoc,innerProdLoc),

              newLoc       : copylist(cellNodeLoc[pS]),
              fromCoef     : makelist(0,i,1,numNodes),
              for i : 1 thru numNodes do (
                if not ((stencilLoc[sI][dI]=1) and (nodes[i][dI]=1)) then (
                  newLoc[i][dI] : newLoc[i][dI]-1
                ),
                fromCell : "",
                for d : 1 thru dim do (
                  fromCell : sconcat(fromCell,assoc(newLoc[i][d],neighStrKey),assoc(newLoc[i][d],condVarsC)[d])
                ),
                if (slength(fromCell) = 0) then ( fromCell : "C" ),

                localNode : copylist(nodes[i]),
                for d : 1 thru dim do ( localNode[d] : localNode[d]+2*ipLoc[d] ),
                nodeOwner : assoc(localNode,nodeToCell),

                fromCoef[i] : sconcat(fromCell,string([sublist_indices(assoc(nodeOwner,neighCellNodes),lambda([x],x=localNode))[1]-1]))
              ),
              cellNodeLoc : endcons(newLoc,cellNodeLoc),
              dataMap     : endcons(fromCoef,dataMap)
            )
          )
        ),

        printf(fh, "void ~a_~aP~a(const double omega, double **dx, const double *bcVals, double **rho, double **phiPrev, double **phi) ~%{ ~%", funcNm, boundaryStr, polyOrder),
        printf(fh, "  // omega:   relaxation parameter.~%"),
        printf(fh, "  // dx:      cell lengths of cells pointed to by the stencil.~%"),
        printf(fh, "  // bcVals:  values to impose as BCs.~%"),
        printf(fh, "  // rho:     right-side source in the current cell.~%"),
        printf(fh, "  // phiPrev: (Jacobi-only) iterate cells pointed to by the stencil (only use neighbor cells).~%"),
        printf(fh, "  // phi:     iterate cells pointed to by the stencil (Gauss-Seidel), or cell we are currently updating (Jacobi).~%"),
        printf(fh, "~%"),

        phi_e : doExpand1(phi,bN),
        rho_e : doExpand1(rho,bN),

        /* Lists where we will store the actual stencil.*/
        stencilLHS : makelist(0,i,1,numNodes),
        stencilRHS : makelist(0,i,1,numNodes),

        innerProdLHS : makelist(0,i,1,numNodes),
        innerProdRHS : makelist(0,i,1,numNodes),

        /* Volume terms. */
        for dI : 1 thru dim do (
          bNp    : diff(bN,varsC[dI]),
          phip_e : diff(phi_e,varsC[dI]),

          /* Only need to perform the inner product once, and the
             contribution from the various cells will get added
             with a careful mapping of the contributions/nodes. */
          innerProdLHS : innerProdLHS+rdx2SqVol[dI-1]*calcInnerProdList(varsC,1,bNp,phip_e),
          innerProdRHS : innerProdRHS+volFac*calcInnerProdList(varsC,1,bN,rho_e)
        ),

        /* Surface terms. */
        npDirs   : sublist_indices(currBCs, lambda([x],x # 0)),
        surfTerm : makelist(0,i,1,numNodes),
        for dI : 1 thru length(npDirs) do (
          dir      : npDirs[dI],
          dirVar   : varsC[dir],
          surfVars : delete(dirVar,varsC), 

          surfTerm : surfTerm+stencilLoc[sI][dir]*rdx2SqVol[dir-1]
                    *calcInnerProdList(surfVars,1,subst(dirVar=stencilLoc[sI][dir],bN),subst(dirVar=stencilLoc[sI][dir],phi_e))
        ),

        /* Put together volume and surface terms. */
        for nC : 1 thru length(basisMap) do (  /* Loop over cells abutting this cell's nodes. */

          for k : 1 thru length(basisMap[nC]) do (  /* Loop over the basis/nodes that contribute from this cell. */
          
            /* Pick out the corresponding contribution from the generic inner product. */
            currLHS : innerProdLHS[basisMap[nC][k][1]],
            currRHS : innerProdRHS[basisMap[nC][k][1]],
            for s : 1 thru length(dataMap[nC]) do (
              currLHS : subst(phi[s-1]=eval_string(sconcat("phi",dataMap[nC][s])),currLHS),
              currRHS : subst(rho[s-1]=eval_string(sconcat("rho",dataMap[nC][s])),currRHS)
            ),

            /* Change the variable names accordingly. */
            stencilLHS[basisMap[nC][k][2]] : stencilLHS[basisMap[nC][k][2]] + currLHS,
            stencilRHS[basisMap[nC][k][2]] : stencilRHS[basisMap[nC][k][2]] + currRHS,

            if (nC = 1) then (
              /* Now add the surface contributions to the stencil, using
                 the mappings of the central cell. */
              for k : 1 thru length(basisMap[1]) do (
                /* Pick out the corresponding contribution from the generic inner product. */
                currLHS : surfTerm[basisMap[1][k][1]],
                for s : 1 thru length(dataMap[1]) do (
                  currLHS : subst(phi[s-1]=eval_string(sconcat("phi",dataMap[1][s])),currLHS)
                ),
                /* Change the variable names accordingly. */
                stencilLHS[basisMap[1][k][2]] : stencilLHS[basisMap[1][k][2]] + currLHS
              )
    
            )
          )

        ),


        /* Boundary conditions. */
        bcEQs   : [],
        bcCoefs : [], 
        for dI : 1 thru length(npDirs) do (
          dir      : npDirs[dI],
          dirVar   : varsC[dir],
          surfDirs : delete(dir,makelist(i,i,1,dim)),
          surfVars : delete(dirVar,varsC), 

          if (stencilLoc[sI][dir] = -1) then (
            dirBC : [bcVals[6*(dir-1)], bcVals[6*(dir-1)+1], bcVals[6*(dir-1)+2]]
          ) elseif (stencilLoc[sI][dir] = 1) then (
            dirBC : [bcVals[6*(dir-1)+3], bcVals[6*(dir-1)+4], bcVals[6*(dir-1)+5]]
          ),
          robinBC : subst(dirVar=stencilLoc[sI][dir], dirBC[1]*phi_e + dirBC[2]*diff(phi_e,dirVar) = dirBC[3]),

          /* Evaluate at boundary nodes in this direction. */
          boundNodes  : copylist(sublist(nodes,lambda([x],x[dir]=stencilLoc[sI][dir]))),
          boundNodesI : sublist_indices(nodes,lambda([x],x[dir]=stencilLoc[sI][dir])),
          potCoefs    : makelist(phi[boundNodesI[i]-1],i,1,length(boundNodesI)),
          newCoefs    : copylist(potCoefs),
          for k : 1 thru length(boundNodes) do (
            cRobinBC : robinBC,
            for d : 1 thru length(surfDirs) do (
              cRobinBC : subst(surfVars[d]=boundNodes[k][surfDirs[d]],cRobinBC)
            ),

            bounds : sublist_indices(boundNodes[k],lambda([x],abs(x)=1)),
            if (npBCs=1) or (length(bounds)<2) then (
              cornerFac : 1
            ) else (
              /* We will weigh the BCs of each boundary at the corner
                 according to the size of the cell length in that direction. */
              cornerFac : dxC[dir-1]/sum(dxC[bounds[i]-1],i,1,length(bounds))
            ),

            coefPos : sublist_indices(bcCoefs,lambda([x],x=potCoefs[k])),
            if (length(coefPos) > 0) then (
              bcEQs[coefPos[1]] : bcEQs[coefPos[1]]+cornerFac*cRobinBC,
              newCoefs : delete(potCoefs[k],newCoefs)
            ) else (
              bcEQs : endcons(cornerFac*cRobinBC,bcEQs)
            )
          ),
          bcCoefs : append(bcCoefs, newCoefs)
        ),

        bcSol : linsolve(bcEQs,bcCoefs),

        /* The coefficients in bcSol that correspond to this cell will be used
           to replace equations in the weak stencil. Coefficients that correspond
           to other cells will be substituted throughout the stencil. */
        bcElem : makelist(args(bcCoefs[i])[1],i,1,length(bcCoefs)),
        for bI : 1 thru length(bcSol) do (
          cNi : sublist_indices(cellNodes,lambda([x],x=nodes[bcElem[bI]+1])),
          if (length(cNi)>0) then (
            /* Replace the corresponding entry in the stencil. */
            for s : 1 thru length(dataMap[1]) do (
              bcSol[bI] : subst(phi[s-1]=eval_string(sconcat("phi",dataMap[1][s])),bcSol[bI])
            ),
            stencilLHS[bcElem[bI]+1] : rhs(bcSol[bI]) - lhs (bcSol[bI]),
            stencilRHS[bcElem[bI]+1] : 0
          )
        ),
        for bI : 1 thru length(bcSol) do (
          cNi : sublist_indices(cellNodes,lambda([x],x=nodes[bcElem[bI]+1])),
          if (length(cNi)=0) then (
            /* Substitute this node's BC throughout the stencil. */
            for s : 1 thru length(dataMap[1]) do (
              bcSol[bI] : subst(phi[s-1]=eval_string(sconcat("phi",dataMap[1][s])),bcSol[bI])
            ),
            stencilLHS : subst(bcSol[bI],stencilLHS)
          )
        ),

        /* Solve for the coefficients of this cell to get the stencil. */
        phiC_c       : makelist(phiC[i],i,0,numCellNodes-1),
        cellNodesI   : makelist(basisMap[1][i][1],i,1,numCellNodes),
        stencilSolve : linsolve(makelist(stencilLHS[cellNodesI[i]]=stencilRHS[cellNodesI[i]],i,1,numCellNodes),phiC_c),

        /* Damped Gauss-Seidel method. */
        gsStencil : (1-omega)*phiC_c + omega*makelist(rhs(stencilSolve[i]),i,1,numCellNodes),
        gsStencil : fullratsimp(gsStencil),

        /* Pointers to the cell lengths in cells pointed to by the stencil. */
        printf(fh, "  double *dxC  = dx[0]; ~%"),
        printf(fh, "~%"),

        /* This volume factors appears in front of the right-side source term. */
        volumeFac : (1/2)^dim,
        for dir : 1 thru dim do (
          volumeFac : volumeFac*dxC[dir-1]
        ),
        printf(fh, "  double volFac = ~a; ~%", float(volumeFac)),
        printf(fh, "~%"),

        /* Some factors based on cell lengths. */
        printf(fh, "  double rdx2SqVol[~a]; ~%", dim),

        for dir : 1 thru dim do (
          printf(fh, "  rdx2SqVol[~a] = volFac*4.0/(dxC[~a]*dxC[~a]); ~%", dir-1, dir-1, dir-1)
        ),
        printf(fh, "~%"),

        /* Pointers to the data in cells pointed to by the stencil. */
        printf(fh, "  double *phiC = phi[0]; ~%"),
        printf(fh, "  double *rhoC = rho[0]; ~%"),
        i : 1,
        varStrs : [""],
        for d : 1 thru dim do (
          for sI : 1 thru 3^(d-1) do (
            for pm : -1 thru 1 step 2 do (
              i : i + 1,
              varStrs : append(varStrs, [sconcat(varStrs[sI],assoc(pm,neighStrKey),string(varsC[d]))]),
              printf(fh, "  double *phi~a = phi[~a]; ~%", varStrs[i], i-1),
              printf(fh, "  double *rho~a = rho[~a]; ~%", varStrs[i], i-1)
            )
          )
        ),
        printf(fh, "~%"),

        /* Write the relaxation stencil. */
        writeCExprs1noPowers(phiC,gsStencil,[rdx2SqVol,bcVals],12),
        printf(fh, "~%"),

        printf(fh, "}~%"),
        printf(fh, "~%")

      )
    )
  )
)$
